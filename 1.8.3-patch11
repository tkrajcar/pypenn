This is patch11 to PennMUSH 1.8.3. After applying this patch, you will
have version 1.8.3p11

To apply this patch, save it to a file in your top-level 1.8.3p9 MUSH directory,
and do the following:
        patch -p0 < 1.8.3-patch11
        ./configure
        make install

If you use GNU patch 2.2, you probably want the above to be 'patch -b -p0',
not just 'patch -p0'.

Unix (or cygwin) users need not worry about failed hunks in src/switchinc.c,
hdrs/switches.h, hdrs/cmds.h, or hdrs/funs.h. These files are automatically
rebuilt on compile. On the off chance they appear not to be, simply
rm them and re-run make.

Then @shutdown/reboot your MUSH.
    - Shawn/Raevnos


In this patch:
Major changes:
  * The WHO, DOING and SESSION commands are now normal game commands,
    and can be @hook'd, typed in lower-case, etc. (The WHO at the login
    screen is separate.) If you have a softcoded 'who' command, you will
    need to @hook/override WHO for it to continue working. Suggested by
    Bane. [MG]
  * The "take" command has been moved from the hardcode into alias.cnf.
    If you want to keep it as an alias for "get", you should add the line
    "command_alias get take" into your alias.cnf. [MG]

Configuration:
  * The *_file options (connect_file, motd_file, etc) can now be a
    #dbref/attribute instead of a filename, in which case the given
    attribute is evaluated and the result shown in place of the text file.
    Based on patches by Nathan Baum and Mercutio@M*U*S*H. [MG]

Commands:
  * @decompile now takes multiple attribute patterns after the /
    (@dec obj/attr attr2) [GM]
  * @channel/decompile now shows the dbref of the channel mogrifier,
    instead of its name. [SW]
  * @pemit now takes a /port switch, which sends the message to the
    specified port. Suggested by Mercutio. [MG]
  * @hook/list without a <command> now shows all commands which have hooks.
    Based on a patch by Trinsec. [MG]
  * @search now takes multiple <class>=<restriction> pairs. [MG]
  * The IDLE command now takes an optional argument, which it prints back
    to the descriptor which sent the command. [MG]
  * IDLE no longer increases the cmds() for a descriptor. [MG]

Functions:
  * die() now takes up to 700 dice.
  * remove() will now remove a list of words.
  * table() now supports <, > and - as alignment parameters to field width.
  * testlock(<boolexp>, <victim>) tests a lock without setting it.
    Suggested by Mercutio@M*U*S*H. [GM]
  * lnum() now takes a fourth argument: A step. [GM]
  * cwho() now takes an optional second argument, to control whether
    online, offline or all players are returned. Suggested by Mercutio,
    based on a patch by Ifrit. [MG]
  * room(<room>) now returns <room>, instead of #-1. Also, room(<exit>)
    returns the exit's source room, rather than the destination. Suggested
    by Null@M*U*S*H. [MG]
  * Fixed a bug in how align() strips spaces when wrapping text. Reported
    by Paige@M*U*S*H. [MG]
  * pemit(<port number>, <message>) sends <message> to the specified
    port, like @pemit/port. Suggested by Mercutio. [MG]
  * lports() and lwho() take an optional second argument to include
    connections at the login screen. Suggested by Mercutio. [MG]
  * namelist() now takes an optional #dbref/attr, called for each invalid
    name in the first argument. [MG]
  * lmath() can now do lt, lte, gt, gte, eq and neq. Also, lt(), lte(),
    etc, can all take more than 2 arguments. [GM]
  * Anyone can now use ctime() on any object. [MG]
  * locks() reported built-in locks as being user: locks. [MG]

Fixes:
  * Help fixes by various folks.
  * lsearch() with invalid syntax was failing to report it as such, causing
    confusion when lsearch(me,exits) returned the same as lsearch(me). [GM]
  * fun_merge() was eating characters when ansi was present. Reported
    by Nammyung. Fixed. [GM]
  * Windows compile fixes.
  * Math-y crashbug fixed. Reported by Ghost@M*U*S*H. [GM]
  * page/port didn't evaluate its arguments properly. Reported
    by adkins@drigon.com. [SW]
  * randword() with a single element list wasn't dealing correctly
    with extra spaces. Reported by Minion. [SW]
  * @listen/^-listens should now be triggered with the object being
    spoofed as %#, not the object doing the spoofing, when @message/spoof
    (and @pemit/spoof, etc) are used. Reported by Mercutio@M*U*S*H. [MG]
  * Fixed some minor type-related warnings when compiling on cygwin. [MG]
  * @functions which were set "localize" would report being set "Userfn"
    as well, and functions set "Userfn" weren't reported as such. [MG]
  * Objects could be set with flags which weren't valid for their object
    type, if such flags were in the <type>_flags config option. Found by
    Kitai. [MG]
  * Crashbug in the command parser fixed. Found by Freon, patch by Javelin.
  * Added some missing punctuation in channel messages. Reported by Stoko.

   
 Minor changes:
  * @listen/^-listens now carry over ANSI. Requested by Mercutio. [MG]
  * @adisconnect now has %5, which is true if the disconnecting descriptor
    was @hide. Suggested by Minion@M*U*S*H [GM]
  * @pemit <name>= would show nospoof info if <name> was set Nospoof. Now,
    it does nothing at all. Reported by Minion. [MG]
  * The connect screen can now contain ANSI color. Patch by Mercutio.
  * Small bug fix in @search. [MG]
  * Built-in functions can be set FN_LOCALIZE to preserve %q-regs. [MG]
  * Refactoring of ufun(), ulocal(), u[l]default() and ulambda(). [MG]
  * The "Not enough money to queue command" message tells you which object
    was attempting to queue the command. Suggested by Daniel Powell. [MG]

Tools:
  * New script in utils/ for searching change logs: grep-cl.pl [SW]


 BUGS                         |    8 
 CHANGES.183                  |   99 +
 Makefile.in                  |   13 
 Patchlevel                   |    2 
 config.h.in                  |    5 
 game/aliascnf.dst            |    1 
 game/mushcnf.dst             |    4 
 game/txt/hlp/index.hlp       |  969 ++++++-------
 game/txt/hlp/pennchat.hlp    |    9 
 game/txt/hlp/penncmd.hlp     |  166 +-
 game/txt/hlp/pennfunc.hlp    | 3017 +++++++++++++++++++++++--------------------
 game/txt/hlp/penntop.hlp     |   11 
 game/txt/hlp/pennv183.hlp    |  102 +
 game/txt/hlp/pennvOLD.hlp    |    2 
 hdrs/cmds.h                  |  152 --
 hdrs/dbdefs.h                |    5 
 hdrs/externs.h               |    4 
 hdrs/funs.h                  |  382 -----
 hdrs/game.h                  |   15 
 hdrs/version.h               |    6 
 options.h.dist               |   35 
 src/Makefile.in              |    2 
 src/boolexp.c                |    4 
 src/bsd.c                    |  702 +++++++---
 src/chunk.c                  |    6 
 src/cmds.c                   |   39 
 src/command.c                |   98 -
 src/conf.c                   |   19 
 src/cque.c                   |   48 
 src/create.c                 |   45 
 src/extchat.c                |   81 -
 src/extmail.c                |   53 
 src/flags.c                  |    2 
 src/function.c               |   39 
 src/fundb.c                  |   83 -
 src/funlist.c                |  203 +-
 src/funmath.c                |  133 +
 src/funmisc.c                |   17 
 src/funstr.c                 |   24 
 src/funufun.c                |   65 
 src/intmap.c                 |    9 
 src/lmathtab.c               |  203 +-
 src/lmathtab.gperf           |   12 
 src/lock.c                   |    4 
 src/look.c                   |   79 -
 src/malias.c                 |    6 
 src/move.c                   |    8 
 src/notify.c                 |   45 
 src/parse.c                  |   41 
 src/pcre.c                   |    4 
 src/player.c                 |   16 
 src/predicat.c               |    8 
 src/rob.c                    |    2 
 src/set.c                    |    6 
 src/speech.c                 |   64 
 src/unparse.c                |   14 
 src/utils.c                  |   16 
 src/wiz.c                    |   35 
 utils/README.txt             |    2 
 utils/grep-cl.pl             |   79 +
 win32/cmds.h                 |   11 
 win32/funs.h                 |   11 
 win32/msvc6/pennmush.dsp     |   16 
 win32/vs2005/pennmush.vcproj |   10 
 win32/vs2008/pennmush.vcproj |   10 
 65 files changed, 4042 insertions(+), 3339 deletions(-)


Prereq: 1.8.3p10
===================================================================
--- Patchlevel	(.../183p10)	(revision 142)
+++ Patchlevel	(.../183p11)	(revision 142)
@@ -1,3 +1,3 @@
 Do not edit this file. It is maintained by the official PennMUSH patches.
-This is PennMUSH 1.8.3p10
+This is PennMUSH 1.8.3p11
 
Index: Makefile.in
===================================================================
--- Makefile.in	(.../183p10)	(revision 142)
+++ Makefile.in	(.../183p11)	(revision 142)
@@ -3,13 +3,13 @@
 # - System configuration - #
 
 VERSION=1.8.3
-PATCHLEVEL=10
+PATCHLEVEL=11
 
 #
-# This section of the file should be automatically configured by
-# the Configure script. If it doesn't work, you might try starting
-# from the Makefile.old that's included instead, and reporting
-# your problem (including this Makefile) to pennmush-bugs@pennmush.org
+# This section of the file should be automatically configured by the
+# Configure script. If it doesn't work, you might try reporting your
+# problem (including this Makefile) at
+# http://code.google.com/p/pennmush/issues/list
 #
 # If you want to profile the code, add -pg -a -DPROFILING to CCFLAGS
 # and (probably) remove -O
@@ -206,6 +206,9 @@
 ctags:
 	(cd src; make ctags)
 
+cscope:
+	cscope *.h hdrs/*.h src/*.c
+
 touchswitches:
 	@@TOUCH@ src/SWITCHES
 
Index: options.h.dist
===================================================================
--- options.h.dist	(.../183p10)	(revision 142)
+++ options.h.dist	(.../183p11)	(revision 142)
@@ -1,25 +1,26 @@
-/* options.h */
+/* options.h -*- c -*- */
 
 #ifndef __OPTIONS_H
 #define __OPTIONS_H
 
 /* *********** READ THIS BEFORE YOU MODIFY ANYTHING IN THIS FILE *********** */
-/* WARNING:  All options in this file have the ability to significantly change
- * the look and feel and sometimes even internal behavior of the program.
- * The ones shipped as the default have been extensively tested.  Others have
- * been tested to a (usually) lesser degree, and therefore might still have
- * latent bugs.  If you change any of them from the default, PLEASE check
- * to make sure that you know the full effects of what you are changing. And
- * if you encounter any errors or compile time problems with any options
- * other than the default settings, PLEASE inform 
- * pennmush-bugs@pennmush.org
- * immediately, so that they can be fixed.  The same goes for any other bug
- * you might find in using this software.  All efforts will be made to fix
- * errors encountered, but unless given a FULL description of the error,
- * (IE telling me that logging in doesn't work is insufficient.  telling
- * me that logging in with WCREAT undefined still gives you the registration
- * message is a lot better.  MOST effective would be a full dbx trace, or a
- * patch for the bug.)  Enjoy using the program.
+/* WARNING: All options in this file have the ability to significantly
+ * change the look and feel and sometimes even internal behavior of
+ * the program.  The ones shipped as the default have been extensively
+ * tested.  Others have been tested to a (usually) lesser degree, and
+ * therefore might still have latent bugs.  If you change any of them
+ * from the default, PLEASE check to make sure that you know the full
+ * effects of what you are changing. And if you encounter any errors
+ * or compile time problems with any options other than the default
+ * settings, PLEASE file a ticket at
+ * http://code.google.com/p/pennmush/issues/list immediately, so that
+ * they can be fixed.  The same goes for any other bug you might find
+ * in using this software.  All efforts will be made to fix errors
+ * encountered, but unless given a FULL description of the error, (IE
+ * telling me that logging in doesn't work is insufficient.  telling
+ * me that logging in with WCREAT undefined still gives you the
+ * registration message is a lot better.  MOST effective would be a
+ * full gdb trace, or a patch for the bug.)  Enjoy using the program.
  */
 /***************************************************************************/
 
Index: src/fundb.c
===================================================================
--- src/fundb.c	(.../183p10)	(revision 142)
+++ src/fundb.c	(.../183p11)	(revision 142)
@@ -36,18 +36,9 @@
 extern struct db_stat_info *get_stats(dbref owner);
 static int lattr_helper(dbref player, dbref thing, dbref parent,
                         char const *pattern, ATTR *atr, void *args);
-static dbref
-
-
-
-
-
-
-
-dbwalk(char *buff, char **bp, dbref executor, dbref enactor,
-       int type, dbref loc, dbref after, int skipdark,
-       int start, int count, int *retcount);
-
+static dbref dbwalk(char *buff, char **bp, dbref executor, dbref enactor,
+                    int type, dbref loc, dbref after, int skipdark,
+                    int start, int count, int *retcount);
 
 const char *
 do_get_attrib(dbref executor, dbref thing, const char *attrib)
@@ -337,7 +328,7 @@
     add_check("fun_eval.attr_value");
     process_expression(buff, bp, &tp, thing, executor, executor,
                        PE_DEFAULT, PT_DEFAULT, pe_info);
-    mush_free((Malloc_t) tbuf, "fun_eval.attr_value");
+    mush_free(tbuf, "fun_eval.attr_value");
     return;
   } else if (a || !Can_Examine(executor, thing)) {
     safe_str(T(e_atrperm), buff, bp);
@@ -377,7 +368,7 @@
     add_check("fun_eval.attr_value");
     process_expression(buff, bp, &tp, thing, executor, executor,
                        PE_DEFAULT, PT_DEFAULT, pe_info);
-    mush_free((Malloc_t) tbuf, "fun_eval.attr_value");
+    mush_free(tbuf, "fun_eval.attr_value");
     return;
   } else if (a || !Can_Examine(executor, thing)) {
     safe_str(T(e_atrperm), buff, bp);
@@ -414,7 +405,7 @@
     add_check("fun_edefault.attr_value");
     process_expression(buff, bp, &sp, thing, executor, executor,
                        PE_DEFAULT, PT_DEFAULT, pe_info);
-    mush_free((Malloc_t) sbuf, "fun_edefault.attr_value");
+    mush_free(sbuf, "fun_edefault.attr_value");
     return;
   }
   /* We couldn't get it. Evaluate args[1] and return it */
@@ -604,7 +595,7 @@
       safe_str(T(e_match), buff, bp);
       break;
     case AMBIGUOUS:
-      safe_str(T("#-1 AMBIGUOUS MATCH"), buff, bp);
+      safe_str("#-2", buff, bp);
       break;
     default:
       safe_dbref(thing, buff, bp);
@@ -1008,7 +999,7 @@
    * then we want to know about the whole object; otherwise, we're
    * just interested in a single attribute.
    * If we encounter an error, we return 0 rather than an error
-   * code, since if it doesn't exist, it obviously can't see 
+   * code, since if it doesn't exist, it obviously can't see
    * anything or be seen.
    */
 
@@ -1378,6 +1369,32 @@
 }
 
 /* ARGSUSED */
+FUNCTION(fun_testlock)
+{
+  dbref victim = match_thing(executor, args[1]);
+  boolexp elock = TRUE_BOOLEXP;
+
+  elock = parse_boolexp(executor, args[0], "Search");
+
+  if (elock == TRUE_BOOLEXP) {
+    safe_str("#-1 INVALID BOOLEXP", buff, bp);
+    return;
+  }
+
+  if (!GoodObject(victim)) {
+    safe_str("#-1", buff, bp);
+    return;
+  }
+  if (Can_Locate(executor, victim)) {
+    safe_boolean(eval_boolexp(victim, elock, executor), buff, bp);
+  } else {
+    safe_str("#-1", buff, bp);
+  }
+  free_boolexp(elock);
+  return;
+}
+
+/* ARGSUSED */
 FUNCTION(fun_findable)
 {
   dbref obj = match_thing(executor, args[0]);
@@ -1428,8 +1445,6 @@
 
   if (!GoodObject(it) || IsGarbage(it))
     safe_str(T(e_notvis), buff, bp);
-  else if (!Can_Examine(executor, it))
-    safe_str(T(e_perm), buff, bp);
   else
     safe_str(show_time(CreTime(it), utc), buff, bp);
 }
@@ -1440,8 +1455,6 @@
 
   if (!GoodObject(it) || IsGarbage(it))
     safe_str(T(e_notvis), buff, bp);
-  else if (!Can_Examine(executor, it))
-    safe_str(T(e_perm), buff, bp);
   else
     safe_integer((intmax_t) CreTime(it), buff, bp);
 }
@@ -1650,7 +1663,7 @@
   /* If the thing in question has unlimited money, respond with the
    * max money possible. We don't use the NoPay macro, though, because
    * we want to return the amount of money stored in an object, even
-   * if its owner is no_pay. Softcode can check money(owner(XX)) if 
+   * if its owner is no_pay. Softcode can check money(owner(XX)) if
    * they want to allow objects to pay like their owners.
    */
   if (has_power_by_name(it, "NO_PAY", NOTYPE))
@@ -1836,6 +1849,18 @@
   char *current;
   dbref target;
   const char *start;
+  int report = 0;
+  ufun_attrib ufun;
+  char *wenv[2];
+
+  if (nargs > 1 && args[1] && *args[1]) {
+    if (fetch_ufun_attrib(args[1], executor, &ufun, 1)) {
+      report = 1;
+    } else {
+      safe_str(ufun.errmess, buff, bp);
+      return;
+    }
+  }
 
   start = args[0];
   while (start && *start) {
@@ -1848,12 +1873,14 @@
     target = lookup_player(current);
     if (!GoodObject(target))
       target = visible_short_page(executor, current);
-    if (target == NOTHING) {
-      safe_str("#-1", buff, bp);
-    } else if (target == AMBIGUOUS) {
-      safe_str("#-2", buff, bp);
-    } else {
-      safe_dbref(target, buff, bp);
+    safe_dbref(target, buff, bp);
+    if (target == NOTHING || target == AMBIGUOUS) {
+      if (report) {
+        wenv[0] = current;
+        wenv[1] = unparse_dbref(target);
+        if (call_ufun(&ufun, wenv, 2, NULL, executor, enactor, pe_info))
+          report = 0;
+      }
     }
   }
 }
Index: src/extchat.c
===================================================================
--- src/extchat.c	(.../183p10)	(revision 142)
+++ src/extchat.c	(.../183p11)	(revision 142)
@@ -168,7 +168,7 @@
      } \
     } while (0)
 
-/** A macro to test if a channel exists and player's on it, and, 
+/** A macro to test if a channel exists and player's on it, and,
  * if not, to notify. */
 #define test_channel_on(player,name,chan) \
    do { \
@@ -855,7 +855,7 @@
  * Some utility functions:
  *  find_channel - given a name and a player, return a channel
  *  find_channel_partial - given a name and a player, return
- *    the first channel that matches name 
+ *    the first channel that matches name
  *  find_channel_partial_on - given a name and a player, return
  *    the first channel that matches name that player is on.
  *  onchannel - is player on channel?
@@ -863,7 +863,7 @@
 
 /** Removes markup and <>'s in channel names.
  * \param name The name to normalize.
- * \retval a pointer to a static buffer with the normalized name. 
+ * \retval a pointer to a static buffer with the normalized name.
  */
 static char *
 normalize_channel_name(const char *name)
@@ -1032,9 +1032,9 @@
 
 /** Attempt to match a channel name for a player.
  * Given name and a chan pointer, set chan pointer to point to
- * channel if found and player is on the channel (NULL otherwise), 
- * and return an indication of how good the match was. If the player is 
- * not able to see the channel, fail to match. If the match is ambiguous, 
+ * channel if found and player is on the channel (NULL otherwise),
+ * and return an indication of how good the match was. If the player is
+ * not able to see the channel, fail to match. If the match is ambiguous,
  * return the first channel matched.
  * \param name name of channel to find.
  * \param chan pointer to address of channel structure to return.
@@ -1081,9 +1081,9 @@
 
 /** Attempt to match a channel name for a player.
  * Given name and a chan pointer, set chan pointer to point to
- * channel if found and player is NOT on the channel (NULL otherwise), 
- * and return an indication of how good the match was. If the player is 
- * not able to see the channel, fail to match. If the match is ambiguous, 
+ * channel if found and player is NOT on the channel (NULL otherwise),
+ * and return an indication of how good the match was. If the player is
+ * not able to see the channel, fail to match. If the match is ambiguous,
  * return the first channel matched.
  * \param name name of channel to find.
  * \param chan pointer to address of channel structure to return.
@@ -1259,7 +1259,7 @@
       if (!Channel_Quiet(chan) && !DarkLegal(victim)) {
         channel_send(chan, victim,
                      CB_CHECKQUIET | CB_PRESENCE | CB_POSE,
-                     T("has joined this channel"));
+                     T("has joined this channel."));
       }
     } else {
       notify_format(player,
@@ -1284,7 +1284,7 @@
       if (!Channel_Quiet(chan) && !DarkLegal(victim)) {
         channel_send(chan, victim,
                      CB_CHECKQUIET | CB_PRESENCE | CB_POSE,
-                     T("has left this channel"));
+                     T("has left this channel."));
       }
       notify_format(victim,
                     T("CHAT: %s removes you from channel <%s>."),
@@ -1789,7 +1789,7 @@
     /* make sure the channel name is unique */
     if (find_channel(perms, &temp, GOD)) {
       /* But allow renaming a channel to a differently-cased version of
-       * itself 
+       * itself
        */
       if (temp != chan) {
         notify(player, T("The channel needs a more unique new name."));
@@ -1805,7 +1805,7 @@
     remove_channel(chan);
     strcpy(ChanName(chan), perms);
     insert_channel(&chan);
-    snprintf(announcebuff, BUFFER_LEN, T("has renamed %s to %s"),
+    snprintf(announcebuff, BUFFER_LEN, T("has renamed %s to %s."),
              old, ChanName(chan));
     channel_send(chan, player,
                  CB_CHECKQUIET | CB_PRESENCE | CB_POSE, announcebuff);
@@ -1919,7 +1919,7 @@
 
   /* channel loop */
   do {
-    /* If we have a channel list at the start, 
+    /* If we have a channel list at the start,
      * that means they didn't gave us a channel name,
      * so we now figure out c. */
     if (p != NULL) {
@@ -2168,7 +2168,7 @@
 /* ARGSUSED */
 FUNCTION(fun_cflags)
 {
-  /* With one channel arg, returns list of set flags, as per 
+  /* With one channel arg, returns list of set flags, as per
    * do_channel_list. Sample output: PQ, Oo, etc.
    * With two args (channel,object) return channel-user flags
    * for that object on that channel (a subset of GQH).
@@ -2318,7 +2318,7 @@
    * either you must either be able to examine <object>, or
    * <object> must not be hidden, and either
    *   a) You must be on <channel>, or
-   *   b) You must pass the join-lock 
+   *   b) You must pass the join-lock
    */
   CHAN *c;
   CHANUSER *u;
@@ -2441,7 +2441,7 @@
 
 }
 
-/* Remove all players from a channel, notifying them. This is the 
+/* Remove all players from a channel, notifying them. This is the
  * utility routine for handling it. The command @channel/wipe
  * calls do_chan_wipe, below
  */
@@ -2571,7 +2571,7 @@
     return;
   }
   /* We refund the original owner's money, but don't charge the
-   * new owner. 
+   * new owner.
    */
   chan_chown(c, victim);
   notify_format(player,
@@ -2580,7 +2580,7 @@
   return;
 }
 
-/** Chown all of a player's channels. 
+/** Chown all of a player's channels.
  * This function changes ownership of all of a player's channels. It's
  * usually used before destroying the player.
  * \param old dbref of old channel owner.
@@ -2781,8 +2781,8 @@
       notify_format(player, "@channel/chown %s = %s", ChanName(c),
                     Name(ChanCreator(c)));
       if (ChanMogrifier(c) != NOTHING) {
-        notify_format(player, "@channel/mogrifier %s = %s", ChanName(c),
-                      Name(ChanMogrifier(c)));
+        notify_format(player, "@channel/mogrifier %s = #%d", ChanName(c),
+                      ChanMogrifier(c));
       }
       if (ChanModLock(c) != TRUE_BOOLEXP)
         notify_format(player, "@clock/mod %s = %s", ChanName(c),
@@ -2858,6 +2858,9 @@
 FUNCTION(fun_cwho)
 {
   int first = 1;
+  int matchcond = 0;
+  int priv = 0;
+  int show;
   CHAN *chan = NULL;
   CHANUSER *u;
   dbref who;
@@ -2873,6 +2876,19 @@
     break;
   }
 
+  if (nargs == 2) {
+    if (!strcasecmp(args[1], "on"))
+      matchcond = 0;
+    else if (!strcasecmp(args[1], "off"))
+      matchcond = 1;
+    else if (!strcasecmp(args[1], "all"))
+      matchcond = 2;
+    else {
+      safe_str(T("#-1 INVALID ARGUMENT"), buff, bp);
+      return;
+    }
+  }
+
   /* Feh. We need to do some sort of privilege checking, so that
    * if mortals can't do '@channel/who wizard', they can't do
    * 'think cwho(wizard)' either. The first approach that comes to
@@ -2890,16 +2906,25 @@
     safe_str(T("#-1 NO PERMISSIONS FOR CHANNEL"), buff, bp);
     return;
   }
+
+  priv = Priv_Who(executor);
+
   for (u = ChanUsers(chan); u; u = u->next) {
     who = CUdbref(u);
-    if ((IsThing(who) || Connected(who)) &&
-        (!Chanuser_Hide(u) || Priv_Who(executor))) {
-      if (first)
-        first = 0;
+    show = 1;
+    if (!IsThing(who) && matchcond != 2) {
+      if (matchcond)
+        show = !Connected(who) || (Chanuser_Hide(u) && !priv);
       else
-        safe_chr(' ', buff, bp);
-      safe_dbref(who, buff, bp);
+        show = Connected(who) && (!Chanuser_Hide(u) || priv);
     }
+    if (!show)
+      continue;
+    if (first)
+      first = 0;
+    else
+      safe_chr(' ', buff, bp);
+    safe_dbref(who, buff, bp);
   }
 }
 
@@ -3617,7 +3642,7 @@
   }
   *bp = '\0';
 
-  // @chatformat 
+  // @chatformat
   if (flags & CB_PRESENCE) {
     snprintf(title, BUFFER_LEN, "%s", message);
     snprintf(message, BUFFER_LEN, "%s %s", Name(player), title);
Index: src/utils.c
===================================================================
--- src/utils.c	(.../183p10)	(revision 142)
+++ src/utils.c	(.../183p11)	(revision 142)
@@ -85,8 +85,8 @@
 }
 
 /** Parse an attribute or anonymous attribute into dbref and pointer.
- * This function takes a string which is of the format #lambda/code, 
- * <obj>/<attr> or <attr>,  and returns the dbref of the object, 
+ * This function takes a string which is of the format #lambda/code,
+ * <obj>/<attr> or <attr>,  and returns the dbref of the object,
  * and a pointer to the attribute.
  * \param player the executor, for permissions checks.
  * \param str string to parse.
@@ -465,8 +465,8 @@
 
 
 /** Is an object inside another, at any level of depth?
- * That is, we check if disallow is inside of from, i.e., if 
- * loc(disallow) = from, or loc(loc(disallow)) = from, etc., with a 
+ * That is, we check if disallow is inside of from, i.e., if
+ * loc(disallow) = from, or loc(loc(disallow)) = from, etc., with a
  * depth limit of 50.
  * Despite the name of this function, it's not recursive any more.
  * \param disallow interior object to check.
@@ -536,7 +536,7 @@
 
 
 
-/** Wrapper to choose a seed and initialize the Mersenne Twister PRNG. 
+/** Wrapper to choose a seed and initialize the Mersenne Twister PRNG.
  * The actual MT code lives in SFMT.c and hdrs/SFMT*.h */
 void
 initialize_mt(void)
@@ -698,7 +698,9 @@
   dbref room;
   if (!GoodObject(it))
     return NOTHING;
-  room = Location(it);
+  if (IsRoom(it))
+    return it;
+  room = IsExit(it) ? Home(it) : Location(it);
   if (!GoodObject(room))
     return NOTHING;
   while (!IsRoom(room)) {
@@ -717,7 +719,7 @@
  * INTERACT_SEE (will light rays from 'from' reach 'to'?), INTERACT_HEAR
  * (will sound from 'from' reach 'to'?), INTERACT_MATCH (can 'to'
  * match the name of 'from'?), and INTERACT_PRESENCE (will the arrival/
- * departure/connection/disconnection/growing ears/losing ears of 
+ * departure/connection/disconnection/growing ears/losing ears of
  * 'from' be noticed by 'to'?).
  * \param from object of interaction.
  * \param to subject of interaction, attempting to interact with from.
Index: src/Makefile.in
===================================================================
--- src/Makefile.in	(.../183p10)	(revision 142)
+++ src/Makefile.in	(.../183p11)	(revision 142)
@@ -515,6 +515,8 @@
 cque.o: ../hdrs/mymalloc.h
 cque.o: ../hdrs/game.h
 cque.o: ../hdrs/attrib.h
+cque.o: ../hdrs/function.h
+cque.o: ../hdrs/case.h
 cque.o: ../hdrs/log.h
 cque.o: ../hdrs/intmap.h
 create.o: ../hdrs/copyrite.h
Index: src/malias.c
===================================================================
--- src/malias.c	(.../183p10)	(revision 142)
+++ src/malias.c	(.../183p11)	(revision 142)
@@ -508,7 +508,7 @@
   if (Wizard(player) || (m->owner == player)) {
     notify(player, T("MAIL: Alias Destroyed."));
     if (m->members)
-      mush_free((Malloc_t) m->members, "malias_members");
+      mush_free(m->members, "malias_members");
     if (m->name)
       mush_free(m->name, "malias_name");
     if (m->desc)
@@ -698,9 +698,9 @@
       if (m->desc)
         mush_free(m->desc, "malias_desc");
       if (m->members)
-        mush_free((Malloc_t) m->members, "malias_members");
+        mush_free(m->members, "malias_members");
     }
-    mush_free((Malloc_t) malias, "malias_list");
+    mush_free(malias, "malias_list");
   }
   ma_size = ma_top = 0;
   notify(player, T("MAIL: All mail aliases destroyed!"));
Index: src/wiz.c
===================================================================
--- src/wiz.c	(.../183p10)	(revision 142)
+++ src/wiz.c	(.../183p11)	(revision 142)
@@ -190,7 +190,7 @@
     notify_format(player, T("Objects: %d   Limit: UNLIMITED"), owned);
     return;
   }
-  /* if we're not doing a change, determine the mortal's quota limit. 
+  /* if we're not doing a change, determine the mortal's quota limit.
    * RQUOTA is the objects _left_, not the quota itself.
    */
 
@@ -382,8 +382,8 @@
   /* get destination */
 
   if (!strcasecmp(to, "home")) {
-    /* If the object is @tel'ing itself home, treat it the way we'd  
-     * treat a 'home' command 
+    /* If the object is @tel'ing itself home, treat it the way we'd
+     * treat a 'home' command
      */
     if (player == victim) {
       if (command_check_byname(victim, "HOME"))
@@ -435,7 +435,7 @@
         loc = find_entrance(victim);
       else
         loc = Home(victim);
-      /* Unlike normal teleport, you must control the destination 
+      /* Unlike normal teleport, you must control the destination
        * or have the open_anywhere power
        */
       if (!(tport_control_ok(player, victim, loc) &&
@@ -1158,6 +1158,7 @@
 {
   char tbuf[BUFFER_LEN], *arg2 = tbuf, *tbp;
   dbref *results = NULL;
+  char *s;
   int nresults;
 
   /* parse first argument into two */
@@ -1198,12 +1199,22 @@
     }
   }
   {
-    const char *myargs[4];
+    const char *myargs[MAX_ARG];
+    int i;
+    int j = 2;
+
     myargs[0] = arg2;
     myargs[1] = arg3[1];
-    myargs[2] = arg3[2];
-    myargs[3] = arg3[3];
-    nresults = raw_search(player, tbuf, 4, myargs, &results, NULL);
+    for (i = 2; i < INT_MAX && (arg3[i] != NULL); i++) {
+      if ((s = strchr(arg3[i], '='))) {
+        *s++ = '\0';
+        myargs[j++] = arg3[i];
+        myargs[j++] = s;
+      } else {
+        myargs[j++] = arg3[i];
+      }
+    }
+    nresults = raw_search(player, tbuf, j, myargs, &results, NULL);
   }
 
   if (nresults == 0) {
@@ -1755,6 +1766,11 @@
     notify(player, T("Unknown owner."));
     return -1;
   }
+  // An odd number of search classes is invalid.
+  if (nargs % 2) {
+    notify(player, T("Invalid search class+restriction format."));
+    return -1;
+  }
 
   for (n = 0; n < nargs - 1; n += 2) {
     class = args[n];
@@ -1960,7 +1976,6 @@
   char lbuff[BUFFER_LEN];
 
   if (fill_search_spec(player, owner, nargs, args, &spec) < 0) {
-    giveto(player, FIND_COST);
     if (spec.lock != TRUE_BOOLEXP)
       free_boolexp(spec.lock);
     return -1;
@@ -2048,7 +2063,7 @@
       bp = tbuf1;
       process_expression(tbuf1, &bp, &ebuf2, player, player, player,
                          PE_DEFAULT, PT_DEFAULT, pe_info);
-      mush_free((Malloc_t) ebuf1, "replace_string.buff");
+      mush_free(ebuf1, "replace_string.buff");
       *bp = '\0';
       if (!parse_boolean(tbuf1))
         continue;
Index: src/unparse.c
===================================================================
--- src/unparse.c	(.../183p10)	(revision 142)
+++ src/unparse.c	(.../183p11)	(revision 142)
@@ -195,7 +195,8 @@
   ATTR *a;
   char *wsave[10], *rsave[NUMQ];
   char *arg, *bp, *arg2;
-  char const *sp, *save;
+  char const *sp;
+  char *save;
 
   int j;
   a = atr_get(loc, "NAMEFORMAT");
@@ -220,13 +221,13 @@
     process_expression(tbuf1, &bp, &sp, loc, player, player,
                        PE_DEFAULT, PT_DEFAULT, NULL);
     *bp = '\0';
-    free((Malloc_t) save);
+    free(save);
     for (j = 0; j < 10; j++) {
       global_eval_context.wenv[j] = wsave[j];
     }
     restore_global_regs("nameformat", rsave);
-    mush_free((Malloc_t) arg, "string");
-    mush_free((Malloc_t) arg2, "string");
+    mush_free(arg, "string");
+    mush_free(arg2, "string");
     return 1;
   } else {
     /* No @nameformat attribute */
@@ -290,9 +291,10 @@
 char *
 unparse_number(NVAL num)
 {
-  static char str[100];         /* Should be large enough for even the HUGE floats */
+  /* 100 is NOT large enough for even the huge floats */
+  static char str[1000];        /* Should be large enough for even the HUGE floats */
   char *p;
-  sprintf(str, "%.*f", FLOAT_PRECISION, num);
+  snprintf(str, 1000, "%.*f", FLOAT_PRECISION, num);
 
   if ((p = strchr(str, '.'))) {
     p += strlen(p);
Index: src/lmathtab.gperf
===================================================================
--- src/lmathtab.gperf	(.../183p10)	(revision 142)
+++ src/lmathtab.gperf	(.../183p11)	(revision 142)
@@ -38,6 +38,12 @@
 MATH_PROTO(math_stddev);
 MATH_PROTO(math_dist2d);
 MATH_PROTO(math_dist3d);
+MATH_PROTO(math_lt);
+MATH_PROTO(math_lte);
+MATH_PROTO(math_gt);
+MATH_PROTO(math_gte);
+MATH_PROTO(math_eq);
+MATH_PROTO(math_neq);
 
 /** A math function. */
 %}
@@ -71,6 +77,12 @@
 STDDEV, math_stddev
 DIST2D, math_dist2d
 DIST3D, math_dist3d
+LT, math_lt
+LTE, math_lte
+GT, math_gt
+GTE, math_gte
+EQ, math_eq
+NEQ, math_neq
 %%
 
 typedef struct math MATH;
Index: src/function.c
===================================================================
--- src/function.c	(.../183p10)	(revision 142)
+++ src/function.c	(.../183p11)	(revision 142)
@@ -361,7 +361,7 @@
   {"CSTATUS", fun_cstatus, 2, 2, FN_REG},
   {"CTITLE", fun_ctitle, 2, 2, FN_REG},
   {"CUSERS", fun_cinfo, 1, 1, FN_REG},
-  {"CWHO", fun_cwho, 1, 1, FN_REG},
+  {"CWHO", fun_cwho, 1, 2, FN_REG},
   {"CENTER", fun_center, 2, 4, FN_REG},
   {"CHILDREN", fun_lsearch, 1, 1, FN_REG},
   {"CHR", fun_chr, 1, 1, FN_REG},
@@ -406,7 +406,7 @@
   {"ENCRYPT", fun_encrypt, 2, 3, FN_REG},
   {"ENTRANCES", fun_entrances, 0, 4, FN_REG},
   {"ETIMEFMT", fun_etimefmt, 2, 2, FN_REG},
-  {"EQ", fun_eq, 2, 2, FN_REG},
+  {"EQ", fun_eq, 2, INT_MAX, FN_REG},
   {"EVAL", fun_eval, 2, 2, FN_REG},
   {"ESCAPE", fun_escape, 1, -1, FN_REG},
   {"EXIT", fun_exit, 1, 1, FN_REG},
@@ -436,8 +436,8 @@
   {"GRABALL", fun_graball, 2, 4, FN_REG},
   {"GREP", fun_grep, 3, 3, FN_REG},
   {"GREPI", fun_grep, 3, 3, FN_REG},
-  {"GT", fun_gt, 2, 2, FN_REG},
-  {"GTE", fun_gte, 2, 2, FN_REG},
+  {"GT", fun_gt, 2, INT_MAX, FN_REG},
+  {"GTE", fun_gte, 2, INT_MAX, FN_REG},
   {"HASATTR", fun_hasattr, 1, 2, FN_REG},
   {"HASATTRP", fun_hasattr, 1, 2, FN_REG},
   {"HASATTRPVAL", fun_hasattr, 1, 2, FN_REG},
@@ -489,7 +489,7 @@
   {"LLOCKFLAGS", fun_lockflags, 0, 1, FN_REG},
   {"LLOCKS", fun_locks, 1, 1, FN_REG},
   {"LMATH", fun_lmath, 2, 3, FN_REG},
-  {"LNUM", fun_lnum, 1, 3, FN_REG},
+  {"LNUM", fun_lnum, 1, 4, FN_REG},
   {"LOC", fun_loc, 1, 1, FN_REG},
   {"LOCALIZE", fun_localize, 1, 1, FN_NOPARSE},
   {"LOCATE", fun_locate, 3, 3, FN_REG},
@@ -500,20 +500,20 @@
   {"LPARENT", fun_lparent, 1, 1, FN_REG},
   {"LPIDS", fun_lpids, 0, 2, FN_REG},
   {"LPLAYERS", fun_dbwalker, 1, 1, FN_REG},
-  {"LPORTS", fun_lports, 0, 1, FN_REG},
+  {"LPORTS", fun_lports, 0, 2, FN_REG},
   {"LPOS", fun_lpos, 2, 2, FN_REG},
   {"LSEARCH", fun_lsearch, 1, INT_MAX, FN_REG},
   {"LSEARCHR", fun_lsearch, 1, INT_MAX, FN_REG},
   {"LSET", fun_lset, 2, 2, FN_REG},
   {"LSTATS", fun_lstats, 0, 1, FN_REG},
-  {"LT", fun_lt, 2, 2, FN_REG},
-  {"LTE", fun_lte, 2, 2, FN_REG},
+  {"LT", fun_lt, 2, INT_MAX, FN_REG},
+  {"LTE", fun_lte, 2, INT_MAX, FN_REG},
   {"LTHINGS", fun_dbwalker, 1, 1, FN_REG},
   {"LVCON", fun_dbwalker, 1, 1, FN_REG},
   {"LVEXITS", fun_dbwalker, 1, 1, FN_REG},
   {"LVPLAYERS", fun_dbwalker, 1, 1, FN_REG},
   {"LVTHINGS", fun_dbwalker, 1, 1, FN_REG},
-  {"LWHO", fun_lwho, 0, 1, FN_REG},
+  {"LWHO", fun_lwho, 0, 2, FN_REG},
   {"LWHOID", fun_lwho, 0, 1, FN_REG},
   {"MAIL", fun_mail, 0, 2, FN_REG},
   {"MAILFROM", fun_mailfrom, 1, 2, FN_REG},
@@ -548,7 +548,7 @@
   {"MWHO", fun_lwho, 0, 0, FN_REG},
   {"MWHOID", fun_lwho, 0, 0, FN_REG},
   {"NAME", fun_name, 0, 2, FN_REG},
-  {"NAMELIST", fun_namelist, 1, 1, FN_REG},
+  {"NAMELIST", fun_namelist, 1, 2, FN_REG},
   {"NAMEGRAB", fun_namegrab, 2, 3, FN_REG},
   {"NAMEGRABALL", fun_namegraball, 2, 3, FN_REG},
   {"NAND", fun_nand, 1, INT_MAX, FN_REG},
@@ -561,7 +561,7 @@
   {"NEXITS", fun_dbwalker, 1, 1, FN_REG},
   {"NPLAYERS", fun_dbwalker, 1, 1, FN_REG},
   {"NEARBY", fun_nearby, 2, 2, FN_REG},
-  {"NEQ", fun_neq, 2, 2, FN_REG},
+  {"NEQ", fun_neq, 2, INT_MAX, FN_REG},
   {"NEXT", fun_next, 1, 1, FN_REG},
   {"NEXTDBREF", fun_nextdbref, 0, 0, FN_REG},
   {"NLSEARCH", fun_lsearch, 1, INT_MAX, FN_REG},
@@ -699,6 +699,7 @@
   {"TABLE", fun_table, 1, 5, FN_REG},
   {"TEL", fun_tel, 2, 4, FN_REG},
   {"TERMINFO", fun_terminfo, 1, 1, FN_REG},
+  {"TESTLOCK", fun_testlock, 2, 2, FN_REG},
   {"TEXTENTRIES", fun_textentries, 2, 3, FN_REG},
   {"TEXTFILE", fun_textfile, 2, 2, FN_REG},
   {"TIME", fun_time, 0, 1, FN_REG},
@@ -711,11 +712,11 @@
   {"TRUNC", fun_trunc, 1, 1, FN_REG},
   {"TYPE", fun_type, 1, 1, FN_REG},
   {"UCSTR", fun_ucstr, 1, -1, FN_REG},
-  {"UDEFAULT", fun_uldefault, 2, 12, FN_NOPARSE},
+  {"UDEFAULT", fun_udefault, 2, 12, FN_NOPARSE},
   {"UFUN", fun_ufun, 1, 11, FN_REG},
-  {"ULAMBDA", fun_ulambda, 1, 11, FN_REG},
-  {"ULDEFAULT", fun_uldefault, 1, 12, FN_NOPARSE},
-  {"ULOCAL", fun_ulocal, 1, 11, FN_REG},
+  {"ULAMBDA", fun_ufun, 1, 11, FN_REG},
+  {"ULDEFAULT", fun_udefault, 1, 12, FN_NOPARSE | FN_LOCALIZE},
+  {"ULOCAL", fun_ufun, 1, 11, FN_REG | FN_LOCALIZE},
   {"UNIQUE", fun_unique, 1, 4, FN_REG},
   {"UTCTIME", fun_time, 0, 0, FN_REG},
   {"U", fun_ufun, 1, 11, FN_REG},
@@ -1052,7 +1053,7 @@
 }
 
 /*------------------------------------------------------------------------
- * User-defined global function handlers 
+ * User-defined global function handlers
  */
 
 static int
@@ -1296,7 +1297,7 @@
     }
     return;
   }
-  /* otherwise, we are adding a user function. 
+  /* otherwise, we are adding a user function.
    * Only those with the Global_Funcs power may add stuff.
    * If you add a function that is already a user-defined function,
    * the old function gets over-written.
@@ -1494,7 +1495,7 @@
 void
 do_function_delete(dbref player, char *name)
 {
-  /* Deletes a user-defined function. 
+  /* Deletes a user-defined function.
    * For security, you must control the object the function uses
    * to delete the function.
    */
@@ -1626,7 +1627,7 @@
     first = 0;
   }
 
-  if (fp->flags & FN_LOCALIZE) {
+  if (fp->flags & FN_USERFN) {
     if (first == 0)
       safe_strl(", ", 2, tbuf, &tp);
     safe_str("Userfn", tbuf, &tp);
Index: src/conf.c
===================================================================
--- src/conf.c	(.../183p10)	(revision 142)
+++ src/conf.c	(.../183p11)	(revision 142)
@@ -120,7 +120,7 @@
    "messages"}
   ,
   {"motd_html_file", cf_str, options.motd_file[1],
-   sizeof options.connect_file[1], 0,
+   sizeof options.motd_file[1], 0,
    "messages"}
   ,
   {"wizmotd_html_file", cf_str, options.wizmotd_file[1],
@@ -747,7 +747,7 @@
 }
 
 
-/** Parse an time configuration option with a default unit of seconds 
+/** Parse an time configuration option with a default unit of seconds
  * \param opt name of the configuration option.
  * \param val value of the option.
  * \param loc address to store the value.
@@ -1367,16 +1367,14 @@
     do_rawlog(LT_ERR, "Reading %s", conf);
   }
 
-  fgets(tbuf1, BUFFER_LEN, fp);
-  while (!feof(fp)) {
+  while ((p = fgets(tbuf1, BUFFER_LEN, fp)) != NULL) {
 
-    p = tbuf1;
+    while (*p && isspace((unsigned char) *p))
+      p++;
+
+    if (*p == '\0' || *p == '#')
+      continue;                 /* comment or blank line */
 
-    if (*p == '#') {
-      /* comment line */
-      fgets(tbuf1, BUFFER_LEN, fp);
-      continue;
-    }
     /* this is a real line. Strip the end-of-line and characters following it.
      * Split the line into command and argument portions. If it exists,
      * also strip off the trailing comment. We try to make this work
@@ -1423,7 +1421,6 @@
       } else
         config_set(p, q, 0, restrictions);
     }
-    fgets(tbuf1, BUFFER_LEN, fp);
   }
 
   /* Warn about any config options that aren't overridden by the
Index: src/cmds.c
===================================================================
--- src/cmds.c	(.../183p10)	(revision 142)
+++ src/cmds.c	(.../183p11)	(revision 142)
@@ -717,6 +717,8 @@
   if (!(SW_ISSET(sw, SWITCH_SPOOF) && (controls(player, cause)
                                        || Can_Nspemit(player)))) {
     cause = player;
+  } else {
+    orator = cause;
   }
 
   for (numargs = 1; args_right[numargs] && numargs < 13; numargs++) ;
@@ -818,7 +820,6 @@
 {
   int flags;
 
-  SPOOF(player, cause, sw);
   if (SW_ISSET(sw, SWITCH_SILENT))
     flags = PEMIT_SILENT;
   else if (SW_ISSET(sw, SWITCH_NOISY))
@@ -826,6 +827,13 @@
   else
     flags = SILENT_PEMIT ? PEMIT_SILENT : 0;
 
+  if (SW_ISSET(sw, SWITCH_PORT)) {
+    do_pemit_port(player, arg_left, arg_right, flags);
+    return;
+  }
+
+  SPOOF(player, cause, sw);
+
   if (!strcmp(cmd->name, "@NSPEMIT"))
     flags |= PEMIT_SPOOF;
   if (SW_ISSET(sw, SWITCH_LIST))
@@ -1300,7 +1308,8 @@
 COMMAND(cmd_page)
 {
   if (SW_ISSET(sw, SWITCH_PORT))
-    do_page_port(player, arg_left, arg_right);
+    do_page_port(player, cause, arg_left, arg_right,
+                 !SW_ISSET(sw, SWITCH_NOEVAL));
   else
     do_page(player, arg_left, arg_right, cause, SW_ISSET(sw, SWITCH_NOEVAL),
             !(SW_ISSET(sw, SWITCH_BLIND) ||
@@ -1333,11 +1342,6 @@
   do_kill(player, arg_left, 0, 1);
 }
 
-COMMAND(cmd_take)
-{
-  do_get(player, arg_left);
-}
-
 COMMAND(cmd_think)
 {
   do_think(player, arg_left);
@@ -1384,3 +1388,24 @@
                 unparse_dbref(player));
   return;
 }
+
+COMMAND(cmd_who_doing)
+{
+  do_who_mortal(player, arg_left);
+}
+
+COMMAND(cmd_session)
+{
+  if (Priv_Who(player))
+    do_who_session(player, arg_left);
+  else
+    do_who_mortal(player, arg_left);
+}
+
+COMMAND(cmd_who)
+{
+  if (Priv_Who(player))
+    do_who_admin(player, arg_left);
+  else
+    do_who_mortal(player, arg_left);
+}
Index: src/intmap.c
===================================================================
--- src/intmap.c	(.../183p10)	(revision 142)
+++ src/intmap.c	(.../183p11)	(revision 142)
@@ -120,7 +120,7 @@
 
 /** Deallocate an integer map. All data pointers that need to be freed
  *  qmust be deallocated seperately before this, or you'll get a memory
- *  leak. 
+ *  leak.
  *  \param im the map to delete.
  */
 void
@@ -389,7 +389,8 @@
 
   fprintf(fp,
           "node%u [label=\"{ <key> key = 0b%s (%u) | bit = %d | { <b0> 0 | <b1> 1 } }\", ",
-          node->key, tmpbuf, node->key, node->bit);
+          (unsigned int) node->key, tmpbuf, (unsigned int) node->key,
+          node->bit);
   if (node->links[0]->bit > node->bit && node->links[1]->bit > node->bit)
     fputs("fillcolor=1", fp);
   else if (node->links[0]->bit <= node->bit && node->links[1]->bit <= node->bit)
@@ -418,8 +419,8 @@
 
   for (i = 0; i < 2; i++) {
     if (node->links[i]) {
-      fprintf(fp, "node%u:b%d -> node%u:key [%s];\n", node->key, i,
-              node->links[i]->key,
+      fprintf(fp, "node%u:b%d -> node%u:key [%s];\n", (unsigned int) node->key,
+              i, (unsigned int) node->links[i]->key,
               edge_styles[node->links[i]->bit > node->bit]);
       if (node->links[i]->bit > node->bit)
         pat_list_links(node->links[i], fp);
Index: src/funmisc.c
===================================================================
--- src/funmisc.c	(.../183p10)	(revision 142)
+++ src/funmisc.c	(.../183p11)	(revision 142)
@@ -68,7 +68,7 @@
 FUNCTION(fun_pemit)
 {
   int ns = string_prefix(called_as, "NS");
-  int flags = PEMIT_LIST;
+  int flags = PEMIT_LIST | PEMIT_SILENT;
   dbref saved_orator = orator;
   if (!command_check_byname(executor, ns ? "@nspemit" : "@pemit") ||
       fun->flags & FN_NOSIDEFX) {
@@ -78,7 +78,10 @@
   orator = executor;
   if (ns)
     flags |= PEMIT_SPOOF;
-  do_pemit_list(executor, args[0], args[1], flags);
+  if (is_strict_integer(args[0]))
+    do_pemit_port(executor, args[0], args[1], flags);
+  else
+    do_pemit_list(executor, args[0], args[1], flags);
   orator = saved_orator;
 }
 
@@ -359,7 +362,7 @@
   if (nargs == 3)
     show_all = parse_boolean(args[2]);
 
-  if (n == 0 || n > 20) {
+  if (n == 0 || n > 700) {
     safe_str(T("#-1 NUMBER OUT OF RANGE"), buff, bp);
     return;
   }
@@ -433,7 +436,7 @@
                                executor, caller, enactor,
                                PE_DEFAULT, PT_DEFAULT, pe_info);
       if (!exact)
-        mush_free((Malloc_t) tbuf1, "replace_string.buff");
+        mush_free(tbuf1, "replace_string.buff");
       found = 1;
       if (per || first)
         return;
@@ -450,7 +453,7 @@
     process_expression(buff, bp, &sp, executor, caller, enactor,
                        PE_DEFAULT, PT_DEFAULT, pe_info);
     if (!exact)
-      mush_free((Malloc_t) tbuf1, "replace_string.buff");
+      mush_free(tbuf1, "replace_string.buff");
   }
 }
 
@@ -497,7 +500,7 @@
       per = process_expression(buff, bp, &sp,
                                executor, caller, enactor,
                                PE_DEFAULT, PT_DEFAULT, pe_info);
-      mush_free((Malloc_t) tbuf1, "replace_string.buff");
+      mush_free(tbuf1, "replace_string.buff");
       found = 1;
       if (per || first)
         return;
@@ -510,7 +513,7 @@
     sp = tbuf1;
     process_expression(buff, bp, &sp, executor, caller, enactor,
                        PE_DEFAULT, PT_DEFAULT, pe_info);
-    mush_free((Malloc_t) tbuf1, "replace_string.buff");
+    mush_free(tbuf1, "replace_string.buff");
   }
 }
 
Index: src/move.c
===================================================================
--- src/move.c	(.../183p10)	(revision 142)
+++ src/move.c	(.../183p11)	(revision 142)
@@ -11,6 +11,7 @@
 
 #include <ctype.h>
 #include <string.h>
+#include <stdlib.h>
 
 #include "conf.h"
 #include "externs.h"
@@ -323,7 +324,8 @@
    * a VARIABLE (ambiguous) link.
    */
 
-  char const *abuf, *ap;
+  char *abuf;
+  const char *ap;
   char buff[BUFFER_LEN], *bp;
   ATTR *a;
   dbref dest_room;
@@ -339,7 +341,7 @@
   if (!abuf)
     return NOTHING;
   if (!*abuf) {
-    free((Malloc_t) abuf);
+    free(abuf);
     return NOTHING;
   }
   ap = abuf;
@@ -348,7 +350,7 @@
                      PE_DEFAULT, PT_DEFAULT, NULL);
   *bp = '\0';
   dest_room = parse_objid(buff);
-  free((Malloc_t) abuf);
+  free(abuf);
   return (dest_room);
 }
 
Index: src/speech.c
===================================================================
--- src/speech.c	(.../183p10)	(revision 142)
+++ src/speech.c	(.../183p11)	(revision 142)
@@ -253,7 +253,7 @@
     }
   }
 
-  /* Sort the list of rooms to oemit to so we don't oemit to the same           
+  /* Sort the list of rooms to oemit to so we don't oemit to the same
    * room twice */
   qsort((void *) locs, pass[0], sizeof(locs[0]), dbref_comp);
 
@@ -542,6 +542,9 @@
   dbref who;
   int silent, nospoof;
 
+  if (!arg2 || !*arg2)
+    return;
+
   silent = (flags & PEMIT_SILENT) ? 1 : 0;
   nospoof = (flags & PEMIT_SPOOF) ? 0 : 1;
 
@@ -768,8 +771,8 @@
   dbref good[100];
   int gcount = 0;
   char *msgbuf, *mb;
-  const char *head;
-  const char *hp = NULL;
+  char *head;
+  char *hp = NULL;
   const char **start;
   char *current;
   int i;
@@ -803,14 +806,14 @@
     a = atr_get_noparent(player, "LASTPAGED");
     if (!a || !*((hp = head = safe_atr_value(a)))) {
       notify(player, T("You haven't paged anyone since connecting."));
-      mush_free((Malloc_t) tbuf2, "page_buff");
+      mush_free(tbuf2, "page_buff");
       return;
     }
     if (!message || !*message) {
       notify_format(player, T("You last paged %s."), head);
-      mush_free((Malloc_t) tbuf2, "page_buff");
+      mush_free(tbuf2, "page_buff");
       if (hp)
-        free((Malloc_t) hp);
+        free(hp);
       return;
     }
   }
@@ -824,7 +827,7 @@
     override = 0;
   }
 
-  start = &head;
+  start = (const char **) &head;
   while (head && *head && (gcount < 99)) {
     current = next_in_list(start);
     target = lookup_player(current);
@@ -884,10 +887,10 @@
    * anyone, this looks like a spam attack. */
   if (gcount == 99) {
     notify(player, T("You're trying to page too many people at once."));
-    mush_free((Malloc_t) tbuf, "page_buff");
-    mush_free((Malloc_t) tbuf2, "page_buff");
+    mush_free(tbuf, "page_buff");
+    mush_free(tbuf2, "page_buff");
     if (hp)
-      free((Malloc_t) hp);
+      free(hp);
     return;
   }
 
@@ -901,20 +904,20 @@
 
   if (!gcount) {
     /* Well, that was a total waste of time. */
-    mush_free((Malloc_t) tbuf, "page_buff");
-    mush_free((Malloc_t) tbuf2, "page_buff");
+    mush_free(tbuf, "page_buff");
+    mush_free(tbuf2, "page_buff");
     if (hp)
-      free((Malloc_t) hp);
+      free(hp);
     return;
   }
 
   /* Can the player afford to pay for this thing? */
   if (!payfor(player, PAGE_COST * gcount)) {
     notify_format(player, T("You don't have enough %s."), MONIES);
-    mush_free((Malloc_t) tbuf, "page_buff");
-    mush_free((Malloc_t) tbuf2, "page_buff");
+    mush_free(tbuf, "page_buff");
+    mush_free(tbuf2, "page_buff");
     if (hp)
-      free((Malloc_t) hp);
+      free(hp);
     return;
   }
 
@@ -1049,12 +1052,12 @@
     page_return(player, good[i], "Idle", "IDLE", NULL);
   }
 
-  mush_free((Malloc_t) tbuf, "page_buff");
-  mush_free((Malloc_t) tbuf2, "page_buff");
+  mush_free(tbuf, "page_buff");
+  mush_free(tbuf2, "page_buff");
   if (msgbuf)
-    mush_free((Malloc_t) msgbuf, "page_buff");
+    mush_free(msgbuf, "page_buff");
   if (hp)
-    free((Malloc_t) hp);
+    free(hp);
 }
 
 
@@ -1071,7 +1074,7 @@
   char *filter;
   ATTR *a;
   char *p, *bp;
-  char *temp;                   /* need this so we don't leak memory     
+  char *temp;                   /* need this so we don't leak memory
                                  * by failing to free the storage
                                  * allocated by safe_uncompress
                                  */
@@ -1104,7 +1107,7 @@
       matched = local_wild_match_case(p, msg, AF_Case(a));
   }
 
-  free((Malloc_t) temp);
+  free(temp);
   return matched;
 }
 
@@ -1141,7 +1144,7 @@
     ap = asave;
     process_expression(tbuf1, &bp, &ap, thing, orator, orator,
                        PE_DEFAULT, PT_DEFAULT, NULL);
-    free((Malloc_t) asave);
+    free(asave);
     restore_global_regs("prefix_save", preserve);
     for (j = 0; j < 10; j++)
       global_eval_context.wenv[j] = wsave[j];
@@ -1392,7 +1395,6 @@
 {
   /* give a message to the "absolute" location of an object */
   dbref room;
-  int rec = 0;
   int na_flags = NA_INTER_HEAR;
   int silent = (flags & PEMIT_SILENT) ? 1 : 0;
 
@@ -1400,18 +1402,8 @@
   if (!Mobile(player))
     return;
 
-  /* prevent infinite loop if player is inside himself */
-  if (((room = Location(player)) == player) || !GoodObject(room)) {
-    notify(player, T("Invalid container object."));
-    do_rawlog(LT_ERR, T("** BAD CONTAINER **  #%d is inside #%d."), player,
-              room);
-    return;
-  }
-  while (!IsRoom(room) && (rec < 15)) {
-    room = Location(room);
-    rec++;
-  }
-  if (rec > 15) {
+  room = absolute_room(player);
+  if (!GoodObject(room) || !IsRoom(room)) {
     notify(player, T("Too many containers."));
     return;
   } else if (!Loud(player) && !eval_lock(player, room, Speech_Lock)) {
Index: src/bsd.c
===================================================================
--- src/bsd.c	(.../183p10)	(revision 142)
+++ src/bsd.c	(.../183p11)	(revision 142)
@@ -88,6 +88,9 @@
 #ifdef HAVE_FAM_H
 #include <fam.h>
 #endif
+#ifdef HAVE_POLL_H
+#include <poll.h>
+#endif
 
 #include "conf.h"
 
@@ -183,12 +186,12 @@
  * option negotiation code for setting client-side line-editing mode
  * to it. If it gets a reply, a flag in the descriptor struct is
  * turned on indicated telnet-awareness.
- * 
+ *
  * If the reply indicates that the client supports linemode, further
  * instructions as to what linemode options are to be used is sent.
  * Those options: Client-side line editing, and expanding literal
  * client-side-entered tabs into spaces.
- * 
+ *
  * Option negotation requests sent by the client are processed,
  * with the only one we confirm rather than refuse outright being
  * suppress-go-ahead, since a number of telnet clients try it.
@@ -224,6 +227,9 @@
         for(d = descriptor_list;(d);d=(d)->next) \
           if((d)->connected)
 
+#define DESC_ITER(d) \
+				for(d = descriptor_list;(d);d=(d)->next) \
+
 /** Is a descriptor hidden? */
 #define Hidden(d)        ((d->hide == 1) && Can_Hide(d->player))
 
@@ -317,6 +323,7 @@
 typedef struct fblock {
   unsigned char *buff;    /**< Pointer to the block as a string */
   size_t len;             /**< Length of buff */
+  dbref thing;               /**< If NOTHING, display buff as raw text. Otherwise, buff is an attrname on thing to eval and display */
 } FBLOCK;
 
 /** The complete collection of cached text files. */
@@ -334,6 +341,8 @@
 
 static struct fcache_entries fcache;
 static void fcache_dump(DESC *d, FBLOCK fp[2], const unsigned char *prefix);
+static int fcache_dump_attr(DESC *d, dbref thing, const char *attr, int html,
+                            const unsigned char *prefix);
 static int fcache_read(FBLOCK *cp, const char *filename);
 static void logout_sock(DESC *d);
 static void shutdownsock(DESC *d);
@@ -376,7 +385,7 @@
 #endif
 #endif
 extern pid_t forked_dump_pid;   /**< Process id of forking dump process */
-static void dump_users(DESC *call_by, char *match, int doing);
+static void dump_users(DESC *call_by, char *match);
 static const char *time_format_1(time_t dt);
 static const char *time_format_2(time_t dt);
 static void announce_connect(dbref player, int isnew, int num);
@@ -429,7 +438,7 @@
   if (geteuid() == 0) {
     fprintf(stderr, "The  %s binary is set suid and owned by root.\n", argv[0]);
 #ifdef HAVE_SETEUID
-    fprintf(stderr, "Changing effective user to %d.\n", getuid());
+    fprintf(stderr, "Changing effective user to %d.\n", (int) getuid());
     seteuid(getuid());
     in_suid_root_mode = 1;
 #endif
@@ -703,7 +712,7 @@
   install_sig_handler(SIGTERM, bailout);
   install_sig_handler(SIGCHLD, reaper);
 #else
-  /* Win32 stuff: 
+  /* Win32 stuff:
    *   No support for SIGUSR2 or SIGINT.
    *   SIGTERM is never generated on NT-based Windows (according to MSDN)
    *   MSVC++ will let you get away with installing a handler anyway,
@@ -1192,15 +1201,73 @@
 clearstrings(DESC *d)
 {
   if (d->output_prefix) {
-    mush_free((Malloc_t) d->output_prefix, "userstring");
+    mush_free(d->output_prefix, "userstring");
     d->output_prefix = 0;
   }
   if (d->output_suffix) {
-    mush_free((Malloc_t) d->output_suffix, "userstring");
+    mush_free(d->output_suffix, "userstring");
     d->output_suffix = 0;
   }
 }
 
+static int
+fcache_dump_attr(DESC *d, dbref thing, const char *attr, int html,
+                 const unsigned char *prefix)
+{
+  ATTR *a;
+  char *wsave[10], *rsave[NUMQ];
+  char arg[BUFFER_LEN], *save, *buff, *bp;
+  char const *sp;
+  int j;
+
+  if (!GoodObject(thing) || IsGarbage(thing))
+    return 0;
+
+  a = atr_get(thing, attr);
+  if (!a)
+    return -1;
+
+  bp = arg;
+  safe_integer(d->descriptor, arg, &bp);
+  *bp = '\0';
+  buff = (char *) mush_malloc(BUFFER_LEN, "string");
+  if (!buff) {
+    mush_panic("Unable to allocate memory in fcache_dump_attr");
+    return -2;
+  }
+  save_global_regs("send_txt", rsave);
+  for (j = 0; j < 10; j++) {
+    wsave[j] = global_eval_context.wenv[j];
+    global_eval_context.wenv[j] = NULL;
+  }
+  for (j = 0; j < NUMQ; j++)
+    global_eval_context.renv[j][0] = '\0';
+  global_eval_context.wenv[0] = arg;
+  sp = save = safe_atr_value(a);
+  bp = buff;
+  process_expression(buff, &bp, &sp, thing, NOTHING, NOTHING,
+                     PE_DEFAULT, PT_DEFAULT, NULL);
+  safe_chr('\n', buff, &bp);
+  *bp = '\0';
+  free((void *) save);
+  if (prefix) {
+    queue_newwrite(d, prefix, u_strlen(prefix));
+    queue_eol(d);
+  }
+  if (html)
+    queue_newwrite(d, (unsigned char *) buff, strlen(buff));
+  else
+    queue_write(d, (unsigned char *) buff, strlen(buff));
+  for (j = 0; j < 10; j++) {
+    global_eval_context.wenv[j] = wsave[j];
+  }
+  restore_global_regs("send_txt", rsave);
+  mush_free((void *) buff, "string");
+
+  return 1;
+}
+
+
 /* Display a cached text file. If a prefix line was given,
  * display that line before the text file, but only if we've
  * got a text file to display
@@ -1208,27 +1275,42 @@
 static void
 fcache_dump(DESC *d, FBLOCK fb[2], const unsigned char *prefix)
 {
+  int i;
+
   /* If we've got nothing nice to say, don't say anything */
   if (!fb[0].buff && !((d->conn_flags & CONN_HTML) && fb[1].buff))
     return;
-  /* We've got something to say */
-  if (prefix) {
-    queue_newwrite(d, prefix, u_strlen(prefix));
-    queue_eol(d);
+
+  for (i = ((d->conn_flags & CONN_HTML) && fb[1].buff); i >= 0; i--) {
+    if (fb[i].thing != NOTHING) {
+      if (fcache_dump_attr(d, fb[i].thing, (char *) fb[i].buff, i, prefix) == 1) {
+        /* Attr successfully evaluated and displayed */
+        return;
+      }
+    } else {
+      /* Output static text from the cached file */
+      if (prefix) {
+        queue_newwrite(d, prefix, u_strlen(prefix));
+        queue_eol(d);
+      }
+      if (i)
+        queue_newwrite(d, fb[1].buff, fb[1].len);
+      else
+        queue_write(d, fb[0].buff, fb[0].len);
+      return;
+    }
   }
-  if (d->conn_flags & CONN_HTML) {
-    if (fb[1].buff)
-      queue_newwrite(d, fb[1].buff, fb[1].len);
-    else
-      queue_write(d, fb[0].buff, fb[0].len);
-  } else
-    queue_write(d, fb[0].buff, fb[0].len);
 }
 
 
 static int
 fcache_read(FBLOCK *fb, const char *filename)
 {
+  char objname[BUFFER_LEN];
+  char *attr;
+  dbref thing;
+  size_t len;
+
   if (!fb || !filename)
     return -1;
 
@@ -1239,6 +1321,26 @@
 
   fb->buff = NULL;
   fb->len = 0;
+  fb->thing = NOTHING;
+  /* Check for #dbref/attr */
+  if (*filename == NUMBER_TOKEN) {
+    strcpy(objname, filename);
+    if ((attr = strchr(objname, '/')) != NULL) {
+      *attr++ = '\0';
+      if ((thing = qparse_dbref(objname)) != NOTHING) {
+        /* we have #dbref/attr */
+        if (!(fb->buff = mush_malloc(BUFFER_LEN, "fcache_data"))) {
+          return -1;
+        }
+        len = strlen(attr);
+        fb->thing = thing;
+        fb->len = len;
+        memcpy(fb->buff, (unsigned char *) upcasestr(attr), len);
+        *((char *) fb->buff + len) = '\0';
+        return fb->len;
+      }
+    }
+  }
 
 #ifdef WIN32
   /* Win32 read code here */
@@ -1584,6 +1686,15 @@
      * We need to know if the descriptor is waiting on input, though.
      * So let's find out
      */
+
+#ifdef HAVE_POLL
+    struct pollfd p;
+
+    p.fd = d->descriptor;
+    p.events = POLLIN;
+    p.revents = 0;
+    input_ready = poll(&p, 1, 0);
+#else
     struct timeval pad;
     fd_set input_set;
 
@@ -1592,6 +1703,7 @@
     FD_ZERO(&input_set);
     FD_SET(d->descriptor, &input_set);
     input_ready = select(d->descriptor + 1, &input_set, NULL, NULL, &pad);
+#endif
     if (input_ready < 0) {
       /* Well, shoot, we have no idea. Guess and proceed. */
       penn_perror("select in process_output");
@@ -2021,7 +2133,7 @@
   if (p > d->raw_input) {
     d->raw_input_at = p;
   } else {
-    mush_free((Malloc_t) d->raw_input, "descriptor_raw_input");
+    mush_free(d->raw_input, "descriptor_raw_input");
     d->raw_input = 0;
     d->raw_input_at = 0;
   }
@@ -2107,7 +2219,7 @@
 set_userstring(unsigned char **userstring, const char *command)
 {
   if (*userstring) {
-    mush_free((Malloc_t) * userstring, "userstring");
+    mush_free(*userstring, "userstring");
     *userstring = NULL;
   }
   while (*command && isspace((unsigned char) *command))
@@ -2174,11 +2286,18 @@
 {
   int j;
 
-  (d->cmds)++;
-
-  if (!strcmp(command, IDLE_COMMAND))
+  if (!strncmp(command, IDLE_COMMAND, strlen(IDLE_COMMAND))) {
+    j = strlen(IDLE_COMMAND);
+    if ((int) strlen(command) > j) {
+      if (*(command + j) == ' ')
+        j++;
+      queue_write(d, (unsigned char *) command + j, strlen(command) - j);
+      queue_eol(d);
+    }
     return 1;
+  }
   d->last_time = mudtime;
+  (d->cmds)++;
   if (!strcmp(command, QUIT_COMMAND)) {
     return 0;
   } else if (!strcmp(command, LOGOUT_COMMAND)) {
@@ -2187,18 +2306,6 @@
     send_prefix(d);
     dump_info(d);
     send_suffix(d);
-  } else if (!strncmp(command, WHO_COMMAND, strlen(WHO_COMMAND))) {
-    send_prefix(d);
-    dump_users(d, command + strlen(WHO_COMMAND), 0);
-    send_suffix(d);
-  } else if (!strncmp(command, DOING_COMMAND, strlen(DOING_COMMAND))) {
-    send_prefix(d);
-    dump_users(d, command + strlen(DOING_COMMAND), 1);
-    send_suffix(d);
-  } else if (!strncmp(command, SESSION_COMMAND, strlen(SESSION_COMMAND))) {
-    send_prefix(d);
-    dump_users(d, command + strlen(SESSION_COMMAND), 2);
-    send_suffix(d);
   } else if (!strncmp(command, PREFIX_COMMAND, strlen(PREFIX_COMMAND))) {
     set_userstring(&d->output_prefix, command + strlen(PREFIX_COMMAND));
   } else if (!strncmp(command, SUFFIX_COMMAND, strlen(SUFFIX_COMMAND))) {
@@ -2245,7 +2352,18 @@
       strcpy(global_eval_context.ucom, "");
       global_eval_context.cplr = NOTHING;
     } else {
-      if (!check_connect(d, command))
+      j = 0;
+      if (!strncmp(command, WHO_COMMAND, strlen(WHO_COMMAND)))
+        j = strlen(WHO_COMMAND);
+      else if (!strncmp(command, DOING_COMMAND, strlen(DOING_COMMAND)))
+        j = strlen(DOING_COMMAND);
+      else if (!strncmp(command, SESSION_COMMAND, strlen(SESSION_COMMAND)))
+        j = strlen(SESSION_COMMAND);
+      if (j) {
+        send_prefix(d);
+        dump_users(d, command + j);
+        send_suffix(d);
+      } else if (!check_connect(d, command))
         return 0;
     }
   }
@@ -2653,31 +2771,93 @@
   return (DESC *) NULL;
 }
 
+/** Pemit to a specified socket.
+ * \param player the enactor.
+ * \param pc string containing port number to send message to.
+ * \param message message to send.
+ * \param flags PEMIT_* flags
+ */
+void
+do_pemit_port(dbref player, const char *pc, const char *message, int flags)
+{
+  DESC *d;
+  int port;
+
+  if (!Hasprivs(player)) {
+    notify(player, T("Permission denied."));
+    return;
+  }
+
+  port = atoi(pc);
+  if (port <= 0) {
+    notify(player, T("That's not a port number."));
+    return;
+  }
+
+  if (!*message) {
+    return;
+  }
+
+  d = port_desc(port);
+  if (!d) {
+    notify(player, T("That port is not active."));
+    return;
+  }
+
+  if (!(flags & PEMIT_SILENT))
+    notify_format(player, T("You pemit \"%s\" to %s."), message,
+                  (d->connected ? Name(d->player) : T("a connecting player")));
+  queue_string_eol(d, message);
+
+}
+
 /** Page a specified socket.
  * \param player the enactor.
+ * \param cause the cause.
  * \param pc string containing port number to send message to.
  * \param message message to send.
+ * \param eval_msg Should the message be evaluated?
  */
 void
-do_page_port(dbref player, const char *pc, const char *message)
+do_page_port(dbref player, dbref cause, const char *pc, const char *message,
+             bool eval_msg)
 {
   int p, key;
   DESC *d;
   const char *gap;
   char tbuf[BUFFER_LEN], *tbp = tbuf;
+  char mbuf[BUFFER_LEN], *mbp = mbuf;
   dbref target = NOTHING;
 
   if (!Hasprivs(player)) {
     notify(player, T("Permission denied."));
     return;
   }
-  p = atoi(pc);
+
+  process_expression(tbuf, &tbp, &pc, player, cause, cause, PE_DEFAULT,
+                     PT_DEFAULT, NULL);
+  *tbp = '\0';
+  p = atoi(tbuf);
+  tbp = tbuf;
+
   if (p <= 0) {
     notify(player, T("That's not a port number."));
     return;
   }
 
-  if (!message || !*message) {
+  if (!message) {
+    notify(player, T("What do you want to page with?"));
+    return;
+  }
+
+  if (eval_msg) {
+    process_expression(mbuf, &mbp, &message, player, cause, cause, PE_DEFAULT,
+                       PT_DEFAULT, NULL);
+    *mbp = '\0';
+    message = mbuf;
+  }
+
+  if (!*message) {
     notify(player, T("What do you want to page with?"));
     return;
   }
@@ -2929,8 +3109,7 @@
 
 
 static void
-dump_users(DESC *call_by, char *match, int doing)
-    /* doing: 0 if normal WHO, 1 if DOING, 2 if SESSION */
+dump_users(DESC *call_by, char *match)
 {
   DESC *d;
   int count = 0;
@@ -2946,143 +3125,266 @@
     match++;
   now = mudtime;
 
-  /* If a wizard/royal types "DOING" it gives him the normal player WHO,
-   * BUT flags are not shown. Wizard/royal WHO does not show @doings.
-   */
-
   if (SUPPORT_PUEBLO && (call_by->conn_flags & CONN_HTML)) {
     queue_newwrite(call_by, (const unsigned char *) "<img xch_mode=html>", 19);
     queue_newwrite(call_by, (const unsigned char *) "<PRE>", 5);
   }
 
-  if ((doing == 1) || !call_by->player || !Priv_Who(call_by->player)) {
-    if (poll_msg[0] == '\0')
-      strcpy(poll_msg, "Doing");
-    if (ShowAnsi(call_by->player))
-      snprintf(tbuf2, BUFFER_LEN, "%-16s %10s %6s  %s%s\n",
-               T("Player Name"), T("On For"), T("Idle"), poll_msg, ANSI_END);
-    else
-      snprintf(tbuf2, BUFFER_LEN, "%-16s %10s %6s  %s\n",
-               T("Player Name"), T("On For"), T("Idle"), poll_msg);
-    queue_string(call_by, tbuf2);
-  } else if (doing == 2) {
-    snprintf(tbuf2, BUFFER_LEN,
-             "%-16s %6s %9s %5s %5s Des  Sent    Recv  Pend\n",
-             T("Player Name"), T("Loc #"), T("On For"), T("Idle"), T("Cmds"));
-    queue_string(call_by, tbuf2);
-  } else {
-    snprintf(tbuf2, BUFFER_LEN, "%-16s %6s %9s %5s %5s Des  Host\n",
-             T("Player Name"), T("Loc #"), T("On For"), T("Idle"), T("Cmds"));
-    queue_string(call_by, tbuf2);
+  if (poll_msg[0] == '\0')
+    strcpy(poll_msg, "Doing");
+  snprintf(tbuf2, BUFFER_LEN, "%-16s %10s %6s  %s\n",
+           T("Player Name"), T("On For"), T("Idle"), poll_msg);
+  queue_string(call_by, tbuf2);
+
+  for (d = descriptor_list; d; d = d->next) {
+    if (!d->connected || !GoodObject(d->player))
+      continue;
+    if (COUNT_ALL || !Hidden(d))
+      count++;
+    if (Hidden(d) || (match && !(string_prefix(Name(d->player), match))))
+      continue;
+
+    sprintf(tbuf1, "%-16s %10s   %4s%c %s", Name(d->player),
+            time_format_1(now - d->connected_at),
+            time_format_2(now - d->last_time),
+            (Dark(d->player) ? 'D' : (Hidden(d) ? 'H' : ' '))
+            , d->doing);
+    queue_string(call_by, tbuf1);
+    queue_newwrite(call_by, (const unsigned char *) "\r\n", 2);
   }
+  switch (count) {
+  case 0:
+    mush_strncpy(tbuf1, T("There are no players connected."), BUFFER_LEN);
+    break;
+  case 1:
+    mush_strncpy(tbuf1, T("There is 1 player connected."), BUFFER_LEN);
+    break;
+  default:
+    snprintf(tbuf1, BUFFER_LEN, T("There are %d players connected."), count);
+    break;
+  }
+  queue_string(call_by, tbuf1);
+  if (SUPPORT_PUEBLO && (call_by->conn_flags & CONN_HTML)) {
+    queue_newwrite(call_by, (const unsigned char *) "\n</PRE>\n", 8);
+    queue_newwrite(call_by, (const unsigned char *) "<img xch_mode=purehtml>",
+                   23);
+  } else
+    queue_newwrite(call_by, (const unsigned char *) "\r\n", 2);
+}
 
+void
+do_who_mortal(dbref player, char *name)
+{
+  DESC *d;
+  int count = 0;
+  time_t now = mudtime;
+  int privs = Priv_Who(player);
+  PUEBLOBUFF;
+
+  if (poll_msg[0] == '\0')
+    strcpy(poll_msg, "Doing");
+
+  if (SUPPORT_PUEBLO) {
+    PUSE;
+    tag("img xch_mod=html");
+    notify_noenter(player, open_tag("PRE"));
+    PEND;
+    notify_noenter(player, pbuff);
+  }
+
+
+  notify_format(player, "%-16s %10s %6s  %s", T("Player Name"), T("On For"),
+                T("Idle"), poll_msg);
   for (d = descriptor_list; d; d = d->next) {
-    if (d->connected) {
-      if (!GoodObject(d->player))
-        continue;
-      if (COUNT_ALL || (!Hidden(d)
-                        || (call_by->player && Priv_Who(call_by->player))))
-        count++;
-      if (match && !(string_prefix(Name(d->player), match)))
-        continue;
+    if (!d->connected)
+      continue;
+    if (COUNT_ALL || (!Hidden(d) || privs))
+      count++;
+    if (name && !string_prefix(Name(d->player), name))
+      continue;
+    if (Hidden(d) && !privs)
+      continue;
+    notify_format(player, "%-16s %10s   %4s%c %s", Name(d->player),
+                  time_format_1(now - d->connected_at),
+                  time_format_2(now - d->last_time),
+                  (Dark(d->player) ? 'D' : (Hidden(d) ? 'H' : ' '))
+                  , d->doing);
+  }
+  switch (count) {
+  case 0:
+    notify(player, T("There are no players connected."));
+    break;
+  case 1:
+    notify(player, T("There is one player connected."));
+    break;
+  default:
+    notify_format(player, T("There are %d players connected."), count);
+    break;
+  }
 
-      if (call_by->connected && doing == 0 && call_by->player
-          && Priv_Who(call_by->player)) {
-        sprintf(tbuf1, "%-16s %6s %9s %5s  %4d %3d%c %s", Name(d->player),
-                unparse_dbref(Location(d->player)),
-                time_format_1(now - d->connected_at),
-                time_format_2(now - d->last_time), d->cmds, d->descriptor,
+  if (SUPPORT_PUEBLO) {
+    PUSE;
+    notify_noenter(player, close_tag("PRE"));
+    tag("img xch_mode=purehtml");
+    PEND;
+    notify_noenter(player, pbuff);
+  }
+
+}
+
+void
+do_who_admin(dbref player, char *name)
+{
+  DESC *d;
+  int count = 0;
+  time_t now = mudtime;
+  char tbuf[BUFFER_LEN];
+  PUEBLOBUFF;
+
+  if (SUPPORT_PUEBLO) {
+    PUSE;
+    tag("img xch_mod=html");
+    notify_noenter(player, open_tag("PRE"));
+    PEND;
+    notify_noenter(player, pbuff);
+  }
+
+  notify_format(player, "%-16s %6s %9s %5s %5s Des  Host", T("Player Name"),
+                T("Loc #"), T("On For"), T("Idle"), T("Cmds"));
+  for (d = descriptor_list; d; d = d->next) {
+    if (d->connected)
+      count++;
+    if ((name && *name)
+        && (!d->connected || !string_prefix(Name(d->player), name)))
+      continue;
+    if (d->connected) {
+      sprintf(tbuf, "%-16s %6s %9s %5s  %4d %3d%c %s", Name(d->player),
+              unparse_dbref(Location(d->player)),
+              time_format_1(now - d->connected_at),
+              time_format_2(now - d->last_time), d->cmds, d->descriptor,
 #ifdef HAS_OPENSSL
-                d->ssl ? 'S' : ' ',
+              d->ssl ? 'S' : ' ',
 #else
-                ' ',
+              ' ',
 #endif
-                d->addr);
-        tbuf1[78] = '\0';
-        if (Dark(d->player)) {
-          tbuf1[71] = '\0';
-          strcat(tbuf1, " (Dark)");
-        } else if (Hidden(d)) {
-          tbuf1[71] = '\0';
-          strcat(tbuf1, " (Hide)");
-        }
-      } else if (call_by->connected && doing == 2 && call_by->player
-                 && Priv_Who(call_by->player)) {
-        sprintf(tbuf1, "%-16s %6s %9s %5s %5d %3d%c %5lu %7lu %5d",
-                Name(d->player), unparse_dbref(Location(d->player)),
-                time_format_1(now - d->connected_at),
-                time_format_2(now - d->last_time), d->cmds, d->descriptor,
+              d->addr);
+      if (Dark(d->player)) {
+        tbuf[71] = '\0';
+        strcat(tbuf, " (Dark)");
+      } else if (Hidden(d)) {
+        tbuf[71] = '\0';
+        strcat(tbuf, " (Hide)");
+      } else {
+        tbuf[78] = '\0';
+      }
+    } else {
+      sprintf(tbuf, "%-16s %6s %9s %5s  %4d %3d%c %s", T("Connecting..."),
+              "#-1", time_format_1(now - d->connected_at),
+              time_format_2(now - d->last_time), d->cmds, d->descriptor,
 #ifdef HAS_OPENSSL
-                d->ssl ? 'S' : ' ',
+              d->ssl ? 'S' : ' ',
 #else
-                ' ',
+              ' ',
 #endif
-                d->input_chars, d->output_chars, d->output_size);
-      } else {
-        if (!Hidden(d)
-            || (call_by->player && Priv_Who(call_by->player) && (doing))) {
-          sprintf(tbuf1, "%-16s %10s   %4s%c %s", Name(d->player),
-                  time_format_1(now - d->connected_at),
-                  time_format_2(now - d->last_time),
-                  (Dark(d->player) ? 'D' : (Hidden(d) ? 'H' : ' '))
-                  , d->doing);
-        }
-      }
+              d->addr);
+      tbuf[78] = '\0';
+    }
+    notify(player, tbuf);
+  }
 
-      if (!Hidden(d) || (call_by->player && Priv_Who(call_by->player))) {
-        queue_string(call_by, tbuf1);
-        queue_newwrite(call_by, (const unsigned char *) "\r\n", 2);
-      }
-    } else if (call_by->player && Priv_Who(call_by->player) && doing != 1
-               && (!match || !*match)) {
-      if (doing == 0) {
-        /* Wizard WHO for non-logged in connections */
-        snprintf(tbuf1, BUFFER_LEN, "%-16s %6s %9s %5s  %4d %3d%c %s",
-                 T("Connecting..."), "#-1",
-                 time_format_1(now - d->connected_at),
-                 time_format_2(now - d->last_time), d->cmds, d->descriptor,
+  switch (count) {
+  case 0:
+    notify(player, T("There are no players connected."));
+    break;
+  case 1:
+    notify(player, T("There is one player connected."));
+    break;
+  default:
+    notify_format(player, T("There are %d players connected."), count);
+    break;
+  }
+
+  if (SUPPORT_PUEBLO) {
+    PUSE;
+    notify_noenter(player, close_tag("PRE"));
+    tag("img xch_mode=purehtml");
+    PEND;
+    notify_noenter(player, pbuff);
+  }
+
+}
+
+void
+do_who_session(dbref player, char *name)
+{
+  DESC *d;
+  int count = 0;
+  time_t now = mudtime;
+  PUEBLOBUFF;
+
+  if (SUPPORT_PUEBLO) {
+    PUSE;
+    tag("img xch_mod=html");
+    notify_noenter(player, open_tag("PRE"));
+    PEND;
+    notify_noenter(player, pbuff);
+  }
+
+  notify_format(player, "%-16s %6s %9s %5s %5s %4s %7s %7s %7s",
+                T("Player Name"), T("Loc #"), T("On For"), T("Idle"), T("Cmds"),
+                T("Des"), T("Sent"), T("Recv"), T("Pend"));
+
+  for (d = descriptor_list; d; d = d->next) {
+    if (d->connected)
+      count++;
+    if ((name && *name)
+        && (!d->connected || !string_prefix(Name(d->player), name)))
+      continue;
+    if (d->connected) {
+      notify_format(player, "%-16s %6s %9s %5s %5d %3d%c %7lu %7lu %7d",
+                    Name(d->player), unparse_dbref(Location(d->player)),
+                    time_format_1(now - d->connected_at),
+                    time_format_2(now - d->last_time), d->cmds, d->descriptor,
 #ifdef HAS_OPENSSL
-                 d->ssl ? 'S' : ' ',
+                    d->ssl ? 'S' : ' ',
 #else
-                 ' ',
+                    ' ',
 #endif
-                 d->addr);
-        tbuf1[78] = '\0';
-      } else {
-        /* SESSION for non-logged in connections */
-        snprintf(tbuf1, BUFFER_LEN, "%-16s %5s %9s %5s %5d %3d%c %5lu %7lu %5d",
-                 T("Connecting..."), "#-1",
-                 time_format_1(now - d->connected_at),
-                 time_format_2(now - d->last_time), d->cmds, d->descriptor,
+                    d->input_chars, d->output_chars, d->output_size);
+    } else {
+      notify_format(player, "%-16s %6s %9s %5s %5d %3d%c %7lu %7lu %7d",
+                    T("Connecting..."), "#-1",
+                    time_format_1(now - d->connected_at),
+                    time_format_2(now - d->last_time), d->cmds, d->descriptor,
 #ifdef HAS_OPENSSL
-                 d->ssl ? 'S' : ' ',
+                    d->ssl ? 'S' : ' ',
 #else
-                 ' ',
+                    ' ',
 #endif
-                 d->input_chars, d->output_chars, d->output_size);
-      }
-      queue_string(call_by, tbuf1);
-      queue_newwrite(call_by, (const unsigned char *) "\r\n", 2);
+                    d->input_chars, d->output_chars, d->output_size);
     }
   }
+
   switch (count) {
   case 0:
-    mush_strncpy(tbuf1, T("There are no players connected."), BUFFER_LEN);
+    notify(player, T("There are no players connected."));
     break;
   case 1:
-    mush_strncpy(tbuf1, T("There is 1 player connected."), BUFFER_LEN);
+    notify(player, T("There is one player connected."));
     break;
   default:
-    snprintf(tbuf1, BUFFER_LEN, T("There are %d players connected."), count);
+    notify_format(player, T("There are %d players connected."), count);
     break;
   }
-  queue_string(call_by, tbuf1);
-  if (SUPPORT_PUEBLO && (call_by->conn_flags & CONN_HTML)) {
-    queue_newwrite(call_by, (const unsigned char *) "\n</PRE>\n", 8);
-    queue_newwrite(call_by, (const unsigned char *) "<img xch_mode=purehtml>",
-                   23);
-  } else
-    queue_newwrite(call_by, (const unsigned char *) "\r\n", 2);
+
+  if (SUPPORT_PUEBLO) {
+    PUSE;
+    notify_noenter(player, close_tag("PRE"));
+    tag("img xch_mode=purehtml");
+    PEND;
+    notify_noenter(player, pbuff);
+  }
+
 }
 
 static const char *
@@ -3288,14 +3590,17 @@
    * %2 (bytes received)
    * %3 (bytes sent)
    * %4 (commands queued)
+   * %5 (hidden)
    */
   myenv[0] = NULL;
   myenv[1] = mush_strdup(unparse_integer(num - 1), "myenv");
   myenv[2] = mush_strdup(unparse_integer(saved->input_chars), "myenv");
   myenv[3] = mush_strdup(unparse_integer(saved->output_chars), "myenv");
   myenv[4] = mush_strdup(unparse_integer(saved->cmds), "myenv");
-  for (j = 0; j < 5; j++)
+  myenv[5] = mush_strdup(unparse_integer(Hidden(saved)), "myenv");
+  for (j = 0; j < 6; j++) {
     global_eval_context.wnxt[j] = myenv[j];
+  }
 
   (void) queue_attribute(player, "ADISCONNECT", player);
   if (ROOM_CONNECTS)
@@ -3349,7 +3654,7 @@
     }
   }
 
-  for (j = 0; j < 5; j++)
+  for (j = 0; j < 6; j++)
     if (myenv[j])
       mush_free(myenv[j], "myenv");
   for (j = 0; j < 10; j++)
@@ -3537,7 +3842,7 @@
 
 /** Match the partial name of a connected player.
  * \param match string to match.
- * \return dbref of a unique connected player whose name partial-matches, 
+ * \return dbref of a unique connected player whose name partial-matches,
  * AMBIGUOUS, or NOTHING.
  */
 dbref
@@ -3574,7 +3879,7 @@
 /** Match the partial name of a connected player the enactor can see.
  * \param player the enactor
  * \param match string to match.
- * \return dbref of a unique connected player whose name partial-matches, 
+ * \return dbref of a unique connected player whose name partial-matches,
  * AMBIGUOUS, or NOTHING.
  */
 dbref
@@ -3670,12 +3975,12 @@
 FUNCTION(fun_lwho)
 {
   DESC *d;
-  int first;
+  int first = 1;
   dbref victim;
   int powered = ((*called_as == 'L') && Priv_Who(executor));
   int objid = (strchr(called_as, 'D') != NULL);
-
-  first = 1;
+  int online = 1;
+  int offline = 0;
 
   if (nargs && args[0] && *args[0]) {
     /* An argument was given. Find the victim and choose the lowest
@@ -3693,18 +3998,45 @@
       powered = 0;
   }
 
-  DESC_ITER_CONN(d) {
-    if (!Hidden(d) || powered) {
-      if (first)
-        first = 0;
-      else
-        safe_chr(' ', buff, bp);
+  if (nargs > 1 && args[1] && *args[1]) {
+    if (string_prefix("all", args[1])) {
+      offline = online = 1;
+    } else if (strlen(args[1]) < 2) {
+      safe_str(T("#-1 INVALID SECOND ARGUMENT"), buff, bp);
+      return;
+    } else if (string_prefix("online", args[1])) {
+      online = 1;
+      offline = 0;
+    } else if (string_prefix("offline", args[1])) {
+      online = 0;
+      offline = 1;
+    } else {
+      safe_str(T("#-1 INVALID SECOND ARGUMENT"), buff, bp);
+      return;
+    }
+    if (offline && !powered) {
+      safe_str(T("#-1 PERMISSION DENIED"), buff, bp);
+      return;
+    }
+  }
+
+  DESC_ITER(d) {
+    if ((d->connected && !online) || (!d->connected && !offline))
+      continue;
+    if (!powered && (d->connected && Hidden(d)))
+      continue;
+    if (first)
+      first = 0;
+    else
+      safe_chr(' ', buff, bp);
+    if (d->connected) {
       safe_dbref(d->player, buff, bp);
       if (objid) {
         safe_chr(':', buff, bp);
         safe_integer(CreTime(d->player), buff, bp);
       }
-    }
+    } else
+      safe_dbref(-1, buff, bp);
   }
 }
 
@@ -4171,6 +4503,8 @@
   int first = 1;
   dbref victim;
   int powered = 1;
+  int online = 1;
+  int offline = 0;
 
   if (!Priv_Who(executor)) {
     safe_str(T(e_perm), buff, bp);
@@ -4188,22 +4522,46 @@
       powered = 0;
   }
 
-  DESC_ITER_CONN(d) {
-    if (powered || !Hidden(d)) {
-      if (first)
-        first = 0;
-      else
-        safe_chr(' ', buff, bp);
-      safe_integer(d->descriptor, buff, bp);
+  if (nargs > 1 && args[1] && *args[1]) {
+    if (string_prefix("all", args[1])) {
+      offline = online = 1;
+    } else if (strlen(args[1]) < 2) {
+      safe_str(T("#-1 INVALID SECOND ARGUMENT"), buff, bp);
+      return;
+    } else if (string_prefix("online", args[1])) {
+      online = 1;
+      offline = 0;
+    } else if (string_prefix("offline", args[1])) {
+      online = 0;
+      offline = 1;
+    } else {
+      safe_str(T("#-1 INVALID SECOND ARGUMENT"), buff, bp);
+      return;
+    }
+    if (offline && !powered) {
+      safe_str(T("#-1 PERMISSION DENIED"), buff, bp);
+      return;
     }
   }
+
+  DESC_ITER(d) {
+    if ((d->connected && !online) || (!d->connected && !offline))
+      continue;
+    if (!powered && (d->connected && Hidden(d)))
+      continue;
+    if (first)
+      first = 0;
+    else
+      safe_chr(' ', buff, bp);
+    safe_integer(d->descriptor, buff, bp);
+  }
 }
 
 /* ARGSUSED */
 FUNCTION(fun_ports)
 {
   /* returns a list of the network descriptors that a player is
-   * connected to 
+   * connected to
    */
 
   dbref target;
@@ -4266,7 +4624,7 @@
     notify(player, T("You now appear on the WHO list."));
 }
 
-/** Perform the periodic check of inactive descriptors, and 
+/** Perform the periodic check of inactive descriptors, and
  * disconnect them or autohide them as appropriate.
  */
 void
@@ -4753,7 +5111,7 @@
 }
 
 
-/* File modification watching code. Linux-specific for now. 
+/* File modification watching code. Linux-specific for now.
  * Future directions include: kqueue() for BSD, fam for linux, irix, others?
  *
  * The idea to watch help.txt and motd.txt and friends to avoid having
@@ -4927,7 +5285,7 @@
 
 #endif
 
-/** Start monitoring various useful files for changes. 
+/** Start monitoring various useful files for changes.
  * \return descriptor of the notification service, or -1 on error
  */
 int
@@ -4942,7 +5300,7 @@
 #endif
 }
 
-/** Test for modified files and re-read them if indicated. 
+/** Test for modified files and re-read them if indicated.
  * \param fd the notification monitorh descriptor
  */
 void
Index: src/boolexp.c
===================================================================
--- src/boolexp.c	(.../183p10)	(revision 142)
+++ src/boolexp.c	(.../183p11)	(revision 142)
@@ -610,7 +610,7 @@
               break;
             }
           }
-          free((Malloc_t) orig);
+          free(orig);
         }
         break;
       default:
@@ -897,7 +897,7 @@
       if (b->data.atr_lock) {
         if (b->data.atr_lock->name)
           st_delete(b->data.atr_lock->name, &atr_names);
-        mush_free((Malloc_t) b->data.atr_lock, "boolatr");
+        mush_free(b->data.atr_lock, "boolatr");
       }
       free_bool(b);
       break;
Index: src/chunk.c
===================================================================
--- src/chunk.c	(.../183p10)	(revision 142)
+++ src/chunk.c	(.../183p11)	(revision 142)
@@ -1793,12 +1793,12 @@
   STAT_OUT(tprintf("Storage:   %10d total (%2d%% saturation)",
                    overhead, used_bytes * 100 / overhead));
   STAT_OUT(tprintf("Regions:   %10d total, %8d cached",
-                   region_count, cached_region_count));
+                   (int) region_count, (int) cached_region_count));
   STAT_OUT(tprintf("Paging:    %10d out, %10d in",
                    stat_page_out, stat_page_in));
   STAT_OUT(" ");
   STAT_OUT(tprintf("Period:    %10d (%10d accesses so far, %10d chunks at max)",
-                   curr_period, stat_deref_count, stat_deref_maxxed));
+                   (int) curr_period, stat_deref_count, stat_deref_maxxed));
   STAT_OUT(tprintf("Activity:  %10d creates, %10d deletes this period",
                    stat_create, stat_delete));
   STAT_OUT(tprintf("Migration: %10d moves this period",
@@ -1839,7 +1839,7 @@
               "fbytes:%04x  largest:%04x  deref:%3d",
               rid, regions[rid].used_count, regions[rid].free_count,
               regions[rid].free_bytes, regions[rid].largest_free_chunk,
-              RegionDerefs(rid)));
+              (int) RegionDerefs(rid)));
   }
 }
 
Index: src/funstr.c
===================================================================
--- src/funstr.c	(.../183p10)	(revision 142)
+++ src/funstr.c	(.../183p11)	(revision 142)
@@ -693,6 +693,7 @@
       safe_chr(*(ptr++), buff, bp);
       break;
     case TAG_START:
+    case TAG_END:
       while (*ptr && *ptr != TAG_END) {
         safe_chr(*(ptr++), buff, bp);
       }
@@ -704,22 +705,6 @@
         while (*ptr && matched[(unsigned char) *ptr]) {
           ptr++;
           j++;
-          switch (*ptr) {
-          case ESC_CHAR:
-            safe_ansi_string(as, i, j, buff, bp);
-            i += j;
-            j = 0;
-            while (*ptr && *ptr != 'm')
-              safe_chr(*(ptr++), buff, bp);
-            break;
-          case TAG_START:
-            safe_ansi_string(as, i, j, buff, bp);
-            i += j;
-            j = 0;
-            while (*ptr && *ptr != TAG_END)
-              safe_chr(*(ptr++), buff, bp);
-            break;
-          }
         }
         if (j != 0) {
           safe_ansi_string(as, i, j, buff, bp);
@@ -1203,7 +1188,7 @@
 
     if (!tmp) {
       safe_str(lp, buff, bp);
-      free((Malloc_t) asave);
+      free(asave);
       free_anon_attrib(attrib);
       global_eval_context.wenv[1] = tptr[1];
       return;
@@ -1238,7 +1223,7 @@
   }
   if (*lp)
     safe_str(lp + 1, buff, bp);
-  free((Malloc_t) asave);
+  free(asave);
   free_anon_attrib(attrib);
   global_eval_context.wenv[0] = tptr[0];
   global_eval_context.wenv[1] = tptr[1];
@@ -1809,9 +1794,6 @@
       }
       ptrs[i] = ptr;
     } else if (*ptr == '\n') {
-      for (tptr = ptr;
-           *tptr && tptr >= ptrs[i] && isspace((unsigned char) *tptr); tptr--) ;
-      len = (tptr - ptrs[i]) + 1;
       if (len > 0) {
         safe_ansi_string(as[i], ptrs[i] - (as[i]->text), len, segment, &sp);
       }
Index: src/rob.c
===================================================================
--- src/rob.c	(.../183p10)	(revision 142)
+++ src/rob.c	(.../183p11)	(revision 142)
@@ -476,7 +476,7 @@
       process_expression(fbuff, &fbp, &ap, who, player, player,
                          PE_DEFAULT, PT_DEFAULT, NULL);
       *fbp = '\0';
-      free((Malloc_t) asave);
+      free(asave);
       restore_global_regs("give_save", preserveq);
       restore_global_env("give_save", preserves);
       if (amount < (cost = atoi(fbuff))) {
Index: src/funufun.c
===================================================================
--- src/funufun.c	(.../183p10)	(revision 142)
+++ src/funufun.c	(.../183p11)	(revision 142)
@@ -2,7 +2,7 @@
  * \file funufun.c
  *
  * \brief Evaluation and user-function functions for mushcode.
- * 
+ *
  *
  */
 
@@ -86,7 +86,7 @@
   char const *p;
   dbref obj;
 
-  /* First, we evaluate our first argument so people can use 
+  /* First, we evaluate our first argument so people can use
    * functions on it.
    */
   s = name;
@@ -179,25 +179,8 @@
   char rbuff[BUFFER_LEN];
   ufun_attrib ufun;
 
-  if (!fetch_ufun_attrib(args[0], executor, &ufun, 0)) {
-    safe_str(T(ufun.errmess), buff, bp);
-    return;
-  }
-
-  call_ufun(&ufun, args + 1, nargs - 1, rbuff, executor, enactor, pe_info);
-
-  safe_str(rbuff, buff, bp);
-
-  return;
-}
-
-/* ARGSUSED */
-FUNCTION(fun_ulambda)
-{
-  char rbuff[BUFFER_LEN];
-  ufun_attrib ufun;
-
-  if (!fetch_ufun_attrib(args[0], executor, &ufun, 1)) {
+  if (!fetch_ufun_attrib
+      (args[0], executor, &ufun, (!strcmp(called_as, "ULAMBDA")))) {
     safe_str(T(ufun.errmess), buff, bp);
     return;
   }
@@ -209,38 +192,11 @@
   return;
 }
 
-/* ARGSUSED */
-FUNCTION(fun_ulocal)
-{
-  /* Like fun_ufun, but saves the state of the q0-q9 registers
-   * when called
-   */
-  char *preserve[NUMQ];
-  char rbuff[BUFFER_LEN];
-  ufun_attrib ufun;
-
-  if (!fetch_ufun_attrib(args[0], executor, &ufun, 0)) {
-    safe_str(T(ufun.errmess), buff, bp);
-    return;
-  }
-
-  /* Save global regs */
-  save_global_regs("ulocal.save", preserve);
-
-  call_ufun(&ufun, args + 1, nargs - 1, rbuff, executor, enactor, pe_info);
-  safe_str(rbuff, buff, bp);
-
-  restore_global_regs("ulocal.save", preserve);
-
-  return;
-}
-
 /* Like fun_ufun, but takes as second argument a default message
- * to use if the attribute isn't there.  If called as uldefault,
- * then preserve registers, too.
+ * to use if the attribute isn't there.
  */
 /* ARGSUSED */
-FUNCTION(fun_uldefault)
+FUNCTION(fun_udefault)
 {
   dbref thing;
   ATTR *attrib;
@@ -249,7 +205,6 @@
   char mstr[BUFFER_LEN];
   char **xargs;
   int i;
-  char *preserve[NUMQ];
 
   /* find our object and attribute */
   dp = mstr;
@@ -275,12 +230,8 @@
         *dp = '\0';
       }
     }
-    if (called_as[1] == 'L')
-      save_global_regs("uldefault.save", preserve);
     do_userfn(buff, bp, thing, attrib, nargs - 2, xargs,
               executor, caller, enactor, pe_info, 0);
-    if (called_as[1] == 'L')
-      restore_global_regs("uldefault.save", preserve);
 
     /* Free the xargs */
     if (nargs > 2) {
@@ -293,12 +244,8 @@
   /* We couldn't get it. Evaluate args[1] and return it */
   sp = args[1];
 
-  if (called_as[1] == 'L')
-    save_global_regs("uldefault.save", preserve);
   process_expression(buff, bp, &sp, executor, caller, enactor,
                      PE_DEFAULT, PT_DEFAULT, pe_info);
-  if (called_as[1] == 'L')
-    restore_global_regs("uldefault.save", preserve);
   return;
 }
 
Index: src/flags.c
===================================================================
--- src/flags.c	(.../183p10)	(revision 142)
+++ src/flags.c	(.../183p11)	(revision 142)
@@ -1095,7 +1095,7 @@
 void
 destroy_flag_bitmask(object_flag_type bitmask)
 {
-  mush_free((Malloc_t) bitmask, "flag_bitmask");
+  mush_free(bitmask, "flag_bitmask");
 }
 
 /** Add a bit into a bitmask.
Index: src/funmath.c
===================================================================
--- src/funmath.c	(.../183p10)	(revision 142)
+++ src/funmath.c	(.../183p11)	(revision 142)
@@ -48,6 +48,8 @@
                    double error);
 
 int format_long(intmax_t n, char *buff, char **bp, int maxlen, int base);
+static void lmathcomp(char **ptr, int nptr, char *buff, char **bp,
+                      int eqokay, int isgt);
 
 /* Generated by gperf */
 #include "lmathtab.c"
@@ -202,61 +204,37 @@
 /* ARGSUSED */
 FUNCTION(fun_gt)
 {
-  if (!is_number(args[0]) || !is_number(args[1])) {
-    safe_str(T(e_nums), buff, bp);
-    return;
-  }
-  safe_boolean(parse_number(args[0]) > parse_number(args[1]), buff, bp);
+  math_gt(args, nargs, buff, bp);
 }
 
 /* ARGSUSED */
 FUNCTION(fun_gte)
 {
-  if (!is_number(args[0]) || !is_number(args[1])) {
-    safe_str(T(e_nums), buff, bp);
-    return;
-  }
-  safe_boolean(parse_number(args[0]) >= parse_number(args[1]), buff, bp);
+  math_gte(args, nargs, buff, bp);
 }
 
 /* ARGSUSED */
 FUNCTION(fun_lt)
 {
-  if (!is_number(args[0]) || !is_number(args[1])) {
-    safe_str(T(e_nums), buff, bp);
-    return;
-  }
-  safe_boolean(parse_number(args[0]) < parse_number(args[1]), buff, bp);
+  math_lt(args, nargs, buff, bp);
 }
 
 /* ARGSUSED */
 FUNCTION(fun_lte)
 {
-  if (!is_number(args[0]) || !is_number(args[1])) {
-    safe_str(T(e_nums), buff, bp);
-    return;
-  }
-  safe_boolean(parse_number(args[0]) <= parse_number(args[1]), buff, bp);
+  math_lte(args, nargs, buff, bp);
 }
 
 /* ARGSUSED */
 FUNCTION(fun_eq)
 {
-  if (!is_number(args[0]) || !is_number(args[1])) {
-    safe_str(T(e_nums), buff, bp);
-    return;
-  }
-  safe_boolean(EQ(parse_number(args[0]), parse_number(args[1])), buff, bp);
+  math_eq(args, nargs, buff, bp);
 }
 
 /* ARGSUSED */
 FUNCTION(fun_neq)
 {
-  if (!is_number(args[0]) || !is_number(args[1])) {
-    safe_str(T(e_nums), buff, bp);
-    return;
-  }
-  safe_boolean(!EQ(parse_number(args[0]), parse_number(args[1])), buff, bp);
+  math_neq(args, nargs, buff, bp);
 }
 
 /* ARGSUSED */
@@ -2479,7 +2457,102 @@
     safe_chr('0', buff, bp);
 }
 
+MATH_FUNC(math_lt)
+{
+  lmathcomp(ptr, nptr, buff, bp, 0, 0);
+}
 
+MATH_FUNC(math_gt)
+{
+  lmathcomp(ptr, nptr, buff, bp, 0, 1);
+}
+
+MATH_FUNC(math_lte)
+{
+  lmathcomp(ptr, nptr, buff, bp, 1, 0);
+}
+
+MATH_FUNC(math_gte)
+{
+  lmathcomp(ptr, nptr, buff, bp, 1, 1);
+}
+
+MATH_FUNC(math_eq)
+{
+  // Yes, I'm evil. :D
+  lmathcomp(ptr, nptr, buff, bp, 1, -1);
+}
+
+// This is used for lt, gt, lte, gte, eq
+static void
+lmathcomp(char **ptr, int nptr, char *buff, char **bp, int eqokay, int isgt)
+{
+  NVAL prev = 0;
+  NVAL next = 0;
+  int n;
+
+  if (nptr < 2) {
+    safe_str(T("#-1 COMPARISON REQUIRES 2 OR MORE NUMBERS"), buff, bp);
+    return;
+  }
+
+  if (!is_number(ptr[1])) {
+    safe_str(T(e_nums), buff, bp);
+    return;
+  }
+  prev = parse_number(ptr[0]);
+  for (n = 1; n < nptr; n++, prev = next) {
+    if (!is_number(ptr[n])) {
+      safe_str(T(e_nums), buff, bp);
+      return;
+    }
+    next = parse_number(ptr[n]);
+    // Is eqok?
+    if (EQ(next, prev)) {
+      if (eqokay)
+        continue;
+      safe_chr('0', buff, bp);
+      return;
+    }
+    if ((prev > next) != isgt) {
+      safe_chr('0', buff, bp);
+      return;
+    }
+  }
+
+  safe_chr('1', buff, bp);
+}
+
+MATH_FUNC(math_neq)
+{
+  NVAL prev = 0;
+  NVAL next = 0;
+  int n;
+
+  if (nptr < 2) {
+    safe_str(T("#-1 COMPARISON REQUIRES 2 OR MORE NUMBERS"), buff, bp);
+    return;
+  }
+
+  if (!is_number(ptr[1])) {
+    safe_str(T(e_nums), buff, bp);
+    return;
+  }
+  prev = parse_number(ptr[0]);
+  for (n = 1; n < nptr; n++, prev = next) {
+    if (!is_number(ptr[n])) {
+      safe_str(T(e_nums), buff, bp);
+      return;
+    }
+    next = parse_number(ptr[n]);
+    if (!EQ(next, prev)) {
+      safe_chr('1', buff, bp);
+      return;
+    }
+  }
+
+  safe_chr('0', buff, bp);
+}
 
 static NVAL
 find_median(NVAL *numbers, int nargs)
Index: src/extmail.c
===================================================================
--- src/extmail.c	(.../183p10)	(revision 142)
+++ src/extmail.c	(.../183p11)	(revision 142)
@@ -13,7 +13,7 @@
  * Sending:
  *   @mail[/sendswitch] player-list = message
  *     sendswitches: /silent, /urgent
- *     player-list is a space-separated list of players, aliases, or msg#'s 
+ *     player-list is a space-separated list of players, aliases, or msg#'s
  *     to reply to. Players can be names or dbrefs. Aliases start with *
  * Reading/Handling:
  *   @mail[/readswitch] [msg-list [= target]]
@@ -40,17 +40,17 @@
  *  As of pl11, extmail.c maintains mail as a sorted linked list, sorted
  * by recipient and order of receipt. This makes sending mail less
  * efficient (because you have to scan the list to figure out where to
- * insert), but reading/checking/deleting more efficient, 
+ * insert), but reading/checking/deleting more efficient,
  * because once you've found where the player's mail starts, you just
- * read from there. 
+ * read from there.
  *  That wouldn't be so exciting unless there was a fast way to find
  * where a player's mail chain started. Fortunately, there is. We
  * record that information for connected players when they connect,
  * on their descriptor. So, when connected players do reading/etc,
  * it's O(1). Sending to a connected player is O(1). Sending to an
- * unconnected player still requires scanning (O(n)), but you send once, 
+ * unconnected player still requires scanning (O(n)), but you send once,
  * and read/list/delete etc, multiple times.
- *  And just to make the sending to disconnected players faster, 
+ *  And just to make the sending to disconnected players faster,
  * instead of scanning the whole maildb to find the insertion point,
  * we start the scan from the chain of the connected player with the
  * closest db# to the target player. This scales up very well.
@@ -419,7 +419,7 @@
             }
           } else
             notify_format(player,
-                          "MAIL: Msg #%d:%d %s.", Folder(mp),
+                          "MAIL: Msg #%d:%d %s.", (int) Folder(mp),
                           i[Folder(mp)], negate ? "untagged" : "tagged");
           break;
         case M_CLEARED:
@@ -435,12 +435,12 @@
               notify_format(player,
                             T
                             ("MAIL: Unread Msg #%d:%d cleared! Use @mail/unclear %d:%d to recover."),
-                            Folder(mp), i[Folder(mp)], Folder(mp),
+                            (int) Folder(mp), i[Folder(mp)], (int) Folder(mp),
                             i[Folder(mp)]);
             } else {
               notify_format(player,
                             (negate ? T("MAIL: Msg #%d:%d uncleared.") :
-                             T("MAIL: Msg #%d:%d cleared.")), Folder(mp),
+                             T("MAIL: Msg #%d:%d cleared.")), (int) Folder(mp),
                             i[Folder(mp)]);
             }
           }
@@ -503,7 +503,7 @@
         } else
           notify_format(player,
                         T("MAIL: Msg %d:%d filed in folder %d [%s]"),
-                        origfold, i[origfold], foldernum,
+                        (int) origfold, i[origfold], foldernum,
                         get_folder_name(player, foldernum));
       }
     }
@@ -548,8 +548,8 @@
           notify_noenter(player, open_tag("SAMP"));
           snprintf(folderheader, BUFFER_LEN,
                    "%c%cA XCH_HINT=\"List messages in this folder\" XCH_CMD=\"@mail/list %d:1-\"%c%s%c%c/A%c",
-                   TAG_START, MARKUP_HTML, Folder(mp), TAG_END, T("Folder:"),
-                   TAG_START, MARKUP_HTML, TAG_END);
+                   TAG_START, MARKUP_HTML, (int) Folder(mp), TAG_END,
+                   T("Folder:"), TAG_START, MARKUP_HTML, TAG_END);
         } else
           mush_strncpy(folderheader, T("Folder:"), BUFFER_LEN);
         notify(player, DASH_LINE);
@@ -561,7 +561,7 @@
                               && Connected(mp->from)
                               && (!hidden(mp->from)
                                   || Priv_Who(player))) ? " (Conn)" : "      ",
-                      show_time(mp->time, 0), folderheader, Folder(mp),
+                      show_time(mp->time, 0), folderheader, (int) Folder(mp),
                       i[Folder(mp)], status_string(mp));
         notify_format(player, T("Subject: %s"), get_subject(mp));
         notify(player, DASH_LINE);
@@ -613,7 +613,7 @@
   notify_format(player,
                 T
                 ("---------------------------  MAIL (folder %2d)  ------------------------------"),
-                folder);
+                (int) folder);
   for (mp = find_exact_starting_point(player); mp && (mp->to == player);
        mp = mp->next) {
     if ((mp->to == player) && (All(ms) || Folder(mp) == folder)) {
@@ -624,12 +624,13 @@
           notify_noenter(player,
                          tprintf
                          ("%c%cA XCH_CMD=\"@mail/read %d:%d\" XCH_HINT=\"Read message %d in folder %d\"%c",
-                          TAG_START, MARKUP_HTML, Folder(mp), i[Folder(mp)],
-                          i[Folder(mp)], Folder(mp), TAG_END));
+                          TAG_START, MARKUP_HTML, (int) Folder(mp),
+                          i[Folder(mp)], i[Folder(mp)], (int) Folder(mp),
+                          TAG_END));
         strcpy(subj, chopstr(get_subject(mp), 28));
         strcpy(sender, chopstr(get_sender(mp, 0), 12));
         notify_format(player, "[%s] %2d:%-3d %c%-12s  %-*s %s",
-                      status_chars(mp), Folder(mp), i[Folder(mp)],
+                      status_chars(mp), (int) Folder(mp), i[Folder(mp)],
                       ((*sender != '!') && (Connected(mp->from) &&
                                             (!hidden(mp->from)
                                              || Priv_Who(player)))
@@ -757,7 +758,7 @@
   folder = AllInFolder(ms) ? player_folder(player) : MSFolder(ms);
   /* Mark the player's last message. This prevents a loop if
    * the forwarding command happens to forward a message back
-   * to the player itself 
+   * to the player itself
    */
   last = mp = find_exact_starting_point(player);
   if (!last) {
@@ -1015,7 +1016,7 @@
                         fwd);
       }
     }
-    free((Malloc_t) orig);
+    free(orig);
   }
   if (!silent) {
     if (good)
@@ -1071,7 +1072,7 @@
 
   /* Where do we insert it? After mp, wherever that is.
    * This can return NULL if there are no messages or
-   * if we insert at the head of the list 
+   * if we insert at the head of the list
    */
   mp = find_insertion_point(target);
 
@@ -1278,7 +1279,7 @@
         slab_free(mail_slab, mp);
       } else if (!GoodObject(mp->from)) {
         /* Oops, it's from a player whose dbref is out of range!
-         * We'll make it appear to be from #0 instead because there's 
+         * We'll make it appear to be from #0 instead because there's
          * no really good choice
          */
         mp->from = 0;
@@ -2297,11 +2298,11 @@
   /* put the attrib back */
   (void) atr_add(player, "MAILFOLDERS", res, GOD,
                  AF_WIZARD | AF_NOPROG | AF_LOCKED);
-  mush_free((Malloc_t) res, "replace_string.buff");
-  mush_free((Malloc_t) new, "string");
-  mush_free((Malloc_t) pat, "string");
-  mush_free((Malloc_t) str, "string");
-  mush_free((Malloc_t) tbuf, "string");
+  mush_free(res, "replace_string.buff");
+  mush_free(new, "string");
+  mush_free(pat, "string");
+  mush_free(str, "string");
+  mush_free(tbuf, "string");
 }
 
 static int
@@ -2651,7 +2652,7 @@
 /* See if we've been given something of the form [f:]m1[-m2]
  * If so, return 1 and set f and mlow and mhigh
  * If not, return 0
- * If msghigh is given as NULL, don't allow ranges 
+ * If msghigh is given as NULL, don't allow ranges
  * Used in parse_msglist, fun_mail and relatives.
  */
 static int
Index: src/create.c
===================================================================
--- src/create.c	(.../183p10)	(revision 142)
+++ src/create.c	(.../183p11)	(revision 142)
@@ -93,6 +93,9 @@
                                                              player :
                                                              Location(player)));
   dbref new_exit;
+  char *flaglist, *flagname;
+  char flagbuff[BUFFER_LEN];
+
   if (!command_check_byname(player, "@dig")) {
     notify(player, "Permission denied.");
     return NOTHING;
@@ -124,7 +127,16 @@
     Zone(new_exit) = Zone(player);
     Source(new_exit) = loc;
     Type(new_exit) = TYPE_EXIT;
-    Flags(new_exit) = string_to_bits("FLAG", options.exit_flags);
+    Flags(new_exit) = new_flag_bitmask("FLAG");
+    strcpy(flagbuff, options.exit_flags);
+    flaglist = trim_space_sep(flagbuff, ' ');
+    if (*flaglist != '\0') {
+      while (flaglist) {
+        flagname = split_token(&flaglist, ' ');
+        twiddle_flag_internal("FLAG", new_exit, flagname, 0);
+      }
+    }
+
 
     /* link it in */
     PUSH(new_exit, Exits(loc));
@@ -223,7 +235,7 @@
 /** Link an exit, room, player, or thing.
  * \verbatim
  * This is the top-level function for @link, which is used to link an
- * exit to a destination, set a player or thing's home, or set a 
+ * exit to a destination, set a player or thing's home, or set a
  * drop-to on a room.
  *
  * Linking an exit usually seizes ownership of the exit and costs 1 penny.
@@ -237,7 +249,7 @@
 void
 do_link(dbref player, const char *name, const char *room_name, int preserve)
 {
-  /* Use this to link to a room that you own. 
+  /* Use this to link to a room that you own.
    * It usually seizes ownership of the exit and costs 1 penny,
    * plus a penny transferred to the exit owner if they aren't you.
    * You must own the linked-to room AND specify it by room number.
@@ -380,6 +392,8 @@
 do_dig(dbref player, const char *name, char **argv, int tport)
 {
   dbref room;
+  char *flaglist, *flagname;
+  char flagbuff[BUFFER_LEN];
 
   /* we don't need to know player's location!  hooray! */
   if (*name == '\0') {
@@ -394,7 +408,15 @@
     Owner(room) = Owner(player);
     Zone(room) = Zone(player);
     Type(room) = TYPE_ROOM;
-    Flags(room) = string_to_bits("FLAG", options.room_flags);
+    Flags(room) = new_flag_bitmask("FLAG");
+    strcpy(flagbuff, options.room_flags);
+    flaglist = trim_space_sep(flagbuff, ' ');
+    if (*flaglist != '\0') {
+      while (flaglist) {
+        flagname = split_token(&flaglist, ' ');
+        twiddle_flag_internal("FLAG", room, flagname, 0);
+      }
+    }
 
     notify_format(player, T("%s created with room number %d."), name, room);
     if (argv[1] && *argv[1]) {
@@ -434,6 +456,8 @@
 {
   dbref loc;
   dbref thing;
+  char *flaglist, *flagname;
+  char flagbuff[BUFFER_LEN];
 
   if (*name == '\0') {
     notify(player, T("Create what?"));
@@ -477,7 +501,16 @@
     Zone(thing) = Zone(player);
     s_Pennies(thing, cost);
     Type(thing) = TYPE_THING;
-    Flags(thing) = string_to_bits("FLAG", options.thing_flags);
+    Flags(thing) = new_flag_bitmask("FLAG");
+    strcpy(flagbuff, options.thing_flags);
+    flaglist = trim_space_sep(flagbuff, ' ');
+    if (*flaglist != '\0') {
+      while (flaglist) {
+        flagname = split_token(&flaglist, ' ');
+        twiddle_flag_internal("FLAG", thing, flagname, 0);
+      }
+    }
+
 
     /* home is here (if we can link to it) or player's home */
     if ((loc = Location(player)) != NOTHING &&
@@ -624,7 +657,7 @@
     break;
   case TYPE_EXIT:
     /* For exits, we don't want people to be able to link it to
-       a location they can't with @open. So, all this stuff. 
+       a location they can't with @open. So, all this stuff.
      */
     switch (Location(thing)) {
     case NOTHING:
Index: src/funlist.c
===================================================================
--- src/funlist.c	(.../183p10)	(revision 142)
+++ src/funlist.c	(.../183p11)	(revision 142)
@@ -242,9 +242,9 @@
     safe_str(T("#-1 LISTS MUST BE OF EQUAL SIZE"), buff, bp);
     freearr(ptrs1, nptrs1);
     freearr(ptrs2, nptrs2);
-    mush_free((Malloc_t) ptrs1, "ptrarray");
-    mush_free((Malloc_t) ptrs2, "ptrarray");
-    mush_free((Malloc_t) ptrs3, "ptrarray");
+    mush_free(ptrs1, "ptrarray");
+    mush_free(ptrs2, "ptrarray");
+    mush_free(ptrs3, "ptrarray");
     free_anon_attrib(attrib);
     return;
   }
@@ -285,10 +285,10 @@
   freearr(ptrs1, nptrs1);
   freearr(ptrs2, nptrs2);
   freearr(results, nresults);
-  mush_free((Malloc_t) ptrs1, "ptrarray");
-  mush_free((Malloc_t) ptrs2, "ptrarray");
-  mush_free((Malloc_t) ptrs3, "ptrarray");
-  mush_free((Malloc_t) results, "ptrarray");
+  mush_free(ptrs1, "ptrarray");
+  mush_free(ptrs2, "ptrarray");
+  mush_free(ptrs3, "ptrarray");
+  mush_free(results, "ptrarray");
   free_anon_attrib(attrib);
 }
 
@@ -344,8 +344,8 @@
     }
   }
   freearr(ptrs, nwords);
-  mush_free((Malloc_t) ptrs, "ptrarray");
-  mush_free((Malloc_t) wordlist, "string");
+  mush_free(ptrs, "ptrarray");
+  mush_free(wordlist, "string");
 }
 
 /* ARGSUSED */
@@ -829,8 +829,8 @@
       if (x1 >= n1) {
         freearr(a1, n1);
         freearr(a2, n2);
-        mush_free((Malloc_t) a1, "ptrarray");
-        mush_free((Malloc_t) a2, "ptrarray");
+        mush_free(a1, "ptrarray");
+        mush_free(a2, "ptrarray");
         return;
       }
     } else {
@@ -838,8 +838,8 @@
       if (x2 >= n2) {
         freearr(a1, n1);
         freearr(a2, n2);
-        mush_free((Malloc_t) a1, "ptrarray");
-        mush_free((Malloc_t) a2, "ptrarray");
+        mush_free(a1, "ptrarray");
+        mush_free(a2, "ptrarray");
         return;
       }
     }
@@ -850,8 +850,8 @@
     if (x1 >= n1) {
       freearr(a1, n1);
       freearr(a2, n2);
-      mush_free((Malloc_t) a1, "ptrarray");
-      mush_free((Malloc_t) a2, "ptrarray");
+      mush_free(a1, "ptrarray");
+      mush_free(a2, "ptrarray");
       return;
     }
   }
@@ -864,8 +864,8 @@
         if (x1 >= n1) {
           freearr(a1, n1);
           freearr(a2, n2);
-          mush_free((Malloc_t) a1, "ptrarray");
-          mush_free((Malloc_t) a2, "ptrarray");
+          mush_free(a1, "ptrarray");
+          mush_free(a2, "ptrarray");
           return;
         }
       } else {
@@ -873,8 +873,8 @@
         if (x2 >= n2) {
           freearr(a1, n1);
           freearr(a2, n2);
-          mush_free((Malloc_t) a1, "ptrarray");
-          mush_free((Malloc_t) a2, "ptrarray");
+          mush_free(a1, "ptrarray");
+          mush_free(a2, "ptrarray");
           return;
         }
       }
@@ -886,16 +886,16 @@
       if (x1 >= n1) {
         freearr(a1, n1);
         freearr(a2, n2);
-        mush_free((Malloc_t) a1, "ptrarray");
-        mush_free((Malloc_t) a2, "ptrarray");
+        mush_free(a1, "ptrarray");
+        mush_free(a2, "ptrarray");
         return;
       }
     }
   }
   freearr(a1, n1);
   freearr(a2, n2);
-  mush_free((Malloc_t) a1, "ptrarray");
-  mush_free((Malloc_t) a2, "ptrarray");
+  mush_free(a1, "ptrarray");
+  mush_free(a2, "ptrarray");
 }
 
 /* ARGSUSED */
@@ -1033,8 +1033,8 @@
   }
   freearr(a1, orign1);
   freearr(a2, orign2);
-  mush_free((Malloc_t) a1, "ptrarray");
-  mush_free((Malloc_t) a2, "ptrarray");
+  mush_free(a1, "ptrarray");
+  mush_free(a2, "ptrarray");
 }
 
 /* ARGSUSED */
@@ -1103,8 +1103,8 @@
       if (x1 >= n1) {
         freearr(a1, n1);
         freearr(a2, n2);
-        mush_free((Malloc_t) a1, "ptrarray");
-        mush_free((Malloc_t) a2, "ptrarray");
+        mush_free(a1, "ptrarray");
+        mush_free(a2, "ptrarray");
         return;
       }
     }
@@ -1115,8 +1115,8 @@
     if (x1 >= n1) {
       freearr(a1, n1);
       freearr(a2, n2);
-      mush_free((Malloc_t) a1, "ptrarray");
-      mush_free((Malloc_t) a2, "ptrarray");
+      mush_free(a1, "ptrarray");
+      mush_free(a2, "ptrarray");
       return;
     }
   } while (!gencomp(executor, a1[x1], a1[x1 - 1], sort_type));
@@ -1133,8 +1133,8 @@
         if (x1 >= n1) {
           freearr(a1, n1);
           freearr(a2, n2);
-          mush_free((Malloc_t) a1, "ptrarray");
-          mush_free((Malloc_t) a2, "ptrarray");
+          mush_free(a1, "ptrarray");
+          mush_free(a2, "ptrarray");
           return;
         }
       } while (!gencomp(executor, a1[x1], a1[x1 - 1], sort_type));
@@ -1153,8 +1153,8 @@
   }
   freearr(a1, n1);
   freearr(a2, n2);
-  mush_free((Malloc_t) a1, "ptrarray");
-  mush_free((Malloc_t) a2, "ptrarray");
+  mush_free(a1, "ptrarray");
+  mush_free(a2, "ptrarray");
 }
 
 #define CACHE_SIZE 8  /**< Maximum size of the lnum cache */
@@ -1232,12 +1232,14 @@
   NVAL j;
   NVAL start;
   NVAL end;
-  int istart, iend, k;
+  NVAL step = 1.0;
+  int istart, iend, k, istep;
   char const *osep = " ";
   static NVAL cstart[CACHE_SIZE];
   static NVAL cend[CACHE_SIZE];
   static char csep[CACHE_SIZE][BUFFER_LEN];
   static char cresult[CACHE_SIZE][BUFFER_LEN];
+  static int cstep[CACHE_SIZE];
   static int cpos;
   char *cp;
 
@@ -1251,6 +1253,9 @@
       safe_str(T(e_num), buff, bp);
       return;
     }
+    if (nargs > 3 && is_number(args[3])) {
+      step = parse_number(args[3]);
+    }
     start = end;
     end = parse_number(args[1]);
     if ((start == 0) && (end == 0)) {
@@ -1275,7 +1280,8 @@
     osep = args[2];
   }
   for (k = 0; k < CACHE_SIZE; k++) {
-    if (cstart[k] == start && cend[k] == end && !strcmp(csep[k], osep)) {
+    if (cstart[k] == start && cend[k] == end && !strcmp(csep[k], osep) &&
+        cstep[k] == step) {
       safe_str(cresult[k], buff, bp);
       return;
     }
@@ -1288,16 +1294,17 @@
 
   istart = (int) start;
   iend = (int) end;
-  if (istart == start && iend == end) {
+  istep = (int) step;
+  if (istart == start && iend == end && istep == step) {
     safe_integer(istart, cresult[cpos], &cp);
     if (istart <= iend) {
-      for (k = istart + 1; k <= iend; k++) {
+      for (k = istart + istep; k <= iend; k += istep) {
         safe_str(osep, cresult[cpos], &cp);
         if (safe_integer(k, cresult[cpos], &cp))
           break;
       }
     } else {
-      for (k = istart - 1; k >= iend; k--) {
+      for (k = istart - istep; k >= iend; k -= istep) {
         safe_str(osep, cresult[cpos], &cp);
         if (safe_integer(k, cresult[cpos], &cp))
           break;
@@ -1306,13 +1313,13 @@
   } else {
     safe_number(start, cresult[cpos], &cp);
     if (start <= end) {
-      for (j = start + 1; j <= end; j++) {
+      for (j = start + step; j <= end; j += step) {
         safe_str(osep, cresult[cpos], &cp);
         if (safe_number(j, cresult[cpos], &cp))
           break;
       }
     } else {
-      for (j = start - 1; j >= end; j--) {
+      for (j = start - step; j >= end; j -= step) {
         safe_str(osep, cresult[cpos], &cp);
         if (safe_number(j, cresult[cpos], &cp))
           break;
@@ -1360,10 +1367,6 @@
 
   if (word_count == 0)
     return;
-  else if (word_count == 1) {
-    safe_strl(args[0], arglens[0], buff, bp);
-    return;
-  }
 
   word_index = get_random32(0, word_count - 1);
 
@@ -1685,16 +1688,22 @@
 FUNCTION(fun_remove)
 {
   char sep;
+  char lbuff[BUFFER_LEN];
+  char *r, *s;
 
   /* zap word from string */
 
   if (!delim_check(buff, bp, nargs, args, 3, &sep))
     return;
-  if (strchr(args[1], sep)) {
-    safe_str(T("#-1 CAN ONLY DELETE ONE ELEMENT"), buff, bp);
-    return;
+  r = lbuff;
+  safe_str(args[0], lbuff, &r);
+  *r = '\0';
+
+  s = args[1];
+  while ((r = split_token(&s, sep)) != NULL) {
+    memcpy(lbuff, remove_word(lbuff, r, sep), BUFFER_LEN);
   }
-  safe_str(remove_word(args[0], args[1], sep), buff, bp);
+  safe_str(lbuff, buff, bp);
 }
 
 /* ARGSUSED */
@@ -2012,8 +2021,8 @@
   }
 
   freearr(ptrs, nwords);
-  mush_free((Malloc_t) ptrs, "ptrarray");
-  mush_free((Malloc_t) wordlist, "string");
+  mush_free(ptrs, "ptrarray");
+  mush_free(wordlist, "string");
 }
 
 /* ARGSUSED */
@@ -2184,21 +2193,21 @@
   strncpy(haystack, remove_markup(args[2], NULL), BUFFER_LEN);
   if (!*haystack) {
     safe_str(T("#-1 NEED A WORD"), buff, bp);
-    mush_free((Malloc_t) orig, "ptrarray");
-    mush_free((Malloc_t) repl, "ptrarray");
+    mush_free(orig, "ptrarray");
+    mush_free(repl, "ptrarray");
     return;
   }
   if (do_wordcount(haystack, sep) != 1) {
     safe_str(T("#-1 TOO MANY WORDS"), buff, bp);
-    mush_free((Malloc_t) orig, "ptrarray");
-    mush_free((Malloc_t) repl, "ptrarray");
+    mush_free(orig, "ptrarray");
+    mush_free(repl, "ptrarray");
     return;
   }
 
   if (ocount != rcount) {
     safe_str(T("#-1 NUMBER OF WORDS MUST BE EQUAL"), buff, bp);
-    mush_free((Malloc_t) orig, "ptrarray");
-    mush_free((Malloc_t) repl, "ptrarray");
+    mush_free(orig, "ptrarray");
+    mush_free(repl, "ptrarray");
     return;
   }
 
@@ -2210,8 +2219,8 @@
 
   arr2list(orig, ocount, buff, bp, osep);
 
-  mush_free((Malloc_t) orig, "ptrarray");
-  mush_free((Malloc_t) repl, "ptrarray");
+  mush_free(orig, "ptrarray");
+  mush_free(repl, "ptrarray");
 }
 
 /* ARGSUSED */
@@ -2272,8 +2281,8 @@
   *lp = '\0';
   lp = trim_space_sep(list, sep);
   if (!*lp) {
-    mush_free((Malloc_t) outsep, "string");
-    mush_free((Malloc_t) list, "string");
+    mush_free(outsep, "string");
+    mush_free(list, "string");
     return;
   }
 
@@ -2294,22 +2303,22 @@
     sp = tbuf2;
     if (process_expression(buff, bp, &sp, executor, caller, enactor,
                            PE_DEFAULT, PT_DEFAULT, pe_info)) {
-      mush_free((Malloc_t) tbuf2, "replace_string.buff");
+      mush_free(tbuf2, "replace_string.buff");
       break;
     }
     if (*bp == (buff + BUFFER_LEN - 1) && pe_info->fun_invocations == funccount) {
-      mush_free((Malloc_t) tbuf2, "replace_string.buff");
+      mush_free(tbuf2, "replace_string.buff");
       break;
     }
     funccount = pe_info->fun_invocations;
     oldbp = *bp;
-    mush_free((Malloc_t) tbuf2, "replace_string.buff");
+    mush_free(tbuf2, "replace_string.buff");
   }
   *place = 0;
   iter_rep[inum] = NULL;
   inum--;
-  mush_free((Malloc_t) outsep, "string");
-  mush_free((Malloc_t) list, "string");
+  mush_free(outsep, "string");
+  mush_free(list, "string");
 }
 
 /* ARGSUSED */
@@ -2457,7 +2466,7 @@
     funccount = pe_info->fun_invocations;
   }
 
-  free((Malloc_t) asave);
+  free(asave);
   free_anon_attrib(attrib);
   restore_global_env("step", preserve);
 }
@@ -2590,6 +2599,8 @@
   size_t col = 0;
   size_t offset, col_len;
   char sep, osep, *cp, *t;
+  char aligntype = '<';
+  char *fwidth;
   ansi_string *as;
 
   if (!delim_check(buff, bp, nargs, args, 5, &osep))
@@ -2610,11 +2621,15 @@
       line_length = 2;
   }
   if (nargs > 1) {
-    if (!is_integer(args[1])) {
+    fwidth = args[1];
+    if ((*fwidth) == '<' || (*fwidth) == '>' || (*fwidth) == '-') {
+      aligntype = *(fwidth++);
+    }
+    if (!is_integer(fwidth)) {
       safe_str(T(e_ints), buff, bp);
       return;
     }
-    field_width = parse_integer(args[1]);
+    field_width = parse_integer(fwidth);
     if (field_width < 1)
       field_width = 1;
     if (field_width >= BUFFER_LEN)
@@ -2641,10 +2656,29 @@
   col_len = strlen(t);
   if (col_len > field_width)
     col_len = field_width;
-  safe_ansi_string(as, offset, col_len, buff, bp);
-  if (safe_fill(' ', field_width - col_len, buff, bp)) {
-    free_ansi_string(as);
-    return;
+  switch (aligntype) {
+  case '<':
+    safe_ansi_string(as, offset, col_len, buff, bp);
+    if (safe_fill(' ', field_width - col_len, buff, bp)) {
+      free_ansi_string(as);
+      return;
+    }
+    break;
+  case '>':
+    safe_fill(' ', field_width - col_len, buff, bp);
+    if (safe_ansi_string(as, offset, col_len, buff, bp)) {
+      free_ansi_string(as);
+      return;
+    }
+    break;
+  case '-':
+    safe_fill(' ', (field_width - col_len) / 2, buff, bp);
+    safe_ansi_string(as, offset, col_len, buff, bp);
+    if (safe_fill(' ', (field_width - col_len + 1) / 2, buff, bp)) {
+      free_ansi_string(as);
+      return;
+    }
+    break;
   }
   col = field_width + (osep != '\0');
   while (cp) {
@@ -2666,9 +2700,30 @@
     col_len = strlen(t);
     if (col_len > field_width)
       col_len = field_width;
-    safe_ansi_string(as, offset, col_len, buff, bp);
-    if (safe_fill(' ', field_width - col_len, buff, bp))
+    switch (aligntype) {
+    case '<':
+      safe_ansi_string(as, offset, col_len, buff, bp);
+      if (safe_fill(' ', field_width - col_len, buff, bp)) {
+        free_ansi_string(as);
+        return;
+      }
       break;
+    case '>':
+      safe_fill(' ', field_width - col_len, buff, bp);
+      if (safe_ansi_string(as, offset, col_len, buff, bp)) {
+        free_ansi_string(as);
+        return;
+      }
+      break;
+    case '-':
+      safe_fill(' ', (field_width - col_len) / 2, buff, bp);
+      safe_ansi_string(as, offset, col_len, buff, bp);
+      if (safe_fill(' ', (field_width - col_len + 1) / 2, buff, bp)) {
+        free_ansi_string(as);
+        return;
+      }
+      break;
+    }
   }
   free_ansi_string(as);
 }
Index: src/lock.c
===================================================================
--- src/lock.c	(.../183p10)	(revision 142)
+++ src/lock.c	(.../183p11)	(revision 142)
@@ -351,7 +351,7 @@
     return L_KEY(ll);
 }
 
-/** Given a lock type, find a lock without checking parents. 
+/** Given a lock type, find a lock without checking parents.
  * \param thing object on which lock is to be found.
  * \param type type of lock to find.
  * \return pointer to boolexp of lock.
@@ -436,7 +436,7 @@
 const lock_list *
 get_lockproto(lock_type type)
 {
-  return hashfind(type, &htab_locks);
+  return hashfind(strupper(type), &htab_locks);
 }
 
 /** Add a lock to an object (primitive).
Index: src/lmathtab.c
===================================================================
--- src/lmathtab.c	(.../183p10)	(revision 142)
+++ src/lmathtab.c	(.../183p11)	(revision 142)
@@ -1,4 +1,4 @@
-/* ANSI-C code produced by gperf version 3.0.3p1 */
+/* ANSI-C code produced by gperf version 3.0.3 */
 /* Command-line: gperf --output-file lmathtab.c lmathtab.gperf  */
 /* Computed positions: -k'1-2,5' */
 
@@ -60,14 +60,20 @@
 MATH_PROTO(math_stddev);
 MATH_PROTO(math_dist2d);
 MATH_PROTO(math_dist3d);
+MATH_PROTO(math_lt);
+MATH_PROTO(math_lte);
+MATH_PROTO(math_gt);
+MATH_PROTO(math_gte);
+MATH_PROTO(math_eq);
+MATH_PROTO(math_neq);
 
 /** A math function. */
-#line 44 "lmathtab.gperf"
+#line 50 "lmathtab.gperf"
 struct math {
   const char *name;     /**< Name of the function. */
   void (*func) (char **, int, char *, char **); /**< Pointer to function code. */
 };
-/* maximum key range = 46, duplicates = 0 */
+/* maximum key range = 63, duplicates = 0 */
 
 #ifndef GPERF_DOWNCASE
 #define GPERF_DOWNCASE 1
@@ -114,40 +120,41 @@
 
 #ifdef __GNUC__
 __inline
-#ifdef __GNUC_STDC_INLINE__
-  __attribute__ ((__gnu_inline__))
+#else
+#ifdef __cplusplus
+inline
 #endif
 #endif
-    static unsigned int
-     math_hash(register const char *str, register unsigned int len)
+  static unsigned int
+math_hash(register const char *str, register unsigned int len)
 {
   static unsigned char asso_values[] = {
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    5, 0, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 0, 25, 49, 25, 0,
-    18, 49, 49, 10, 49, 49, 0, 10, 0, 5,
-    49, 49, 0, 15, 10, 30, 49, 49, 3, 49,
-    49, 49, 49, 49, 49, 49, 49, 0, 25, 49,
-    25, 0, 18, 49, 49, 10, 49, 49, 0, 10,
-    0, 5, 49, 49, 0, 15, 10, 30, 49, 49,
-    3, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
-    49, 49, 49, 49, 49, 49
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    10, 5, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 10, 15, 65, 30, 0,
+    30, 0, 65, 0, 65, 65, 5, 5, 0, 20,
+    65, 0, 10, 15, 3, 8, 65, 65, 25, 65,
+    65, 65, 65, 65, 65, 65, 65, 10, 15, 65,
+    30, 0, 30, 0, 65, 0, 65, 65, 5, 5,
+    0, 20, 65, 0, 10, 15, 3, 8, 65, 65,
+    25, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+    65, 65, 65, 65, 65, 65
   };
   register int hval = len;
 
@@ -175,84 +182,102 @@
                                   register unsigned int len)
 {
   enum {
-    TOTAL_KEYWORDS = 25,
+    TOTAL_KEYWORDS = 31,
     MIN_WORD_LENGTH = 2,
     MAX_WORD_LENGTH = 9,
-    MIN_HASH_VALUE = 3,
-    MAX_HASH_VALUE = 48
+    MIN_HASH_VALUE = 2,
+    MAX_HASH_VALUE = 64
   };
 
   static unsigned char lengthtable[] = {
-    0, 0, 0, 3, 4, 0, 0, 2, 3, 0, 0, 3, 0, 3,
-    4, 0, 6, 0, 3, 9, 0, 6, 7, 3, 0, 0, 8, 0,
-    3, 4, 0, 6, 4, 3, 0, 0, 0, 0, 3, 0, 0, 6,
-    0, 3, 0, 0, 6, 4, 3
+    0, 0, 2, 3, 0, 2, 3, 0, 3, 4, 2, 3, 0, 3,
+    4, 0, 3, 0, 3, 9, 0, 6, 0, 3, 6, 0, 3, 0,
+    3, 4, 0, 0, 2, 3, 0, 0, 6, 7, 3, 0, 0, 6,
+    0, 3, 4, 0, 6, 0, 3, 0, 0, 0, 0, 8, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 4
   };
   static struct math wordlist[] = {
-    {"", NULL}, {"", NULL}, {"", NULL},
-#line 60 "lmathtab.gperf"
-    {"AND", math_and},
-#line 61 "lmathtab.gperf"
-    {"NAND", math_nand},
-    {"", NULL}, {"", NULL},
-#line 62 "lmathtab.gperf"
-    {"OR", math_or},
-#line 63 "lmathtab.gperf"
-    {"NOR", math_nor},
     {"", NULL}, {"", NULL},
-#line 64 "lmathtab.gperf"
-    {"XOR", math_xor},
+#line 84 "lmathtab.gperf"
+    {"EQ", math_eq},
+#line 85 "lmathtab.gperf"
+    {"NEQ", math_neq},
     {"", NULL},
-#line 59 "lmathtab.gperf"
-    {"MAX", math_max},
-#line 69 "lmathtab.gperf"
+#line 82 "lmathtab.gperf"
+    {"GT", math_gt},
+#line 83 "lmathtab.gperf"
+    {"GTE", math_gte},
+    {"", NULL},
+#line 64 "lmathtab.gperf"
+    {"MIN", math_min},
+#line 75 "lmathtab.gperf"
     {"MEAN", math_mean},
+#line 80 "lmathtab.gperf"
+    {"LT", math_lt},
+#line 81 "lmathtab.gperf"
+    {"LTE", math_lte},
     {"", NULL},
-#line 70 "lmathtab.gperf"
-    {"MEDIAN", math_median},
+#line 66 "lmathtab.gperf"
+    {"AND", math_and},
+#line 67 "lmathtab.gperf"
+    {"NAND", math_nand},
     {"", NULL},
-#line 54 "lmathtab.gperf"
-    {"MOD", math_modulo},
 #line 57 "lmathtab.gperf"
+    {"MUL", math_mul},
+    {"", NULL},
+#line 65 "lmathtab.gperf"
+    {"MAX", math_max},
+#line 63 "lmathtab.gperf"
     {"REMAINDER", math_remainder},
     {"", NULL},
-#line 55 "lmathtab.gperf"
-    {"MODULO", math_modulo},
-#line 56 "lmathtab.gperf"
-    {"MODULUS", math_modulo},
-#line 58 "lmathtab.gperf"
-    {"MIN", math_min},
-    {"", NULL}, {"", NULL},
-#line 53 "lmathtab.gperf"
-    {"FLOORDIV", math_floordiv},
+#line 76 "lmathtab.gperf"
+    {"MEDIAN", math_median},
     {"", NULL},
-#line 49 "lmathtab.gperf"
-    {"ADD", math_add},
-#line 65 "lmathtab.gperf"
-    {"BAND", math_band},
+#line 69 "lmathtab.gperf"
+    {"NOR", math_nor},
+#line 77 "lmathtab.gperf"
+    {"STDDEV", math_stddev},
     {"", NULL},
+#line 56 "lmathtab.gperf"
+    {"SUB", math_sub},
+    {"", NULL},
+#line 60 "lmathtab.gperf"
+    {"MOD", math_modulo},
 #line 71 "lmathtab.gperf"
-    {"STDDEV", math_stddev},
-#line 67 "lmathtab.gperf"
-    {"BXOR", math_bxor},
-#line 66 "lmathtab.gperf"
-    {"BOR", math_bor},
-    {"", NULL}, {"", NULL}, {"", NULL}, {"", NULL},
-#line 52 "lmathtab.gperf"
+    {"BAND", math_band},
+    {"", NULL}, {"", NULL},
+#line 68 "lmathtab.gperf"
+    {"OR", math_or},
+#line 58 "lmathtab.gperf"
     {"DIV", math_div},
     {"", NULL}, {"", NULL},
-#line 73 "lmathtab.gperf"
+#line 61 "lmathtab.gperf"
+    {"MODULO", math_modulo},
+#line 62 "lmathtab.gperf"
+    {"MODULUS", math_modulo},
+#line 72 "lmathtab.gperf"
+    {"BOR", math_bor},
+    {"", NULL}, {"", NULL},
+#line 79 "lmathtab.gperf"
     {"DIST3D", math_dist3d},
     {"", NULL},
-#line 51 "lmathtab.gperf"
-    {"MUL", math_mul},
-    {"", NULL}, {"", NULL},
-#line 72 "lmathtab.gperf"
+#line 55 "lmathtab.gperf"
+    {"ADD", math_add},
+#line 73 "lmathtab.gperf"
+    {"BXOR", math_bxor},
+    {"", NULL},
+#line 78 "lmathtab.gperf"
     {"DIST2D", math_dist2d},
-#line 68 "lmathtab.gperf"
-    {"FDIV", math_fdiv},
-#line 50 "lmathtab.gperf"
-    {"SUB", math_sub}
+    {"", NULL},
+#line 70 "lmathtab.gperf"
+    {"XOR", math_xor},
+    {"", NULL}, {"", NULL}, {"", NULL}, {"", NULL},
+#line 59 "lmathtab.gperf"
+    {"FLOORDIV", math_floordiv},
+    {"", NULL}, {"", NULL}, {"", NULL}, {"", NULL}, {"", NULL},
+    {"", NULL}, {"", NULL}, {"", NULL}, {"", NULL}, {"", NULL},
+#line 74 "lmathtab.gperf"
+    {"FDIV", math_fdiv}
   };
 
   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH) {
@@ -270,7 +295,7 @@
   return 0;
 }
 
-#line 74 "lmathtab.gperf"
+#line 86 "lmathtab.gperf"
 
 
 typedef struct math MATH;
Index: src/player.c
===================================================================
--- src/player.c	(.../183p10)	(revision 142)
+++ src/player.c	(.../183p11)	(revision 142)
@@ -93,7 +93,7 @@
     if (strcmp(crypt(password, "XX"), saved) != 0)
       /* Nope */
 #endif                          /* HAS_CRYPT */
-      /* crypt() didn't work. Try plaintext, being sure to not 
+      /* crypt() didn't work. Try plaintext, being sure to not
        * allow unencrypted entry of encrypted password */
       if ((strcmp(saved, password) != 0)
           || (strlen(password) < 4)
@@ -363,10 +363,10 @@
 make_player(const char *name, const char *password, const char *host,
             const char *ip, dbref try_dbref)
 {
-
   dbref player;
   char temp[SBUF_LEN];
-
+  char *flaglist, *flagname;
+  char flagbuff[BUFFER_LEN];
 
   if (try_dbref != NOTHING && GoodObject(try_dbref) && IsGarbage(try_dbref)) {
     if (!make_first_free(try_dbref))
@@ -382,7 +382,15 @@
   Owner(player) = player;
   Parent(player) = NOTHING;
   Type(player) = TYPE_PLAYER;
-  Flags(player) = string_to_bits("FLAG", options.player_flags);
+  Flags(player) = new_flag_bitmask("FLAG");
+  strcpy(flagbuff, options.player_flags);
+  flaglist = trim_space_sep(flagbuff, ' ');
+  if (*flaglist != '\0') {
+    while (flaglist) {
+      flagname = split_token(&flaglist, ' ');
+      twiddle_flag_internal("FLAG", player, flagname, 0);
+    }
+  }
   if (Suspect_Site(host, player) || Suspect_Site(ip, player))
     set_flag_internal(player, "SUSPECT");
   set_initial_warnings(player);
Index: src/look.c
===================================================================
--- src/look.c	(.../183p10)	(revision 142)
+++ src/look.c	(.../183p11)	(revision 142)
@@ -11,6 +11,7 @@
 #define _GNU_SOURCE
 #include <string.h>
 #include <ctype.h>
+#include <stdlib.h>
 
 #include "conf.h"
 #include "externs.h"
@@ -114,17 +115,17 @@
     process_expression(buff, &bp, &sp, loc, player, player,
                        PE_DEFAULT, PT_DEFAULT, NULL);
     *bp = '\0';
-    free((Malloc_t) save);
+    free(save);
     notify_by(loc, player, buff);
     for (j = 0; j < 10; j++) {
       global_eval_context.wenv[j] = wsave[j];
     }
     restore_global_regs("look_exits", rsave);
-    mush_free((Malloc_t) tbuf1, "string");
-    mush_free((Malloc_t) tbuf2, "string");
-    mush_free((Malloc_t) nbuf, "string");
-    mush_free((Malloc_t) arg, "string");
-    mush_free((Malloc_t) buff, "string");
+    mush_free(tbuf1, "string");
+    mush_free(tbuf2, "string");
+    mush_free(nbuf, "string");
+    mush_free(arg, "string");
+    mush_free(buff, "string");
     return;
   }
   /* Scan the room and see if there are any visible exits */
@@ -154,9 +155,9 @@
   }
   if (total_count == 0) {
     /* No visible exits. We are outta here */
-    mush_free((Malloc_t) tbuf1, "string");
-    mush_free((Malloc_t) tbuf2, "string");
-    mush_free((Malloc_t) nbuf, "string");
+    mush_free(tbuf1, "string");
+    mush_free(tbuf2, "string");
+    mush_free(nbuf, "string");
     return;
   }
 
@@ -218,9 +219,9 @@
   }
   *s2 = '\0';
   notify_by(loc, player, tbuf2);
-  mush_free((Malloc_t) tbuf1, "string");
-  mush_free((Malloc_t) tbuf2, "string");
-  mush_free((Malloc_t) nbuf, "string");
+  mush_free(tbuf1, "string");
+  mush_free(tbuf2, "string");
+  mush_free(nbuf, "string");
 }
 
 
@@ -279,15 +280,15 @@
     process_expression(buff, &bp, &sp, loc, player, player,
                        PE_DEFAULT, PT_DEFAULT, NULL);
     *bp = '\0';
-    free((Malloc_t) save);
+    free(save);
     notify_by(loc, player, buff);
     for (j = 0; j < 10; j++) {
       global_eval_context.wenv[j] = wsave[j];
     }
     restore_global_regs("look_contents", rsave);
-    mush_free((Malloc_t) arg, "string");
-    mush_free((Malloc_t) arg2, "string");
-    mush_free((Malloc_t) buff, "string");
+    mush_free(arg, "string");
+    mush_free(arg2, "string");
+    mush_free(buff, "string");
     return;
   }
   /* check to see if there is anything there */
@@ -325,7 +326,7 @@
                    __attribute__ ((__unused__)))
 {
   char fbuf[BUFFER_LEN];
-  char const *r;
+  char *r;
 
   if (EX_PUBLIC_ATTRIBS &&
       !strcmp(AL_NAME(atr), "DESCRIBE") && !strcmp(pattern, "*"))
@@ -372,7 +373,7 @@
         notify_format(player, "%s [#%d%s]: %s", AL_NAME(atr),
                       Owner(AL_CREATOR(atr)), fbuf, r);
     }
-    free((Malloc_t) r);
+    free(r);
   }
   return 1;
 }
@@ -384,7 +385,7 @@
             __attribute__ ((__unused__)))
 {
   char fbuf[BUFFER_LEN];
-  char const *r;
+  char *r;
 
   if (EX_PUBLIC_ATTRIBS &&
       !strcmp(AL_NAME(atr), "DESCRIBE") && !strcmp(pattern, "*"))
@@ -410,7 +411,7 @@
       notify_format(player, "%s [#%d%s]: %s", AL_NAME(atr),
                     Owner(AL_CREATOR(atr)), fbuf, r);
   }
-  free((Malloc_t) r);
+  free(r);
   return 1;
 }
 
@@ -583,7 +584,7 @@
     process_expression(buff, &bp, &ap, thing, player, player,
                        PE_DEFAULT, PT_DEFAULT, NULL);
     *bp = '\0';
-    free((Malloc_t) asave);
+    free(asave);
   }
   f = atr_get(thing, descformatname);
   if (f) {
@@ -596,7 +597,7 @@
     process_expression(fbuff, &fbp, &ap, thing, player, player,
                        PE_DEFAULT, PT_DEFAULT, NULL);
     *fbp = '\0';
-    free((Malloc_t) asave);
+    free(asave);
     notify_by(thing, player, fbuff);
   } else if (a) {
     /* DESCRIBE only */
@@ -822,7 +823,7 @@
     if (a) {
       r = safe_atr_value(a);
       notify(player, r);
-      free((Malloc_t) r);
+      free(r);
     }
   }
   if (ok) {
@@ -1035,15 +1036,15 @@
     process_expression(buff, &bp, &sp, player, player, player,
                        PE_DEFAULT, PT_DEFAULT, NULL);
     *bp = '\0';
-    free((Malloc_t) save);
+    free(save);
     notify(player, buff);
     for (j = 0; j < 10; j++) {
       global_eval_context.wenv[j] = wsave[j];
     }
     restore_global_regs("do_inventory", rsave);
-    mush_free((Malloc_t) arg, "string");
-    mush_free((Malloc_t) arg2, "string");
-    mush_free((Malloc_t) buff, "string");
+    mush_free(arg, "string");
+    mush_free(arg2, "string");
+    mush_free(buff, "string");
     return;
   }
 
@@ -1556,6 +1557,7 @@
   dbref thing;
   const char *object = NULL;
   char *attrib, *name;
+  char *attrname;
   char dbnum[40];
 
   /* @decompile must always have an argument */
@@ -1584,16 +1586,19 @@
 
   /* if we have an attribute arg specified, wild match on it */
   if (attrib && *attrib) {
-    switch (dbflag) {
-    case DEC_DB:
-      decompile_atrs(player, thing, dbnum, attrib, prefix, skipdef);
-      break;
-    default:
-      if (IsRoom(thing))
-        decompile_atrs(player, thing, "here", attrib, prefix, skipdef);
-      else
-        decompile_atrs(player, thing, Name(thing), attrib, prefix, skipdef);
-      break;
+    attrname = attrib;
+    while ((attrib = split_token(&attrname, ' ')) != NULL) {
+      switch (dbflag) {
+      case DEC_DB:
+        decompile_atrs(player, thing, dbnum, attrib, prefix, skipdef);
+        break;
+      default:
+        if (IsRoom(thing))
+          decompile_atrs(player, thing, "here", attrib, prefix, skipdef);
+        else
+          decompile_atrs(player, thing, Name(thing), attrib, prefix, skipdef);
+        break;
+      }
     }
     mush_free(name, "dd.string");
     return;
Index: src/notify.c
===================================================================
--- src/notify.c	(.../183p10)	(revision 142)
+++ src/notify.c	(.../183p11)	(revision 142)
@@ -96,12 +96,12 @@
  * option negotiation code for setting client-side line-editing mode
  * to it. If it gets a reply, a flag in the descriptor struct is
  * turned on indicated telnet-awareness.
- * 
+ *
  * If the reply indicates that the client supports linemode, further
  * instructions as to what linemode options are to be used is sent.
  * Those options: Client-side line editing, and expanding literal
  * client-side-entered tabs into spaces.
- * 
+ *
  * Option negotation requests sent by the client are processed,
  * with the only one we confirm rather than refuse outright being
  * suppress-go-ahead, since a number of telnet clients try it.
@@ -662,14 +662,11 @@
 
   if (!d->connected) {
     /* These are the settings used at, e.g., the connect screen,
-     * when there's no connected player yet. If you want to use
-     * ansified connect screens, you'd probably change NA_NPASCII
-     * to NA_NCOLOR (for no accents) or NA_COLOR (for accents). 
-     * We don't recommend it. If you want to use accented characters,
-     * change NA_NPUEBLO and NA_NPASCII to NA_PUEBLO and NA_PASCII,
-     * respectively. That's not so bad.
+     * when there's no connected player yet. If you want to use accented
+     * characters, change NA_NPUEBLO and NA_NCOLOR to NA_PUEBLO and
+     * NA_COLOR, respectively.
      */
-    return (d->conn_flags & CONN_HTML) ? NA_NPUEBLO : NA_NPASCII;
+    return (d->conn_flags & CONN_HTML) ? NA_NPUEBLO : NA_NCOLOR;
   }
 
   /* At this point, we have a connected player on the descriptor */
@@ -895,12 +892,12 @@
       if (AF_Regexp(a)
           ? regexp_match_case_r(tbuf1,
                                 (char *) notify_makestring(msgbuf, messages,
-                                                           NA_ASCII, 0),
+                                                           NA_COLOR, 0),
                                 AF_Case(a), global_eval_context.wnxt, 10,
                                 match_space, match_space_len)
           : wild_match_case_r(tbuf1,
                               (char *) notify_makestring(msgbuf, messages,
-                                                         NA_ASCII, 0),
+                                                         NA_COLOR, 0),
                               AF_Case(a), global_eval_context.wnxt, 10,
                               match_space, match_space_len)) {
         if (eval_lock(speaker, target, Listen_Lock))
@@ -914,7 +911,7 @@
         if (!(flags & NA_NORELAY) && (loc != target) &&
             !filter_found(target,
                           (char *) notify_makestring(msgbuf, messages,
-                                                     NA_ASCII, 0), 1)) {
+                                                     NA_COLOR, 0), 1)) {
           passalong[0] = target;
           passalong[1] = target;
           passalong[2] = Owner(target);
@@ -954,7 +951,7 @@
         && eval_lock(speaker, target, Listen_Lock)
       )
       atr_comm_match(target, speaker, '^', ':',
-                     (char *) notify_makestring(msgbuf, messages, NA_ASCII, 0),
+                     (char *) notify_makestring(msgbuf, messages, NA_COLOR, 0),
                      0, 1, NULL, NULL, NULL);
 
     /* If object is flagged AUDIBLE and has a @FORWARDLIST, send
@@ -969,19 +966,19 @@
 
   for (i = 0; i < MESSAGE_TYPES; i++) {
     if (messages[i].message)
-      mush_free((Malloc_t) messages[i].message, "string");
+      mush_free(messages[i].message, "string");
     if (nospoofs[i].message)
-      mush_free((Malloc_t) nospoofs[i].message, "string");
+      mush_free(nospoofs[i].message, "string");
     if (paranoids[i].message)
-      mush_free((Malloc_t) paranoids[i].message, "string");
+      mush_free(paranoids[i].message, "string");
   }
   if (nospoof)
-    mush_free((Malloc_t) nospoof, "string");
+    mush_free(nospoof, "string");
   if (paranoid)
-    mush_free((Malloc_t) paranoid, "string");
+    mush_free(paranoid, "string");
   if (tbuf1)
-    mush_free((Malloc_t) tbuf1, "string");
-  mush_free((Malloc_t) msgbuf, "string");
+    mush_free(tbuf1, "string");
+  mush_free(msgbuf, "string");
   na_depth--;
 }
 
@@ -1134,7 +1131,7 @@
       }
     }
   }
-  free((Malloc_t) orig);
+  free(orig);
 }
 
 /** Wrapper to notify a single player with a message, unconditionally.
@@ -1149,7 +1146,7 @@
 
 /** Notify all connected players with the given flag(s).
  * If no flags are given, everyone is notified. If one flag list is given,
- * all connected players with some flag in that list are notified. 
+ * all connected players with some flag in that list are notified.
  * If two flag lists are given, all connected players with at least one flag
  * in each list are notified.
  * \param flag1 first required flag list or NULL
@@ -1220,7 +1217,7 @@
 {
   if (t) {
     if (t->buf)
-      mush_free((Malloc_t) t->buf, "text_block_buff");
+      mush_free(t->buf, "text_block_buff");
     slab_free(text_block_slab, t);
   }
 }
@@ -1457,7 +1454,7 @@
   d->input.tail = &d->input.head;
 
   if (d->raw_input) {
-    mush_free((Malloc_t) d->raw_input, "descriptor_raw_input");
+    mush_free(d->raw_input, "descriptor_raw_input");
   }
   d->raw_input = 0;
   d->raw_input_at = 0;
Index: src/parse.c
===================================================================
--- src/parse.c	(.../183p10)	(revision 142)
+++ src/parse.c	(.../183p11)	(revision 142)
@@ -175,7 +175,7 @@
  * a non-zero number is true, and everything else is false.
  * To PennMUSH, negative dbrefs are false, non-negative dbrefs are true,
  * 0 is false, all other numbers are true, empty or blank strings are false,
- * and all other strings are true. 
+ * and all other strings are true.
  * \param str string to parse.
  * \retval 1 str represents a true value.
  * \retval 0 str represents a false value.
@@ -247,7 +247,7 @@
 
 /** Is a string an objid?
  * An objid is a string starting with a #, optionally followed by a -,
- * and then followed by at least one digit, then optionally followed 
+ * and then followed by at least one digit, then optionally followed
  * by a : and at least one digit, and nothing else.
  * In regex: ^#-?\d+(:\d+)?$
  * \param str string to check.
@@ -592,7 +592,7 @@
  * place to be filled (ala safe_str() and safe_chr()).  Be very
  * careful about not overflowing buff; use of safe_str() and safe_chr()
  * for all writes into buff is highly recommended.
- * 
+ *
  * nargs is the count of the number of arguments passed to the function,
  * and args is an array of pointers to them.  args will have at least
  * nargs elements, or 10 elements, whichever is greater.  The first ten
@@ -601,7 +601,7 @@
  * The argument strings are stored in BUFFER_LEN buffers, but reliance
  * on that size is also considered bad form.  The argument strings may
  * be modified, but modifying the pointers to the argument strings will
- * cause crashes. 
+ * cause crashes.
  *
  * executor corresponds to %!, the object invoking the function.
  * caller   corresponds to %@, the last object to do a U() or similar.
@@ -1344,8 +1344,7 @@
            * Special case: zero args is recognized as one null arg.
            */
           if ((fp->minargs == 0) && (nfargs == 1) && !*fargs[0]) {
-            mush_free((Malloc_t) fargs[0],
-                      "process_expression.function_argument");
+            mush_free(fargs[0], "process_expression.function_argument");
             fargs[0] = NULL;
             arglens[0] = 0;
             nfargs = 0;
@@ -1370,8 +1369,11 @@
             safe_str(T(" ARGUMENTS BUT GOT "), buff, bp);
             safe_integer(nfargs, buff, bp);
           } else {
+            char *preserve[NUMQ];
             global_fun_recursions++;
             pe_info->fun_depth++;
+            if (fp->flags & FN_LOCALIZE)
+              save_global_regs("@function.save", preserve);
             if (fp->flags & FN_BUILTIN) {
               global_fun_invocations++;
               pe_info->fun_invocations++;
@@ -1413,15 +1415,12 @@
                 safe_str(fp->where.ufun->name, buff, bp);
                 safe_chr(')', buff, bp);
               } else {
-                char *preserve[NUMQ];
-                if (fp->flags & FN_LOCALIZE)
-                  save_global_regs("@function.save", preserve);
                 do_userfn(buff, bp, thing, attrib, nfargs, fargs,
                           executor, caller, enactor, pe_info, PE_USERFN);
-                if (fp->flags & FN_LOCALIZE)
-                  restore_global_regs("@function.save", preserve);
               }
             }
+            if (fp->flags & FN_LOCALIZE)
+              restore_global_regs("@function.save", preserve);
             pe_info->fun_depth--;
             global_fun_recursions--;
           }
@@ -1430,12 +1429,11 @@
       free_func_args:
         for (j = 0; j < nfargs; j++)
           if (fargs[j])
-            mush_free((Malloc_t) fargs[j],
-                      "process_expression.function_argument");
+            mush_free(fargs[j], "process_expression.function_argument");
         if (fargs != sargs)
-          mush_free((Malloc_t) fargs, "process_expression.function_arglist");
+          mush_free(fargs, "process_expression.function_arglist");
         if (arglens != sarglens)
-          mush_free((Malloc_t) arglens, "process_expression.function_arglens");
+          mush_free(arglens, "process_expression.function_arglens");
       }
       break;
       /* Space compression */
@@ -1492,11 +1490,10 @@
             notify_list(executor, executor, "DEBUGFORWARDLIST", dbuf,
                         NA_NOLISTEN | NA_NOPREFIX);
             pe_info->debug_strings = pe_info->debug_strings->next;
-            mush_free((Malloc_t) pe_info->debug_strings->prev,
+            mush_free(pe_info->debug_strings->prev,
                       "process_expression.debug_node");
           }
-          mush_free((Malloc_t) pe_info->debug_strings,
-                    "process_expression.debug_node");
+          mush_free(pe_info->debug_strings, "process_expression.debug_node");
           pe_info->debug_strings = NULL;
         }
         dbp = dbuf;
@@ -1514,23 +1511,23 @@
           pe_info->debug_strings = node->prev;
           if (node->prev)
             node->prev->next = NULL;
-          mush_free((Malloc_t) node, "process_expression.debug_node");
+          mush_free(node, "process_expression.debug_node");
         }
       }
-      mush_free((Malloc_t) debugstr, "process_expression.debug_source");
+      mush_free(debugstr, "process_expression.debug_source");
     }
     if (realbuff) {
       **bp = '\0';
       *bp = realbp;
       safe_str(buff, realbuff, bp);
-      mush_free((Malloc_t) buff, "process_expression.buffer_extension");
+      mush_free(buff, "process_expression.buffer_extension");
     }
   }
   /* Once we cross call limit, we stay in error */
   if (pe_info && CALL_LIMIT && pe_info->call_depth <= CALL_LIMIT)
     pe_info->call_depth--;
   if (made_info)
-    mush_free((Malloc_t) pe_info, "process_expression.pe_info");
+    mush_free(pe_info, "process_expression.pe_info");
   if (old_iter_limit != -1) {
     inum_limit = old_iter_limit;
   }
Index: src/command.c
===================================================================
--- src/command.c	(.../183p10)	(revision 142)
+++ src/command.c	(.../183p11)	(revision 142)
@@ -242,7 +242,7 @@
   {"@PCREATE", NULL, cmd_pcreate, CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_RS_ARGS, 0,
    0},
 
-  {"@PEMIT", "LIST CONTENTS SILENT NOISY NOEVAL SPOOF", cmd_pemit,
+  {"@PEMIT", "LIST CONTENTS SILENT NOISY NOEVAL PORT SPOOF", cmd_pemit,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED, 0, 0},
   {"@POLL", "CLEAR", cmd_poll, CMD_T_ANY, 0, 0},
   {"@POOR", NULL, cmd_poor, CMD_T_ANY, 0, 0},
@@ -346,8 +346,6 @@
   {"SEMIPOSE", "NOEVAL", cmd_semipose, CMD_T_ANY | CMD_T_NOGAGGED, 0, 0},
   {"SLAY", NULL, cmd_slay, CMD_T_ANY, 0, 0},
 
-  {"TAKE", NULL, cmd_take, CMD_T_PLAYER | CMD_T_THING | CMD_T_NOGAGGED,
-   0, 0},
   {"TEACH", NULL, cmd_teach, CMD_T_ANY | CMD_T_NOPARSE, 0, 0},
   {"THINK", "NOEVAL", cmd_think, CMD_T_ANY | CMD_T_NOGAGGED, 0, 0},
 
@@ -360,6 +358,10 @@
   {"WITH", "NOEVAL ROOM", cmd_with, CMD_T_PLAYER | CMD_T_THING | CMD_T_EQSPLIT,
    0, 0},
 
+  {"WHO", NULL, cmd_who, CMD_T_ANY, 0, 0},
+  {"DOING", NULL, cmd_who_doing, CMD_T_ANY, 0, 0},
+  {"SESSION", NULL, cmd_session, CMD_T_ANY, 0, 0},
+
 /* ATTRIB_SET is an undocumented command - it's sugar to make it possible
  * enable/disable attribute setting with &XX or @XX
  */
@@ -982,11 +984,11 @@
 
 /** A handy macro to free up the command_parse-allocated variables */
 #define command_parse_free_args \
-    mush_free((Malloc_t) command, "string"); \
-    mush_free((Malloc_t) swtch, "string"); \
-    mush_free((Malloc_t) ls, "string"); \
-    mush_free((Malloc_t) rs, "string"); \
-    mush_free((Malloc_t) switches, "string")
+    mush_free(command, "string"); \
+    mush_free(swtch, "string"); \
+    mush_free(ls, "string"); \
+    mush_free(rs, "string"); \
+    mush_free(switches, "string")
 
 /** Parse commands.
  * Parse the commands. This is the big one!
@@ -1114,8 +1116,8 @@
     if (*p != NUMBER_TOKEN)
       p++;
   } else {
-    /* At this point, we have not done a replacer, so we continue with the 
-     * usual processing. Exits have next priority.  We still pass them 
+    /* At this point, we have not done a replacer, so we continue with the
+     * usual processing. Exits have next priority.  We still pass them
      * through the parser so @hook on GOTO can work on them.
      */
     if (strcasecmp(p, "home") && can_move(player, p)) {
@@ -1304,7 +1306,7 @@
     int lsa_index;
     if (lsa[1]) {
       safe_str(lsa[1], commandraw, &c2);
-      for (lsa_index = 2; lsa[lsa_index]; lsa_index++) {
+      for (lsa_index = 2; (lsa_index < MAX_ARG) && lsa[lsa_index]; lsa_index++) {
         safe_chr(',', commandraw, &c2);
         safe_str(lsa[lsa_index], commandraw, &c2);
       }
@@ -1321,7 +1323,8 @@
          * starts at 1. */
         if (rsa[1]) {
           safe_str(rsa[1], commandraw, &c2);
-          for (rsa_index = 2; rsa[rsa_index]; rsa_index++) {
+          for (rsa_index = 2; (rsa_index < MAX_ARG) && rsa[rsa_index];
+               rsa_index++) {
             safe_chr(',', commandraw, &c2);
             safe_str(rsa[rsa_index], commandraw, &c2);
           }
@@ -2113,23 +2116,58 @@
 {
   COMMAND_INFO *cmd;
 
-  cmd = command_find(command);
-  if (!cmd) {
-    notify(player, T("No such command."));
-    return;
-  }
-  if (Wizard(player) || has_power_by_name(player, "HOOK", NOTYPE)) {
-    if (GoodObject(cmd->hooks.before.obj))
-      notify_format(player, T("@hook/before: #%d/%s"),
-                    cmd->hooks.before.obj, cmd->hooks.before.attrname);
-    if (GoodObject(cmd->hooks.after.obj))
-      notify_format(player, T("@hook/after: #%d/%s"), cmd->hooks.after.obj,
-                    cmd->hooks.after.attrname);
-    if (GoodObject(cmd->hooks.ignore.obj))
-      notify_format(player, T("@hook/ignore: #%d/%s"),
-                    cmd->hooks.ignore.obj, cmd->hooks.ignore.attrname);
-    if (GoodObject(cmd->hooks.override.obj))
-      notify_format(player, T("@hook/override: #%d/%s"),
-                    cmd->hooks.override.obj, cmd->hooks.override.attrname);
+  if (!command || !*command) {
+    /* Show all commands with hooks */
+    char *ptrs[BUFFER_LEN / 2];
+    static char buff[BUFFER_LEN];
+    char *bp;
+    int i, count = 0;
+
+    for (cmd = (COMMAND_INFO *) ptab_firstentry(&ptab_command); cmd;
+         cmd = (COMMAND_INFO *) ptab_nextentry(&ptab_command)) {
+      if (has_hook(&cmd->hooks.ignore) || has_hook(&cmd->hooks.override)
+          || has_hook(&cmd->hooks.before) || has_hook(&cmd->hooks.after)) {
+        ptrs[count] = (char *) cmd->name;
+        count++;
+      }
+    }
+    if (count == 0) {
+      notify(player, T("There are no hooks currently set."));
+      return;
+    }
+    do_gensort(0, ptrs, NULL, count, ALPHANUM_LIST);
+    bp = buff;
+    safe_str(T("The following commands have hooks: "), buff, &bp);
+    for (i = 0; i < count; i++) {
+      if (i > 0 && gencomp((dbref) 0, ptrs[i], ptrs[i - 1], ALPHANUM_LIST) <= 0)
+        continue;
+      if (i && i == (count - 1))
+        safe_str(" and ", buff, &bp);
+      else if (i)
+        safe_str(", ", buff, &bp);
+      safe_str(ptrs[i], buff, &bp);
+    }
+    *bp = '\0';
+    notify(player, buff);
+  } else {
+    cmd = command_find(command);
+    if (!cmd) {
+      notify(player, T("No such command."));
+      return;
+    }
+    if (Wizard(player) || has_power_by_name(player, "HOOK", NOTYPE)) {
+      if (GoodObject(cmd->hooks.before.obj))
+        notify_format(player, T("@hook/before: #%d/%s"),
+                      cmd->hooks.before.obj, cmd->hooks.before.attrname);
+      if (GoodObject(cmd->hooks.after.obj))
+        notify_format(player, T("@hook/after: #%d/%s"), cmd->hooks.after.obj,
+                      cmd->hooks.after.attrname);
+      if (GoodObject(cmd->hooks.ignore.obj))
+        notify_format(player, T("@hook/ignore: #%d/%s"),
+                      cmd->hooks.ignore.obj, cmd->hooks.ignore.attrname);
+      if (GoodObject(cmd->hooks.override.obj))
+        notify_format(player, T("@hook/override: #%d/%s"),
+                      cmd->hooks.override.obj, cmd->hooks.override.attrname);
+    }
   }
 }
Index: src/pcre.c
===================================================================
--- src/pcre.c	(.../183p10)	(revision 142)
+++ src/pcre.c	(.../183p11)	(revision 142)
@@ -1259,6 +1259,7 @@
 
 
 
+
 pcre_get_substring_list(const char *subject, int *ovector, int stringcount,
                         const char ***listptr);
 
@@ -1350,6 +1351,7 @@
 
 
 
+
 pcre_get_substring(const char *subject, int *ovector, int stringcount,
                    int stringnumber, const char **stringptr);
 
@@ -1408,6 +1410,7 @@
 
 
 
+
 pcre_get_named_substring(const pcre * code, const char *subject, int *ovector,
                          int stringcount, const char *stringname,
                          const char **stringptr);
@@ -2296,6 +2299,7 @@
 
 
 
+
 compile_regex(int, int, int *, uschar **, const uschar **, int *, BOOL, int,
               int *, int *, branch_chain *, compile_data *);
 
Index: src/predicat.c
===================================================================
--- src/predicat.c	(.../183p10)	(revision 142)
+++ src/predicat.c	(.../183p11)	(revision 142)
@@ -284,7 +284,7 @@
                            PE_DEFAULT, PT_DEFAULT, NULL);
         *bp = '\0';
         notify_by(thing, player, buff);
-        free((Malloc_t) asave);
+        free(asave);
       } else if (def && *def)
         notify_by(thing, player, def);
     }
@@ -314,7 +314,7 @@
           *bp = '\0';
           if (bp != sp)
             notify_except2(Contents(loc), player, thing, buff, flags);
-          free((Malloc_t) asave);
+          free(asave);
         } else {
           if (odef && *odef) {
             notify_except2(Contents(loc), player, thing,
@@ -1111,7 +1111,7 @@
       process_expression(buff, &bp, &ap, target, player, player,
                          PE_DEFAULT, PT_DEFAULT, NULL);
       *bp = '\0';
-      free((Malloc_t) asave);
+      free(asave);
       if (*buff) {
         ptr = (struct tm *) localtime(&mudtime);
         notify_format(player, T("%s message from %s: %s"), type,
@@ -1437,6 +1437,6 @@
     tp = grep_util(player, thing, pattern, lookfor, !insensitive, 0);
     notify_format(player, T("Matches of '%s' on %s(#%d): %s"), lookfor,
                   Name(thing), thing, tp);
-    mush_free((Malloc_t) tp, "grep_util.buff");
+    mush_free(tp, "grep_util.buff");
   }
 }
Index: src/set.c
===================================================================
--- src/set.c	(.../183p10)	(revision 142)
+++ src/set.c	(.../183p11)	(revision 142)
@@ -552,8 +552,8 @@
   af.setflags = mush_strdup(atrflag_to_string(af.setf), "af_flag list");
   if (!atr_iter_get(player, thing, atrname, 0, af_helper, &af))
     notify(player, T("No attribute found to change."));
-  mush_free((Malloc_t) af.clrflags, "af_flag list");
-  mush_free((Malloc_t) af.setflags, "af_flag list");
+  mush_free(af.clrflags, "af_flag list");
+  mush_free(af.setflags, "af_flag list");
 }
 
 
@@ -716,7 +716,7 @@
     }
   }
 
-  free((Malloc_t) text);        /* safe_uncompress malloc()s memory */
+  free(text);                   /* safe_uncompress malloc()s memory */
   if (copies) {
     notify_format(player, T("Attribute %s (%d copies)"),
                   (move ? T("moved") : T("copied")), copies);
Index: src/cque.c
===================================================================
--- src/cque.c	(.../183p10)	(revision 142)
+++ src/cque.c	(.../183p11)	(revision 142)
@@ -108,7 +108,7 @@
 }
 
 /* Returns true if the attribute on thing can be used as a semaphore.
- * atr should be given in UPPERCASE. 
+ * atr should be given in UPPERCASE.
  */
 static int
 waitable_attr(dbref thing, const char *atr)
@@ -215,7 +215,9 @@
     QUEUE_COST +
     (QUEUE_LOSS ? ((get_random32(0, QUEUE_LOSS - 1) == 0) ? 1 : 0) : 0);
   if (!quiet_payfor(player, estcost)) {
-    notify(Owner(player), T("Not enough money to queue command."));
+    notify_format(Owner(player),
+                  T("Not enough money to queue command for %s(#%d)."),
+                  Name(player), player);
     return 0;
   }
   if (!NoPay(player) && (estcost != QUEUE_COST) && Track_Money(Owner(player))) {
@@ -342,7 +344,7 @@
 
 
 /** Enqueue the action part of an attribute.
- * This function is a front-end to parse_que() that takes an attribute, 
+ * This function is a front-end to parse_que() that takes an attribute,
  * removes ^....: or $....: from its value, and queues what's left.
  * \param executor object containing the attribute.
  * \param atrname attribute name.
@@ -498,10 +500,10 @@
 do_second(void)
 {
   BQUE *trail = NULL, *point, *next;
-  /* move contents of low priority queue onto end of normal one 
-   * this helps to keep objects from getting out of control since 
-   * its effects on other objects happen only after one second 
-   * this should allow @halt to be typed before getting blown away 
+  /* move contents of low priority queue onto end of normal one
+   * this helps to keep objects from getting out of control since
+   * its effects on other objects happen only after one second
+   * this should allow @halt to be typed before getting blown away
    * by scrolling text.
    */
   if (qlfirst) {
@@ -832,7 +834,7 @@
   thing = noisy_match_result(player, arg_left, NOTYPE, MAT_EVERYTHING);
   if (!GoodObject(thing))
     return;
-  /* must control something or have it link_ok in order to use it as 
+  /* must control something or have it link_ok in order to use it as
    * as a semaphore.
    */
   if ((!controls(player, thing) && !LinkOk(thing))
@@ -1019,7 +1021,7 @@
     int offset = parse_integer(timestr);
 
     /* If timestr looks like +NNN or -NNN, add or subtract a number
-       of seconds to the current timeout. Otherwise, change timeout. 
+       of seconds to the current timeout. Otherwise, change timeout.
      */
     if (timestr[0] == '+' || timestr[0] == '-')
       q->left += offset;
@@ -1067,7 +1069,8 @@
     }
   }
 
-  notify_format(player, T("Queue entry with pid %u updated."), pid);
+  notify_format(player, T("Queue entry with pid %u updated."),
+                (unsigned int) pid);
 }
 
 FUNCTION(fun_pidinfo)
@@ -1246,25 +1249,25 @@
           continue;
         switch (q_type) {
         case 1:                /* wait queue */
-          notify_format(player, "(Pid: %u) [%ld]%s: %s", tmp->pid,
-                        (long) difftime(tmp->left, mudtime),
+          notify_format(player, "(Pid: %u) [%ld]%s: %s",
+                        (unsigned int) tmp->pid, (long) difftime(tmp->left,
+                                                                 mudtime),
                         unparse_object(player, tmp->player), tmp->comm);
           break;
         case 2:                /* semaphore queue */
           if (tmp->left != 0) {
-            notify_format(player, "(Pid: %u) [#%d/%s/%ld]%s: %s", tmp->pid,
-                          tmp->sem, tmp->semattr, (long) difftime(tmp->left,
-                                                                  mudtime),
+            notify_format(player, "(Pid: %u) [#%d/%s/%ld]%s: %s",
+                          (unsigned int) tmp->pid, tmp->sem, tmp->semattr,
+                          (long) difftime(tmp->left, mudtime),
                           unparse_object(player, tmp->player), tmp->comm);
           } else {
-            notify_format(player, "(Pid: %u) [#%d/%s]%s: %s", tmp->pid,
-                          tmp->sem, tmp->semattr, unparse_object(player,
-                                                                 tmp->player),
-                          tmp->comm);
+            notify_format(player, "(Pid: %u) [#%d/%s]%s: %s",
+                          (unsigned int) tmp->pid, tmp->sem, tmp->semattr,
+                          unparse_object(player, tmp->player), tmp->comm);
           }
           break;
         default:               /* player or object queue */
-          notify_format(player, "(Pid: %u) %s: %s", tmp->pid,
+          notify_format(player, "(Pid: %u) %s: %s", (unsigned int) tmp->pid,
                         unparse_object(player, tmp->player), tmp->comm);
         }
       }
@@ -1528,7 +1531,8 @@
     free_qentry(q);
   }
 
-  notify_format(player, T("Queue entry with pid %u halted."), pid);
+  notify_format(player, T("Queue entry with pid %u halted."),
+                (unsigned int) pid);
 }
 
 
@@ -1647,7 +1651,7 @@
   }
 }
 
-/** Dequeue all queue entries, refunding deposits. 
+/** Dequeue all queue entries, refunding deposits.
  * This function dequeues all entries in all queues, without executing
  * them and refunds queue deposits. It's called at shutdown.
  */
Index: BUGS
===================================================================
--- BUGS	(.../183p10)	(revision 142)
+++ BUGS	(.../183p11)	(revision 142)
@@ -25,6 +25,14 @@
    
   Then do a full @shutdown of the game and run restart.
 
+* The configure script sometimes detects functions that aren't seen
+  when the mush itself is compiled. Some linux distributions seem to
+  be very prone to this, probably due to customizations of their glibc
+  packages. For now, just comment out the relevant HAVE_FOO lines from
+  config.h. You'll have to redo this every time you re-run
+  configure. If you can figure out how to make the relevant prototypes
+  and macros visible to Penn, let us know! Some functions known to
+  cause this include posix_fadvise() and posix_fallocate().
 
 You can browse the bug and suggestion database at
 http://code.google.com/p/pennmush/issues/list to see more.
Index: game/txt/hlp/pennchat.hlp
===================================================================
--- game/txt/hlp/pennchat.hlp	(.../183p10)	(revision 142)
+++ game/txt/hlp/pennchat.hlp	(.../183p11)	(revision 142)
@@ -443,10 +443,13 @@
 
   This function is only usable by objects that pass the channel's @clock/mod.
 & CWHO()
-  cwho(<channel>)
+  cwho(<channel>[, <status>])
  
-  This returns a list of connected dbrefs who are on <channel>. 
-  When used by mortals, hidden/DARK players do not appear on the list.
+  This function returns the dbrefs of objects which are on <channel>.
+  <status> can be one of "on", "off" or "all" to control whether
+  online players, offline players, or all players are returned; it
+  defaults to "on". (Things are always returned.) When used by mortals,
+  hidden/dark players are shown as being offline.
 & CEMIT()
   cemit(<channel>, <message>[, <noisy>])
 
Index: game/txt/hlp/index.hlp
===================================================================
--- game/txt/hlp/index.hlp	(.../183p10)	(revision 142)
+++ game/txt/hlp/index.hlp	(.../183p11)	(revision 142)
@@ -1,655 +1,658 @@
 
 & Entries
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- "                         #lambda                   $-commands               
- $-commands2               %                         %!                       
- %#                        %2                        %3                       
- %4                        %:                        %a                       
- %i                        %n                        %o                       
- %p                        %s                        %~                       
- +                         1.50p6                    1.50p7                   
- 1.50p8                    1.50p9                    1.50p10                  
- 1.50p11                   1.50p12                   1.50p13                  
- 1.50p14                   1.50pdune1                1.50pdune2               
- 1.6.0p0                   1.6.0p3                   1.6.0p4                  
- 1.6.0p5                   1.6.1p0                   1.6.1p1                  
- 1.6.10p0                  1.6.10p1                  1.6.10p2                 
- 1.6.10p3                  1.6.10p4                  1.6.10p5                 
- 1.6.10p6                  1.6.2p0                   1.6.2p1                  
- 1.6.3p0                   1.6.3p1                   1.6.3p2                  
+ `                         ^                         ;                        
+ :                         "                         ]                        
+ @@                        @@()                      \                        
+ %                         %~                        %:                       
+ %!                        %#                        +                        
+ 1.50p6                    1.50p7                    1.50p8                   
+ 1.50p9                    1.50p10                   1.50p11                  
+ 1.50p12                   1.50p13                   1.50p14                  
+ 1.50pdune1                1.50pdune2                1.6.0p0                  
+ 1.6.0p3                   1.6.0p4                   1.6.0p5                  
+ 1.6.1p0                   1.6.1p1                   1.6.10p0                 
+ 1.6.10p1                  1.6.10p2                  1.6.10p3                 
+ 1.6.10p4                  1.6.10p5                  1.6.10p6                 
+ 1.6.2p0                   1.6.2p1                   1.6.3p0                  
+ 1.6.3p1                   1.6.3p2                   1.6.3p3                  
+ 1.6.3p4                   1.6.3p5                   1.6.3p6                  
 
 For more, see Entries-2
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-2
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- 1.6.3p3                   1.6.3p4                   1.6.3p5                  
- 1.6.3p6                   1.6.3p7                   1.6.4p0                  
- 1.6.4p1                   1.6.4p2                   1.6.5p0                  
- 1.6.5p1                   1.6.5p2                   1.6.5p3                  
- 1.6.5p4                   1.6.6p0                   1.6.7p0                  
- 1.6.7p1                   1.6.7p2                   1.6.7p3                  
- 1.6.7p4                   1.6.7p5                   1.6.7p6                  
- 1.6.8p0                   1.6.8p1                   1.6.9p0                  
- 1.6.9p1                   1.6.9p2                   1.6.9p3                  
- 1.6.9p4                   1.6.9p5                   1.6.9p6                  
- 1.6.9p7                   1.6.9p8                   1.6.9p9                  
- 1.7.0p0                   1.7.0p1                   1.7.0p2                  
- 1.7.0p3                   1.7.0p4                   1.7.0p5                  
- 1.7.0p6                   1.7.0p7                   1.7.0p8                  
- 1.7.0p9                   1.7.0p10                  1.7.0p11                 
- 1.7.1p0                   1.7.1p1                   1.7.1p2                  
+ 1.6.3p7                   1.6.4p0                   1.6.4p1                  
+ 1.6.4p2                   1.6.5p0                   1.6.5p1                  
+ 1.6.5p2                   1.6.5p3                   1.6.5p4                  
+ 1.6.6p0                   1.6.7p0                   1.6.7p1                  
+ 1.6.7p2                   1.6.7p3                   1.6.7p4                  
+ 1.6.7p5                   1.6.7p6                   1.6.8p0                  
+ 1.6.8p1                   1.6.9p0                   1.6.9p1                  
+ 1.6.9p2                   1.6.9p3                   1.6.9p4                  
+ 1.6.9p5                   1.6.9p6                   1.6.9p7                  
+ 1.6.9p8                   1.6.9p9                   1.7.0p0                  
+ 1.7.0p1                   1.7.0p2                   1.7.0p3                  
+ 1.7.0p4                   1.7.0p5                   1.7.0p6                  
+ 1.7.0p7                   1.7.0p8                   1.7.0p9                  
+ 1.7.0p10                  1.7.0p11                  1.7.1p0                  
+ 1.7.1p1                   1.7.1p2                   1.7.1p3                  
+ 1.7.2p0                   1.7.2p1                   1.7.2p2                  
 
 For more, see Entries-3
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-3
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- 1.7.1p3                   1.7.2p0                   1.7.2p1                  
- 1.7.2p2                   1.7.2p3                   1.7.2p4                  
- 1.7.2p5                   1.7.2p6                   1.7.2p7                  
- 1.7.2p8                   1.7.2p9                   1.7.2p10                 
- 1.7.2p11                  1.7.2p12                  1.7.2p13                 
- 1.7.2p14                  1.7.2p15                  1.7.2p16                 
- 1.7.2p17                  1.7.2p18                  1.7.2p19                 
- 1.7.2p20                  1.7.2p21                  1.7.2p22                 
- 1.7.2p23                  1.7.2p24                  1.7.2p25                 
- 1.7.2p26                  1.7.2p27                  1.7.2p28                 
- 1.7.2p29                  1.7.2p30                  1.7.2p31                 
- 1.7.2p32                  1.7.2p33                  1.7.2p34                 
- 1.7.2p35                  1.7.3p0                   1.7.3p1                  
- 1.7.3p2                   1.7.3p3                   1.7.3p4                  
- 1.7.3p5                   1.7.3p6                   1.7.3p7                  
- 1.7.3p8                   1.7.3p9                   1.7.3p10                 
+ 1.7.2p3                   1.7.2p4                   1.7.2p5                  
+ 1.7.2p6                   1.7.2p7                   1.7.2p8                  
+ 1.7.2p9                   1.7.2p10                  1.7.2p11                 
+ 1.7.2p12                  1.7.2p13                  1.7.2p14                 
+ 1.7.2p15                  1.7.2p16                  1.7.2p17                 
+ 1.7.2p18                  1.7.2p19                  1.7.2p20                 
+ 1.7.2p21                  1.7.2p22                  1.7.2p23                 
+ 1.7.2p24                  1.7.2p25                  1.7.2p26                 
+ 1.7.2p27                  1.7.2p28                  1.7.2p29                 
+ 1.7.2p30                  1.7.2p31                  1.7.2p32                 
+ 1.7.2p33                  1.7.2p34                  1.7.2p35                 
+ 1.7.3p0                   1.7.3p1                   1.7.3p2                  
+ 1.7.3p3                   1.7.3p4                   1.7.3p5                  
+ 1.7.3p6                   1.7.3p7                   1.7.3p8                  
+ 1.7.3p9                   1.7.3p10                  1.7.3p11                 
+ 1.7.3p12                  1.7.3p13                  1.7.3p14                 
 
 For more, see Entries-4
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-4
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- 1.7.3p11                  1.7.3p12                  1.7.3p13                 
- 1.7.3p14                  1.7.4p0                   1.7.4p1                  
- 1.7.4p2                   1.7.4p3                   1.7.4p4                  
- 1.7.4p5                   1.7.4p6                   1.7.4p7                  
- 1.7.4p8                   1.7.4p9                   1.7.4p10                 
- 1.7.4p11                  1.7.4p12                  1.7.4p13                 
- 1.7.4p14                  1.7.4p15                  1.7.4p16                 
- 1.7.4p17                  1.7.4p18                  1.7.4p19                 
- 1.7.4p20                  1.7.5p0                   1.7.5p1                  
- 1.7.5p2                   1.7.5p3                   1.7.5p4                  
- 1.7.5p5                   1.7.5p6                   1.7.5p7                  
- 1.7.5p8                   1.7.5p9                   1.7.5p10                 
- 1.7.5p11                  1.7.5p12                  1.7.6p0                  
- 1.7.6p1                   1.7.6p2                   1.7.6p3                  
- 1.7.6p4                   1.7.6p5                   1.7.6p6                  
- 1.7.6p7                   1.7.6p8                   1.7.6p9                  
+ 1.7.4p0                   1.7.4p1                   1.7.4p2                  
+ 1.7.4p3                   1.7.4p4                   1.7.4p5                  
+ 1.7.4p6                   1.7.4p7                   1.7.4p8                  
+ 1.7.4p9                   1.7.4p10                  1.7.4p11                 
+ 1.7.4p12                  1.7.4p13                  1.7.4p14                 
+ 1.7.4p15                  1.7.4p16                  1.7.4p17                 
+ 1.7.4p18                  1.7.4p19                  1.7.4p20                 
+ 1.7.5p0                   1.7.5p1                   1.7.5p2                  
+ 1.7.5p3                   1.7.5p4                   1.7.5p5                  
+ 1.7.5p6                   1.7.5p7                   1.7.5p8                  
+ 1.7.5p9                   1.7.5p10                  1.7.5p11                 
+ 1.7.5p12                  1.7.6p0                   1.7.6p1                  
+ 1.7.6p2                   1.7.6p3                   1.7.6p4                  
+ 1.7.6p5                   1.7.6p6                   1.7.6p7                  
+ 1.7.6p8                   1.7.6p9                   1.7.6p10                 
+ 1.7.6p11                  1.7.6p12                  1.7.6p13                 
 
 For more, see Entries-5
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-5
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- 1.7.6p10                  1.7.6p11                  1.7.6p12                 
- 1.7.6p13                  1.7.6p14                  1.7.6p15                 
- 1.7.6p16                  1.7.7p0                   1.7.7p1                  
- 1.7.7p2                   1.7.7p3                   1.7.7p4                  
- 1.7.7p5                   1.7.7p6                   1.7.7p7                  
- 1.7.7p8                   1.7.7p9                   1.7.7p10                 
- 1.7.7p11                  1.7.7p12                  1.7.7p13                 
- 1.7.7p14                  1.7.7p15                  1.7.7p16                 
- 1.7.7p17                  1.7.7p18                  1.7.7p19                 
- 1.7.7p20                  1.7.7p21                  1.7.7p22                 
- 1.7.7p23                  1.7.7p24                  1.7.7p25                 
- 1.7.7p26                  1.7.7p27                  1.7.7p28                 
- 1.7.7p29                  1.7.7p30                  1.7.7p31                 
- 1.7.7p32                  1.7.7p33                  1.7.7p34                 
- 1.7.7p35                  1.7.7p36                  1.7.7p37                 
- 1.7.7p38                  1.7.7p39                  1.7.7p40                 
+ 1.7.6p14                  1.7.6p15                  1.7.6p16                 
+ 1.7.7p0                   1.7.7p1                   1.7.7p2                  
+ 1.7.7p3                   1.7.7p4                   1.7.7p5                  
+ 1.7.7p6                   1.7.7p7                   1.7.7p8                  
+ 1.7.7p9                   1.7.7p10                  1.7.7p11                 
+ 1.7.7p12                  1.7.7p13                  1.7.7p14                 
+ 1.7.7p15                  1.7.7p16                  1.7.7p17                 
+ 1.7.7p18                  1.7.7p19                  1.7.7p20                 
+ 1.7.7p21                  1.7.7p22                  1.7.7p23                 
+ 1.7.7p24                  1.7.7p25                  1.7.7p26                 
+ 1.7.7p27                  1.7.7p28                  1.7.7p29                 
+ 1.7.7p30                  1.7.7p31                  1.7.7p32                 
+ 1.7.7p33                  1.7.7p34                  1.7.7p35                 
+ 1.7.7p36                  1.7.7p37                  1.7.7p38                 
+ 1.7.7p39                  1.7.7p40                  1.8.0p0                  
+ 1.8.0p1                   1.8.0p2                   1.8.0p3                  
 
 For more, see Entries-6
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-6
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- 1.8.0p0                   1.8.0p1                   1.8.0p2                  
- 1.8.0p3                   1.8.0p4                   1.8.0p5                  
- 1.8.0p6                   1.8.0p7                   1.8.0p8                  
- 1.8.0p9                   1.8.0p10                  1.8.0p11                 
- 1.8.0p12                  1.8.0p13                  1.8.1p0                  
- 1.8.1p1                   1.8.1p2                   1.8.1p3                  
- 1.8.1p4                   1.8.1p5                   1.8.1p6                  
- 1.8.1p7                   1.8.1p8                   1.8.1p9                  
- 1.8.1p10                  1.8.2p0                   1.8.2p1                  
- 1.8.2p2                   1.8.2p3                   1.8.2p4                  
- 1.8.2p5                   1.8.2p6                   1.8.2p7                  
- 1.8.2p8                   1.8.3p0                   1.8.3p1                  
- 1.8.3p2                   1.8.3p3                   1.8.3p4                  
- 1.8.3p5                   1.8.3p6                   1.8.3p7                  
- 1.8.3p8                   1.8.3p9                   1.8.3p10                 
- :                         ;                         @-attributes             
+ 1.8.0p4                   1.8.0p5                   1.8.0p6                  
+ 1.8.0p7                   1.8.0p8                   1.8.0p9                  
+ 1.8.0p10                  1.8.0p11                  1.8.0p12                 
+ 1.8.0p13                  1.8.1p0                   1.8.1p1                  
+ 1.8.1p2                   1.8.1p3                   1.8.1p4                  
+ 1.8.1p5                   1.8.1p6                   1.8.1p7                  
+ 1.8.1p8                   1.8.1p9                   1.8.1p10                 
+ 1.8.2p0                   1.8.2p1                   1.8.2p2                  
+ 1.8.2p3                   1.8.2p4                   1.8.2p5                  
+ 1.8.2p6                   1.8.2p7                   1.8.2p8                  
+ 1.8.3p0                   1.8.3p1                   1.8.3p2                  
+ 1.8.3p3                   1.8.3p4                   1.8.3p5                  
+ 1.8.3p6                   1.8.3p7                   1.8.3p8                  
+ 1.8.3p9                   1.8.3p10                  1.8.3p11                 
+ `2                        %2                        `3                       
+ %3                        `4                        %4                       
 
 For more, see Entries-7
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-7
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- @-building                @-general                 @-wizard                 
- @@                        @@()                      @aahear                  
- @abuy                     @aclone                   @aconnect                
- @adeath                   @adescribe                @adestroy                
- @adisconnect              @adrop                    @aefail                  
- @aenter                   @afailure                 @afollow                 
- @agive                    @ahear                    @aidescribe              
+ %a                        @aahear                   abode                    
+ abs()                     @abuy                     accent()                 
+ accent2                   accent3                   accent4                  
+ accname()                 @aclone                   @aconnect                
+ acos()                    action2                   action lists             
+ add()                     @adeath                   @adescribe               
+ @adestroy                 @adisconnect              @adrop                   
+ @aefail                   @aenter                   @afailure                
+ @afollow                  after()                   @agive                   
+ @ahear                    ahelp                     @aidescribe              
  @aleave                   @alfail                   @alias                   
- @allhalt                  @allquota                 @amhear                  
- @amove                    @apayment                 @areceive                
- @assert                   @asuccess                 @atport                  
- @atrchown                 @atrlock                  @attribute               
- @aufail                   @aunfollow                @ause                    
- @away                     @azenter                  @azleave                 
- @boot                     @break                    @buy                     
- @cemit                    @channel                  @channel2                
+ alias()                   align()                   align2                   
+ @allhalt                  allof()                   @allquota                
+ alphamax()                alphamin()                @amhear                  
+ @amove                    ancestors                 and()                    
+ andflags()                andlflags()               andlpowers()             
 
 For more, see Entries-8
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-8
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- @channel3                 @channel4                 @channel5                
- @channel6                 @charges                  @chat                    
- @chat mogrifying          @chat mogrifying2         @chat mogrifying3        
- @chatformat               @chatformat2              @chatformat3             
- @chown                    @chownall                 @chzone                  
- @chzone2                  @chzoneall                @clock                   
- @clock2                   @clone                    @command                 
- @command2                 @command3                 @comment                 
- @config                   @config attribs           @config chat             
- @config cmds              @config cosmetic          @config cosmetic2        
- @config costs             @config db                @config dump             
- @config flags             @config funcs             @config limits           
- @config limits2           @config limits3           @config limits4          
- @config log               @config net               @config parameters       
- @config tiny              @conformat                @cost                    
- @cpattr                   @create                   @dbck                    
+ anews                     angles                    anonymous2               
+ anonymous3                anonymous4                anonymous attributes     
+ ansi                      ansi()                    @apayment                
+ aposs()                   @areceive                 art()                    
+ asin()                    @assert                   @asuccess                
+ atan()                    atan2()                   @atport                  
+ @atrchown                 @atrlock                  atrlock()                
+ attrcnt()                 attrib-ownership          attrib_set()             
+ attrib trees              attrib trees2             attrib trees3            
+ attrib trees4             @attribute                attribute flags          
+ attribute flags2          attribute flags3          attribute functions      
+ attribute list            @-attributes              attributes               
+ attributes2               attributes3               attributes4              
+ attributes list           attribute trees           attribute trees2         
+ attribute trees3          attribute trees4          attrpcnt()               
+ attr trees                attr trees2               attr trees3              
 
 For more, see Entries-9
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-9
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- @death                    @debugforwardlist         @decompile               
- @decompile2               @decompile3               @desc                    
- @descformat               @describe                 @destroy                 
- @destroy2                 @dig                      @dig2                    
- @disable                  @doing                    @dolist                  
- @drain                    @drop                     @dump                    
- @ealias                   @edit                     @efail                   
- @elock                    @emit                     @enable                  
- @enter                    @entrances                @eunlock                 
- @exitformat               @failure                  @filter                  
- @filter2                  @find                     @firstexit               
- @flag                     @flag2                    @follow                  
- @force                    @force2                   @forwardlist             
- @function                 @function2                @function3               
- @function4                @gedit                    @give                    
- @grep2                    @grep                     @halt                    
+ attr trees4               audible                   audible2                 
+ @aufail                   @aunfollow                @ause                    
+ @away                     @azenter                  @azleave                 
+ band()                    baseconv()                beep()                   
+ before()                  being killed              bitwise functions        
+ bnand()                   bnot()                    boolean2                 
+ boolean3                  boolean functions         boolean values           
+ @boot                     bor()                     bound()                  
+ brackets()                @break                    brief                    
+ builder                   @-building                @buy                     
+ buy                       bxor()                    cand()                   
+ capstr()                  case()                    caseall()                
+ cat()                     cbuffer()                 cbufferadd()             
+ cd                        cdesc()                   ceil()                   
+ @cemit                    cemit()                   center()                 
+ cflags()                  ch                        changes                  
 
 For more, see Entries-10
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-10
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- @haven                    @hide                     @hook                    
- @hook2                    @idescformat              @idescribe               
- @idle                     @infilter                 @inprefix                
- @invformat                @kick                     @lalias                  
- @leave                    @lemit                    @lfail                   
- @link                     @list                     @listen                  
- @listen2                  @listmotd                 @lock                    
- @lock10                   @lock2                    @lock3                   
- @lock4                    @lock5                    @lock6                   
- @lock7                    @lock8                    @lock9                   
- @log                      @logwipe                  @lset                    
- @map2                     @mail                     @mailfilter              
- @mailforwardlist          @malias                   @malias2                 
- @malias3                  @malias4                  @malias5                 
- @map                      @message                  @motd                    
- @move                     @mvattr                   @name                    
+ @channel                  @channel2                 @channel3                
+ @channel4                 @channel5                 @channel6                
+ channel functions         channel-list              channels()               
+ chan_usefirstmatch        @charges                  @chat                    
+ chat                      @chatformat               @chatformat2             
+ @chatformat3              @chat mogrifying          @chat mogrifying2        
+ @chat mogrifying3         checkpass()               children()               
+ @chown                    @chownall                 chown_ok                 
+ chr()                     @chzone                   @chzone2                 
+ @chzoneall                clflags()                 clients                  
+ @clock                    clock()                   @clock2                  
+ @clone                    clone()                   cloudy                   
+ cmds()                    cmsgs()                   code                     
+ color                     @command                  @command2                
+ @command3                 $-commands                commands                 
+ $-commands2               @comment                  communication functions  
 
 For more, see Entries-11
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-11
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- @nameaccent               @nameformat               @newpassword             
- @notify                   @nscemit                  @nsemit                  
- @nslemit                  @nsoemit                  @nspemit                 
- @nsprompt                 @nsremit                  @nszemit                 
- @nuke                     @obuy                     @odeath                  
- @odescribe                @odrop                    @oefail                  
- @oemit                    @oenter                   @ofailure                
- @ofollow                  @ogive                    @oidescribe              
- @oleave                   @olfail                   @omove                   
- @opayment                 @open                     @oreceive                
- @osuccess                 @otport                   @oufail                  
- @ounfollow                @ouse                     @oxenter                 
- @oxleave                  @oxmove                   @oxtport                 
- @ozenter                  @ozleave                  @pageformat              
- @parent                   @password                 @payment                 
- @pcreate                  @pemit                    @pemit2                  
+ comp()                    comsys                    con()                    
+ cond()                    condall()                 @config                  
+ config()                  @config attribs           @config chat             
+ @config cmds              @config cosmetic          @config cosmetic2        
+ @config costs             @config db                @config dump             
+ @config flags             @config funcs             @config limits           
+ @config limits2           @config limits3           @config limits4          
+ @config log               @config net               @config parameters       
+ @config tiny              @conformat                conn()                   
+ connected                 connection functions      contact                  
+ control                   controls()                convsecs()               
+ convtime()                convutcsecs()             copyright                
+ copyrite                  cor()                     cos()                    
+ @cost                     costs                     cowner()                 
+ @cpattr                   @create                   create()                 
+ crecall()                 credits                   csecs()                  
 
 For more, see Entries-12
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-12
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- @poll                     @poor                     @power                   
- @power2                   @power3                   @prefix                  
- @pricelist                @prompt                   @ps                      
- @purge                    @quota                    @readcache               
- @receive                  @recycle                  @rejectmotd              
- @remit                    @restart                  @runout                  
- @rwall                    @scan                     @search                  
- @search2                  @search3                  @search4                 
- @search5                  @select                   @set                     
- @sex                      @shutdown                 @sitelock                
- @sitelock2                @sitelock3                @sql                     
- @squota                   @startup                  @stats                   
- @success                  @sweep                    @switch                  
- @switch2                  @teleport                 @tport                   
- @trigger                  @trigger2                 @ufail                   
- @ulock                    @undestroy                @unfollow                
+ cstatus()                 ctime()                   ctitle()                 
+ ctu()                     cusers()                  cv                       
+ cwho()                    dark                      dark2                    
+ database                  @dbck                     dbref #                  
+ dbref2                    dbref functions           dbref number             
+ dbrefs                    @death                    debug                    
+ debug2                    @debugforwardlist         debugforwardlist         
+ dec()                     decode64()                @decompile               
+ @decompile2               @decompile3               decompose()              
+ decrypt()                 default()                 delete()                 
+ @desc                     @descformat               @describe                
+ desert                    @destroy                  @destroy2                
+ destroy_ok                die()                     @dig                     
+ dig()                     @dig2                     digest()                 
+ @disable                  dismiss                   dist2d()                 
+ dist3d()                  div()                     @doing                   
 
 For more, see Entries-13
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-13
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- @unlink                   @unlock                   @unrecycle               
- @uptime                   @uptime2                  @use                     
- @uunlock                  @verb                     @verb2                   
- @verb3                    @verb4                    @version                 
- @vrml_url                 @wait                     @wait2                   
- @wait3                    @wall                     @warnings                
- @warnings2                @warnings3                @wcheck                  
- @whereis                  @wipe                     @wizmotd                 
- @wizwall                  @zemit                    @zenter                  
- @zleave                   \                         ]                        
- ^                         `                         `2                       
- `3                        `4                        abode                    
- abs()                     accent()                  accent2                  
- accent3                   accent4                   accname()                
- acos()                    action lists              action2                  
- add()                     after()                   ahelp                    
+ doing                     doing()                   @dolist                  
+ download                  @drain                    @drop                    
+ drop                      drop-tos                  @dump                    
+ dynhelp()                 e()                       @ealias                  
+ edefault()                @edit                     edit()                   
+ @efail                    element()                 elements()               
+ elist()                   @elock                    elock()                  
+ @emit                     emit()                    empty                    
+ @enable                   enactor                   encode64()               
+ encrypt()                 endtag()                  @enter                   
+ enter                     enter_ok                  @entrances               
+ entrances()               eq()                      escape()                 
+ etimefmt()                etimefmt2                 etimefmt3                
+ @eunlock                  eval()                    evaluation2              
+ evaluation order          events                    examine                  
+ executor                  exit()                    @exitformat              
 
 For more, see Entries-14
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-14
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- alias()                   align()                   align2                   
- allof()                   alphamax()                alphamin()               
- ancestors                 and()                     andflags()               
- andlflags()               andlpowers()              anews                    
- anonymous attributes      anonymous2                anonymous3               
- anonymous4                ansi                      ansi()                   
- aposs()                   art()                     asin()                   
- atan()                    atan2()                   atrlock()                
- attr trees                attr trees2               attr trees3              
- attr trees4               attrcnt()                 attrib trees             
- attrib trees2             attrib trees3             attrib trees4            
- attrib-ownership          attrib_set()              attribute flags          
- attribute flags2          attribute flags3          attribute functions      
- attribute list            attribute trees           attribute trees2         
- attribute trees3          attribute trees4          attributes               
- attributes list           attributes2               attributes3              
+ exits                     exits2                    exp()                    
+ extract()                 @failure                  failure                  
+ fdiv()                    @filter                   filter()                 
+ @filter2                  filterbool()              @find                    
+ findable()                first()                   @firstexit               
+ firstof()                 fixed                     @flag                    
+ @flag2                    flag list                 flag permissions         
+ flags                     flags()                   flags2                   
+ flags list                flip()                    floating                 
+ floor()                   floordiv()                fmod()                   
+ fn()                      fold()                    fold2                    
+ folderstats()             @follow                   follow                   
+ followers()               following()               @force                   
+ @force2                   foreach()                 foreach2                 
+ @forwardlist              fraction()                fullalias()              
+ fullname()                @function                 @function2               
 
 For more, see Entries-15
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-15
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- attributes4               attrpcnt()                audible                  
- audible2                  band()                    baseconv()               
- beep()                    before()                  being killed             
- bitwise functions         bnand()                   bnot()                   
- boolean functions         boolean values            boolean2                 
- boolean3                  bor()                     bound()                  
- brackets()                brief                     builder                  
- buy                       bxor()                    cand()                   
- capstr()                  case()                    caseall()                
- cat()                     cbuffer()                 cbufferadd()             
- cd                        cdesc()                   ceil()                   
- cemit()                   center()                  cflags()                 
- ch                        chan_usefirstmatch        changes                  
- channel functions         channel-list              channels()               
- chat                      checkpass()               children()               
- chown_ok                  chr()                     clflags()                
+ @function3                @function4                function list            
+ functions                 functions()               functions2               
+ gagged                    @gedit                    gender                   
+ @-general                 get                       get()                    
+ get_eval()                getpids()                 @give                    
+ give                      global commands           globals                  
+ go                        going                     goto                     
+ grab()                    graball()                 @grep2                   
+ @grep                     grep()                    grepi()                  
+ gt()                      gte()                     @halt                    
+ halt                      hasattr()                 hasattrp()               
+ hasattrpval()             hasattrval()              hasflag()                
+ haspower()                hastype()                 @haven                   
+ haven                     hear_connect              heavy                    
+ height()                  help                      here                     
+ hidden()                  @hide                     home                     
 
 For more, see Entries-16
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-16
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- clients                   clock()                   clone()                  
- cloudy                    cmds()                    cmsgs()                  
- code                      color                     commands                 
- communication functions   comp()                    comsys                   
- con()                     cond()                    condall()                
- config()                  conn()                    connected                
- connection functions      contact                   control                  
- controls()                convsecs()                convtime()               
- convutcsecs()             copyright                 copyrite                 
- cor()                     cos()                     costs                    
- cowner()                  create()                  crecall()                
- credits                   csecs()                   cstatus()                
- ctime()                   ctitle()                  ctu()                    
- cusers()                  cv                        cwho()                   
- dark                      dark2                     database                 
- dbref #                   dbref functions           dbref number             
+ home()                    homes                     @hook                    
+ @hook2                    host()                    hostname()               
+ html                      html()                    html functions           
+ %i                        i18n                      @idescformat             
+ @idescribe                @idle                     idle                     
+ idle()                    idlesecs()                if()                     
+ ifelse()                  ilev()                    iname()                  
+ inc()                     index                     index()                  
+ @infilter                 info                      information functions    
+ inherit                   inherit2                  @inprefix                
+ insert()                  interiors                 interiors2               
+ internationalization      inum()                    inventory                
+ @invformat                ipaddr()                  isdaylight()             
+ isdbref()                 isint()                   isnum()                  
+ isobjid()                 isword()                  itemize()                
+ items()                   iter()                    iter2                    
 
 For more, see Entries-17
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-17
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- dbref2                    dbrefs                    debug                    
- debug2                    debugforwardlist          dec()                    
- decode64()                decompose()               decrypt()                
- default()                 delete()                  desert                   
- destroy_ok                die()                     dig()                    
- digest()                  dismiss                   dist2d()                 
- dist3d()                  div()                     doing                    
- doing()                   download                  drop                     
- drop-tos                  dynhelp()                 e()                      
- edefault()                edit()                    element()                
- elements()                elist()                   elock()                  
- emit()                    empty                     enactor                  
- encode64()                encrypt()                 endtag()                 
- enter                     enter_ok                  entrances()              
- eq()                      escape()                  etimefmt()               
- etimefmt2                 etimefmt3                 eval()                   
+ itext()                   judge                     jump_ok                  
+ jury_ok                   keepalive                 @kick                    
+ kill                      @lalias                   lalign()                 
+ #lambda                   lambda                    last                     
+ last()                    lastip                    last & lastlogout        
+ lastlogout                lastsite                  lattr()                  
+ lattrp()                  lcon()                    lcstr()                  
+ ldelete()                 @leave                    leave                    
+ left()                    @lemit                    lemit()                  
+ letq()                    lexits()                  @lfail                   
+ lflags()                  license                   light                    
+ @link                     link()                    linking                  
+ link_ok                   @list                     list()                   
+ @listen                   @listen2                  listening                
+ listening2                listening3                listen_parent            
+ list functions            @listmotd                 lists                    
 
 For more, see Entries-18
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-18
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- evaluation order          evaluation2               events                   
- examine                   executor                  exit()                   
- exits                     exits2                    exp()                    
- extract()                 failure                   fdiv()                   
- filter()                  filterbool()              findable()               
- first()                   firstof()                 fixed                    
- flag list                 flag permissions          flags                    
- flags list                flags()                   flags2                   
- flip()                    floating                  floor()                  
- floordiv()                fmod()                    fn()                     
- fold()                    fold2                     folderstats()            
- follow                    followers()               following()              
- foreach()                 foreach2                  fraction()               
- fullalias()               fullname()                function list            
- functions                 functions()               functions2               
- gagged                    gender                    get                      
+ lit()                     ljust()                   llockflags()             
+ llocks()                  lmath()                   ln()                     
+ lnum()                    loc()                     locale                   
+ localize()                locate()                  locate2                  
+ @lock                     lock()                    @lock10                  
+ @lock2                    @lock3                    @lock4                   
+ @lock5                    @lock6                    @lock7                   
+ @lock8                    @lock9                    lockflags()              
+ locking                   lock list                 locklist                 
+ lockowner()               locks                     locks()                  
+ lock types                locktypes                 lock types2              
+ locktypes2                @log                      log()                    
+ logout                    @logwipe                  look                     
+ look2                     looping                   loud                     
+ lparent()                 lpids()                   lplayers()               
+ lports()                  lpos()                    lsearch()                
 
 For more, see Entries-19
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-19
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- get()                     get_eval()                getpids()                
- give                      global commands           globals                  
- go                        going                     goto                     
- grab()                    graball()                 grep()                   
- grepi()                   gt()                      gte()                    
- halt                      hasattr()                 hasattrp()               
- hasattrpval()             hasattrval()              hasflag()                
- haspower()                hastype()                 haven                    
- hear_connect              heavy                     height()                 
- here                      hidden()                  home                     
- home()                    homes                     host()                   
- hostname()                html                      html functions           
- html()                    i18n                      idle                     
- idle()                    idlesecs()                if()                     
- ifelse()                  ilev()                    iname()                  
- inc()                     index                     index()                  
+ lsearch2                  lsearchr()                @lset                    
+ lset()                    lstats()                  lt()                     
+ lte()                     lthings()                 lvcon()                  
+ lvexits()                 lvplayers()               lvthings()               
+ lwho()                    lwhoid()                  @map2                    
+ macros                    macros2                   @mail                    
+ mail                      mail()                    mail-admin               
+ maildstats()              @mailfilter               mailfilter               
+ mail-folders              mail-forward              @mailforwardlist         
+ mailfrom()                mailfstats()              mail functions           
+ mail-other                mail-reading              mailsend()               
+ mail-sending              mailstats()               mailstatus()             
+ mailsubject()             mailtime()                @malias                  
+ malias()                  @malias2                  @malias3                 
+ @malias4                  @malias5                  @map                     
+ map()                     mapsql()                  mapsql2                  
 
 For more, see Entries-20
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-20
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- info                      information functions     inherit                  
- inherit2                  insert()                  interiors                
- interiors2                internationalization      inum()                   
- inventory                 ipaddr()                  isdaylight()             
- isdbref()                 isint()                   isnum()                  
- isobjid()                 isword()                  itemize()                
- items()                   iter()                    iter2                    
- itext()                   judge                     jump_ok                  
- jury_ok                   keepalive                 kill                     
- lalign()                  lambda                    last                     
- last & lastlogout         last()                    lastip                   
- lastlogout                lastsite                  lattr()                  
- lattrp()                  lcon()                    lcstr()                  
- ldelete()                 leave                     left()                   
- lemit()                   letq()                    lexits()                 
- lflags()                  license                   light                    
+ master room               match()                   matchall()               
+ matching                  math functions            max()                    
+ me                        mean()                    median()                 
+ member()                  merge()                   @message                 
+ message()                 mid()                     min()                    
+ mistrust                  mix()                     mix2                     
+ mod()                     modulo()                  modulus()                
+ money                     money()                   monitor                  
+ @motd                     @move                     move                     
+ msecs()                   mtime()                   mudname()                
+ mul()                     munge()                   munge2                   
+ munge3                    mushcode                  mushcode2                
+ @mvattr                   mwho()                    mwhoid()                 
+ myopic                    %n                        @name                    
+ name()                    @nameaccent               @nameformat              
+ namegrab()                namegraball()             namelist()               
 
 For more, see Entries-21
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-21
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- link()                    link_ok                   linking                  
- list functions            list()                    listen_parent            
- listening                 listening2                listening3               
- lists                     lit()                     ljust()                  
- llockflags()              llocks()                  lmath()                  
- ln()                      lnum()                    loc()                    
- locale                    localize()                locate()                 
- locate2                   lock list                 lock types               
- lock types2               lock()                    lockflags()              
- locking                   locklist                  lockowner()              
- locks                     locks()                   locktypes                
- locktypes2                log()                     logout                   
- look                      look2                     looping                  
- loud                      lparent()                 lpids()                  
- lplayers()                lports()                  lpos()                   
- lsearch()                 lsearch2                  lsearchr()               
+ nand()                    nattr()                   nattrp()                 
+ nchildren()               ncon()                    ncond()                  
+ ncondall()                nearby()                  neq()                    
+ newbie                    newbie2                   newbie3                  
+ @newpassword              news                      nexits()                 
+ next()                    nextdbref()               nlsearch()               
+ nmwho()                   noaccents                 no_command               
+ no_leave                  noleave                   noname                   
+ non-standard attributes   nor()                     nospace                  
+ nospoof                   not()                     no_tel                   
+ @notify                   no_warn                   nowarn                   
+ nplayers()                @nscemit                  nsearch()                
+ @nsemit                   nsemit()                  @nslemit                 
+ nslemit()                 @nsoemit                  nsoemit()                
+ @nspemit                  nspemit()                 @nsprompt                
+ nsprompt()                @nsremit                  nsremit()                
 
 For more, see Entries-22
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-22
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- lset()                    lstats()                  lt()                     
- lte()                     lthings()                 lvcon()                  
- lvexits()                 lvplayers()               lvthings()               
- lwho()                    lwhoid()                  macros                   
- macros2                   mail                      mail functions           
- mail()                    mail-admin                mail-folders             
- mail-forward              mail-other                mail-reading             
- mail-sending              maildstats()              mailfilter               
- mailfrom()                mailfstats()              mailsend()               
- mailstats()               mailstatus()              mailsubject()            
- mailtime()                malias()                  map()                    
- mapsql()                  mapsql2                   master room              
- match()                   matchall()                matching                 
- math functions            max()                     me                       
- mean()                    median()                  member()                 
- merge()                   message()                 mid()                    
+ @nszemit                  nszemit()                 nthings()                
+ @nuke                     null()                    num()                    
+ numversion()              nvcon()                   nvexits()                
+ nvplayers()               nvthings()                nwho()                   
+ %o                        obj()                     object parents           
+ objeval()                 objid()                   objmem()                 
+ @obuy                     @odeath                   @odescribe               
+ @odrop                    @oefail                   @oemit                   
+ oemit()                   @oenter                   @ofailure                
+ @ofollow                  @ogive                    @oidescribe              
+ @oleave                   @olfail                   @omove                   
+ on-vacation               opaque                    @opayment                
+ @open                     open()                    or()                     
+ ord()                     ordinal()                 @oreceive                
+ orflags()                 orlflags()                orlpowers()              
+ orphan                    @osuccess                 @otport                  
 
 For more, see Entries-23
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-23
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- min()                     mistrust                  mix()                    
- mix2                      mod()                     modulo()                 
- modulus()                 money                     money()                  
- monitor                   move                      msecs()                  
- mtime()                   mudname()                 mul()                    
- munge()                   munge2                    munge3                   
- mushcode                  mushcode2                 mwho()                   
- mwhoid()                  myopic                    name()                   
- namegrab()                namegraball()             namelist()               
- nand()                    nattr()                   nattrp()                 
- nchildren()               ncon()                    ncond()                  
- ncondall()                nearby()                  neq()                    
- newbie                    newbie2                   newbie3                  
- news                      nexits()                  next()                   
- nextdbref()               nlsearch()                nmwho()                  
- no_command                no_leave                  no_tel                   
+ @oufail                   @ounfollow                @ouse                    
+ outputprefix              outputsuffix              owner()                  
+ @oxenter                  @oxleave                  @oxmove                  
+ @oxtport                  @ozenter                  @ozleave                 
+ %p                        page                      page2                    
+ @pageformat               paranoid                  @parent                  
+ parent                    parent()                  parents                  
+ parents2                  parents3                  parents4                 
+ parents5                  parse()                   @password                
+ patchlevels               @payment                  @pcreate                 
+ pcreate()                 @pemit                    pemit()                  
+ @pemit2                   pi()                      pickrand()               
+ pidinfo()                 player                    player()                 
+ playermem()               pmatch()                  @poll                    
+ poll()                    @poor                     ports()                  
+ pos()                     pose                      pose2                    
 
 For more, see Entries-24
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-24
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- no_warn                   noaccents                 noleave                  
- non-standard attributes   noname                    nor()                    
- nospace                   nospoof                   not()                    
- nowarn                    nplayers()                nsearch()                
- nsemit()                  nslemit()                 nsoemit()                
- nspemit()                 nsprompt()                nsremit()                
- nszemit()                 nthings()                 null()                   
- num()                     numversion()              nvcon()                  
- nvexits()                 nvplayers()               nvthings()               
- nwho()                    obj()                     object parents           
- objeval()                 objid()                   objmem()                 
- oemit()                   on-vacation               opaque                   
- open()                    or()                      ord()                    
- ordinal()                 orflags()                 orlflags()               
- orlpowers()               orphan                    outputprefix             
- outputsuffix              owner()                   page                     
+ poss()                    @power                    power()                  
+ @power2                   @power3                   powers()                 
+ powers2                   powers list               powers list2             
+ @prefix                   @pricelist                @prompt                  
+ prompt()                  prompt_newlines           @ps                      
+ pueblo                    pueblo()                  pueblo features          
+ puppet                    puppets                   puppets2                 
+ @purge                    queue                     quiet                    
+ quit                      @quota                    quota()                  
+ r()                       rand()                    randword()               
+ read                      @readcache                @receive                 
+ recv()                    @recycle                  regedit()                
+ regeditall()              regeditalli()             regediti()               
+ regexp                    regexp classes            regexp classes2          
+ regexp examples           regexps                   regexps2                 
+ regexp syntax             regexp syntax2            regexp syntax3           
 
 For more, see Entries-25
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-25
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- page2                     paranoid                  parent                   
- parent()                  parents                   parents2                 
- parents3                  parents4                  parents5                 
- parse()                   patchlevels               pcreate()                
- pemit()                   pi()                      pickrand()               
- pidinfo()                 player                    player()                 
- playermem()               pmatch()                  poll()                   
- ports()                   pos()                     pose                     
- pose2                     poss()                    power()                  
- powers list               powers list2              powers()                 
- powers2                   prompt()                  prompt_newlines          
- pueblo                    pueblo features           pueblo()                 
- puppet                    puppets                   puppets2                 
- queue                     quiet                     quit                     
- quota()                   r()                       r-function               
- rand()                    randword()                read                     
+ regexp syntax4            regexp syntax5            regexp syntax6           
+ regexp syntax7            regexp syntax8            registers                
+ registers2                regmatch()                regmatchi()              
+ regrab()                  regraball()               regraballi()             
+ regrabi()                 regrep()                  regrepi()                
+ regular expression functions                        @rejectmotd              
+ remainder()               @remit                    remit()                  
+ remove()                  repeat()                  replace()                
+ rest()                    @restart                  restarts()               
+ restarttime()             restrict                  restrict2                
+ restrict3                 reswitch()                reswitchall()            
+ reswitchalli()            reswitchi()               reverse()                
+ revwords()                r-function                right()                  
+ rjust()                   rloc()                    rnum()                   
+ room                      room()                    root()                   
+ round()                   royalty                   rquota                   
 
 For more, see Entries-26
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-26
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- recv()                    regedit()                 regeditall()             
- regeditalli()             regediti()                regexp                   
- regexp classes            regexp classes2           regexp examples          
- regexp syntax             regexp syntax2            regexp syntax3           
- regexp syntax4            regexp syntax5            regexp syntax6           
- regexp syntax7            regexp syntax8            regexps                  
- regexps2                  registers                 registers2               
- regmatch()                regmatchi()               regrab()                 
- regraball()               regraballi()              regrabi()                
- regrep()                  regrepi()                                          
- regular expression functions                        remainder()              
- remit()                   remove()                  repeat()                 
- replace()                 rest()                    restarts()               
- restarttime()             restrict                  restrict2                
- restrict3                 reswitch()                reswitchall()            
- reswitchalli()            reswitchi()               reverse()                
+ rules                     @runout                   @rwall                   
+ %s                        s()                       safe                     
+ say                       @scan                     scan()                   
+ score                     scramble()                screenheight             
+ screenwidth               @search                   search()                 
+ @search2                  search2                   @search3                 
+ @search4                  @search5                  secs()                   
+ secure()                  @select                   semaphores               
+ semaphores2               semaphores3               semaphores4              
+ semaphores5               semaphores6               semipose                 
+ sent()                    session                   @set                     
+ set()                     setdiff()                 setinter()               
+ setq()                    setq2                     setq3                    
+ setr()                    setting-attributes        setunion()               
+ @sex                      sex                       s-function               
+ sha0()                    shared                    shared players           
 
 For more, see Entries-27
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-27
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- revwords()                right()                   rjust()                  
- rloc()                    rnum()                    room                     
- room()                    root()                    round()                  
- royalty                   rquota                    rules                    
- s()                       s-function                safe                     
- say                       scan()                    score                    
- scramble()                screenheight              screenwidth              
- search()                  search2                   secs()                   
- secure()                  semaphores                semaphores2              
- semaphores3               semaphores4               semaphores5              
- semaphores6               semipose                  sent()                   
- session                   set()                     setdiff()                
- setinter()                setq()                    setq2                    
- setq3                     setr()                    setting-attributes       
- setunion()                sex                       sha0()                   
- shared                    shared players            shared players2          
+ shared players2           shl()                     shr()                    
+ shuffle()                 @shutdown                 sign()                   
+ sin()                     @sitelock                 @sitelock2               
+ @sitelock3                slay                      socket commands          
+ softcode                  sort()                    sortby()                 
+ sorting                   sortkey()                 soundex()                
+ soundex2                  soundlike()               soundslike()             
+ space()                   speak()                   speak2                   
+ speak3                    speak4                    speak5                   
+ speak6                    speak7                    spellnum()               
+ splice()                  spoofing                  @sql                     
+ sql()                     sqlescape()               sql functions            
+ sqrt()                    squish()                  @squota                  
+ ssl()                     stack                     starttime()              
+ @startup                  @stats                    stats()                  
+ stddev()                  step2                     step()                   
 
 For more, see Entries-28
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-28
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- shl()                     shr()                     shuffle()                
- sign()                    sin()                     slay                     
- socket commands           softcode                  sort()                   
- sortby()                  sorting                   sortkey()                
- soundex()                 soundex2                  soundlike()              
- soundslike()              space()                   speak()                  
- speak2                    speak3                    speak4                   
- speak5                    speak6                    speak7                   
- spellnum()                splice()                  spoofing                 
- sql functions             sql()                     sqlescape()              
- sqrt()                    squish()                  ssl()                    
- stack                     starttime()               stats()                  
- stddev()                  step2                     step()                   
  sticky                    strcat()                  string functions         
  strings                   stringsecs()              strinsert()              
  stripaccents()            stripansi()               strlen()                 
+ strmatch()                strreplace()              sub()                    
+ subj()                    substitutions             substitutions2           
+ substitutions3            substitutions4            @success                 
+ success                   suspect                   @sweep                   
+ @switch                   switch()                  @switch2                 
+ switch2                   switchall()               switches                 
+ switch wildcards          t()                       table()                  
+ tag()                     tagwrap()                 take                     
+ tan()                     teach                     tel()                    
+ @teleport                 tel_ok                    terminfo()               
+ terse                     testlock()                textentries()            
+ textfile()                think                     time()                   
+ timefmt()                 timefmt2                  time functions           
 
 For more, see Entries-29
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-29
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- strmatch()                strreplace()              sub()                    
- subj()                    substitutions             substitutions2           
- substitutions3            substitutions4            success                  
- suspect                   switch wildcards          switch()                 
- switch2                   switchall()               switches                 
- t()                       table()                   tag()                    
- tagwrap()                 take                      tan()                    
- teach                     tel()                     tel_ok                   
- terminfo()                terse                     textentries()            
- textfile()                think                     time functions           
- time()                    timefmt()                 timefmt2                 
  timestring()              topics                    topics2                  
- tr()                      track_money               translation              
- transparent               transparent2              trim()                   
+ @tport                    tr()                      track_money              
+ translation               transparent               transparent2             
+ @trigger                  @trigger2                 trim()                   
  trimpenn()                trimtiny()                trunc()                  
  trust                     trust2                    type()                   
+ types2                    types of objects          u()                      
+ u2                        u3                        ucstr()                  
+ udefault()                @ufail                    ufun()                   
+ ufun2                     ufun3                     ulambda()                
+ uldefault()               ulocal()                  ulocal2                  
+ @ulock                    @undestroy                unfindable               
+ @unfollow                 unfollow                  uninspected              
+ unique()                  @unlink                   @unlock                  
+ @unrecycle                unregistered              @uptime                  
+ @uptime2                  @use                      use                      
 
 For more, see Entries-30
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-30
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- types of objects          types2                    u()                      
- u2                        u3                        ucstr()                  
- udefault()                ufun()                    ufun2                    
- ufun3                     ulambda()                 uldefault()              
- ulocal()                  ulocal2                   unfindable               
- unfollow                  uninspected               unique()                 
- unregistered              use                       user-defined commands    
- user-defined2             utctime()                 utility functions        
- v()                       v-function                vadd()                   
- val()                     valid()                   vcross()                 
- vdim()                    vdot()                    verbose                  
- verbs                     version()                 visible()                
- visual                    vmag()                    vmax()                   
- vmin()                    vmul()                    vrml                     
- vsub()                    vunit()                   warnings                 
- warnings list             warnings list2            where()                  
+ user-defined2             user-defined commands     utctime()                
+ utility functions         @uunlock                  v()                      
+ vadd()                    val()                     valid()                  
+ vcross()                  vdim()                    vdot()                   
+ @verb                     @verb2                    @verb3                   
+ @verb4                    verbose                   verbs                    
+ @version                  version()                 v-function               
+ visible()                 visual                    vmag()                   
+ vmax()                    vmin()                    vmul()                   
+ vrml                      @vrml_url                 vsub()                   
+ vunit()                   @wait                     @wait2                   
+ @wait3                    @wall                     @warnings                
+ warnings                  @warnings2                @warnings3               
+ warnings list             warnings list2            @wcheck                  
+ where()                   @whereis                  whisper                  
+ whisper2                  who                       width()                  
 
 For more, see Entries-31
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-31
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- whisper                   whisper2                  who                      
- width()                   wildcards                 wildgrep()               
- wildgrepi()               wipe()                    with                     
- wizard                    wordpos()                 words()                  
+ wildcards                 wildgrep()                wildgrepi()              
+ @wipe                     wipe()                    with                     
+ @-wizard                  wizard                    @wizmotd                 
+ @wizwall                  wordpos()                 words()                  
  wrap()                    xattr()                   xattrp()                 
  xcon()                    xexits()                  xget()                   
  xmwho()                   xmwhoid()                 xor()                    
  xplayers()                xthings()                 xvcon()                  
  xvexits()                 xvplayers()               xvthings()               
- xwho()                    xwhoid()                  z_tel                    
- zemit()                   zfun()                    zmo                      
- zmp                       zmr                       zmt                      
- zmwho()                   zone                      zone master objects      
+ xwho()                    xwhoid()                  @zemit                   
+ zemit()                   @zenter                   zfun()                   
+ @zleave                   zmo                       zmp                      
+ zmr                       zmt                       zmwho()                  
+ zone                      zone()                    zone master objects      
  zone master rooms         zone masters              zone objects             
- zone()                    zones                     zones2                   
- zwho()                                                                       
+ zones                     zones2                    z_tel                    
 
 For more, see Entries-32
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+& Entries-32
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+ zwho()                                                                       
 
 & &Entries
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Index: game/txt/hlp/pennfunc.hlp
===================================================================
--- game/txt/hlp/pennfunc.hlp	(.../183p10)	(revision 142)
+++ game/txt/hlp/pennfunc.hlp	(.../183p11)	(revision 142)
@@ -1,6 +1,6 @@
 & FUNCTIONS
   Functions are specialized commands used to manipulate strings and
-  other input. Function take the general form: [FUNCTION(<input>)]
+  other input. Functions take the general form: [FUNCTION(<input>)]
 
   The brackets are used to delimit and force evaluation of the
   function (or nested functions). The brackets can also be used to
@@ -9,28 +9,25 @@
   nest an arbitrary number of brackets.
 
   Examples:
-      > say [first(rest(This is a nice day))]
-      You say, "is"
-      > @va me=This is a 
-      Wizard - Set.
-      > @vb me=nice day
-      Wizard - Set.
-      > say [first([rest([v(va)] [v(vb)])])]
-      You say, "is"
+    > say first(rest(This is a nice day))
+    You say, "is"
+  
+    > @va me=This is a 
+    > @vb me=nice day
+    > say first(rest(v(va) [v(vb)]))
+    You say, "is"
 
   See "help FUNCTIONS2" for more.
 
 & FUNCTIONS2
-
-  A list of available built-in functions can be obtained via the
-  command "@config/functions". In the help text, the list is under the
-  topic "FUNCTION LIST".
-
-  In addition to these built-in functions are MUSH-defined "global
-  user functions."  These are defined by wizards or those with the
-  "Function" power, via the "@function" command. To the user, they act
-  just like the built-in game functions. For details on global user
-  functions, see "help @function".
+  There are two types of functions, "built-in functions" and "global
+  user functions", also known as "@functions". You can get a complete
+  list of functions on this game with "@list/functions".
+  
+  Built-in functions are written in the game hardcode, while @functions
+  are written in softcode, and then made global with the "@function"
+  command. Both are used in exactly the same manner. For more information
+  on @functions, see "help @function".
 
 See also: MUSHCODE
 & FUNCTION LIST
@@ -56,29 +53,29 @@
   Time functions: Formatting and display of time (TIME, CONVSECS)
   Utility functions: general utilities (ISINT, COMP)
 
-  The command "@config/functions" lists all of the game's built-in functions.
-  The command "@function" lists all of the game's custom global functions
+  The command "@list/functions" lists all functions on the game.
+  The command "@function" lists only the game's custom global functions
     defined via the @function command.
 
 & Attribute functions
-  The primary purpose of these functions is to access information
+  The primary purpose of these functions is to access or alter information
   stored in attributes on objects.
 
   aposs()        attrib_set()   default()      edefault()     eval()
   get()          grep()         grepi()        hasattr()      hasattrp()
   hasattrval()   lattr()        nattr()        obj()          poss()
   regrep()       regrepi()      subj()         udefault()     ufun()
-  uldefault()    ulocal()       v-function     wildgrep()     wildgrepi()
+  uldefault()    ulocal()       v()            wildgrep()     wildgrepi()
   xget()         zfun()         
 
 See also: ATTRIBUTES, NON-STANDARD ATTRIBUTES
 & Bitwise functions
-  These functions treat integers as a sequence of binary bits (Either 0
+  These functions treat integers as a sequence of binary bits (either 0
   or 1) and manipulate them.
 
   For example, 2 is represented as '0010' and 4 as '0100'. If these
   two numbers are bitwise-or'ed together with BOR(), the result is 6,
-  or (In binary) '0110'. These functions are useful for storing small
+  or (in binary) '0110'. These functions are useful for storing small
   lists of toggle (Yes/No) options efficiently.
 
   baseconv()    band()        bnand()       bnot()        bor()
@@ -242,17 +239,27 @@
   @@(<expression>)
   null(<expression>[, ... , <expression>])
 
-  The @@() function does nothing and returns nothing. It could be used
-  for commenting, perhaps. It does not evaluate its argument.
+  The @@() function does nothing and returns nothing. It does not evaluate
+  its argument. It could be used for commenting, perhaps. 
 
   The null() function is similar, but does evaluate its argument(s),
   so side-effects can occur within a null(). Useful for eating the
   output of functions when you don't use that output.
+  
+See also: @@
 & ABS()
   abs(<number>)
 
-  Returns the absolute value of a number. i.e. ABS(-4) returns 4;
-  ABS(2) returns 2, etc.
+  Returns the absolute value of a number.
+  
+  Examples:
+    > say abs(-4)
+    You say, "4"
+    
+    > say abs(2)
+    You say, "2"
+    
+See also: sign()
 & ACCENT()
   accent(<string>, <template>)
 
@@ -262,12 +269,12 @@
 
   Whether or not the resulting string is actually displayed correctly
   is client-dependent. Some OSes uses different character sets than
-  the one assumes (ISO 8859-1), and some clients strip these 8-bit
+  the one assumed (ISO 8859-1), and some clients strip these 8-bit
   characters.
 
-  See 'HELP ACCENT2' for a description of the template argument.
+  See 'HELP ACCENT2' for a description of the <template> argument.
 
-See also: stripaccents(), NOACCENTS
+See also: stripaccents(), NOACCENTS, @nameaccent, accname()
 & ACCENT2
   For each character in <string>, the corresponding character of
   <template> is checked according to the table below, and a replacement
@@ -292,7 +299,7 @@
   cedilla    Small tail below    ,          C,c
              letter
 
-  See 'HELP ACCENT3' for more
+  Continued in 'HELP ACCENT3'
 & ACCENT3
   These are non-accent special characters, mostly punctuation and
   non-roman letters.
@@ -314,53 +321,58 @@
 & ACCENT4
   Some examples of accent() and their expected outputs:
 
-  > think accent(Aule, ---:)
-  Aul(e-with-diaeresis)
+    > think accent(Aule, ---:)
+    Aul(e-with-diaeresis)
 
-  > think accent(The Nina was a ship, The Ni~a was a ship) 
-  The Ni(n-with-~)a was a ship
+    > think accent(The Nina was a ship, The Ni~a was a ship) 
+    The Ni(n-with-~)a was a ship
 
-  > think accent(Khazad ai-menu!, Khaz^d ai-m^nu!)
-  Khaz(a-with-^)d ai-m(e-with-^)nu!
+    > think accent(Khazad ai-menu!, Khaz^d ai-m^nu!)
+    Khaz(a-with-^)d ai-m(e-with-^)nu!
 & ACCNAME()
   accname(<object>)
 
-  accname() returns the name of object <object>, applying the object's
+  accname() returns the name of <object>, applying the object's
   @nameaccent, if any.
 
-  Related functions: NAME(), FULLNAME(), INAME()
+See also: name(), fullname(), iname()
 & ACOS()
-  acos(<cosine>[,<angle type>])
+  acos(<cosine>[, <angle type>])
  
   Returns the angle that has the given <cosine> (arc-cosine), with the
-  angle expressed in the given angle type, or radians by default.
+  angle expressed in the given <angle type>, or radians by default.
 
-  See 'HELP CTU()' for more on the angle type.
+  See 'HELP ANGLES' for more on the <angle type>.
+
+See also: asin(), atan(), cos(), ctu(), sin(), tan()
 & ADD()
   add(<number>, <number>[, ... , <numberN>])
 
-  Returns the sum of some numbers. 
+  Returns the sum of the given <number>s.
+  
+See also: MATH FUNCTIONS
 & AFTER()
   after(<string1>, <string2>)
 
   Returns the portion of <string1> that occurs after <string2>.  If
-  <string2> isn't in <string1>, the function returns a null string.
+  <string2> isn't in <string1>, the function returns nothing.
   This is case-sensitive.
  
   Examples:
-   > think after(foo bar baz,bar)
-    baz
-   > think after(foo bar baz,ba)
-   r baz
+    > say after(foo bar baz,bar)
+    You say, "baz"
+    
+    > say after(foo bar baz,ba)
+    You say, "r baz"
 
 See also: before(), rest()
 & ALIGN()
 & LALIGN()
-  align(<widths>,<col1>,...,<coln>[,<filler>[,<colsep>[,<rowsep>]]])
-  lalign(<widths>,<colList>[,<delim>[,<filler>[,<colsep>[,<rowsep>]]]])
+  align(<widths>, <col>[, ... , <colN>[, <filler>[, <colsep>[, <rowsep>]]]])
+  lalign(<widths>, <colList>[, <delim>[, <filler>[, <colsep>[, <rowsep>]]]])
 
-  Creates columns of text, each column designated by <col1..coln>.
-  Each column is individually wrapped inside its own column, allowing
+  Creates columns of text, each column designated by <col> arguments.
+  Each <col> is individually wrapped inside its own column, allowing
   for easy creation of book pages, newsletters, or the like. In lalign(),
   <colList> is a <delim>-separated list of the columns.
 
@@ -382,7 +394,7 @@
   inserted between every line. By default, <filler> and <colsep> are a
   space, and <rowsep> is a newline.
 
-  Continued in HELP ALIGN2
+  Continued in 'help align2'
 & ALIGN2
   Examples:
   
@@ -403,81 +415,75 @@
          +                  Luke                  +
          +----------------------------------------+
 
-See also: center(), ljust(), rjust()
+See also: center(), ljust(), rjust(), table()
 & ALLOF()
-  allof(<expr1>[, ... , <exprN>],<osep>)
+  allof(<expr>[, ... , <exprN>], <osep>)
 
-  Evaluates every expression argument (including side-effects) and
+  Evaluates every <expr> argument (including side-effects) and
   returns the results of those which are true, in a list separated by
-  osep.  The output separator argument is required and must be a
+  <osep>. The output separator argument is required and must be a
   single character, or can be left empty, in which case a space will
   be used to separate the results by default.
 
   The meaning of true or false depends on configuration options as
   explained in the 'BOOLEAN VALUES' help topics.
 
-  > &s me=Bats are similar to Rats which are afraid of Cats
-  > say allof(grab(v(s),rats),grab(v(s),mats),grab(v(s),bats),)
-  You say, "Rats Bats"
+    > &s me=Bats are similar to Rats which are afraid of Cats
+    > say allof(grab(v(s),rats),grab(v(s),mats),grab(v(s),bats),)
+    You say, "Rats Bats"
 
-  > say allof(#-1,#101,#2970,,#-3,0,#319,null(This Doesn't Count),|)
-  You say, "#101|#2970|#319"
+    > say allof(#-1,#101,#2970,,#-3,0,#319,null(This Doesn't Count),|)
+    You say, "#101|#2970|#319"
 
 See also: firstof(), BOOLEAN VALUES
 & ALPHAMAX()
-  alphamax(<word1>[, ... , <wordN>])
+  alphamax(<word>[, ... , <wordN>])
 
-  Takes any number of arguments, and returns the word which is
-  lexicographically biggest. I.e., which word would be last in
+  Takes any number of <word> arguments, and returns the one which is
+  lexicographically biggest. That is, the <word> would be last in
   alphabetical order.
+  
+  This is equivilent to last(sort(<word> ... <wordN>,a)).
 
+See also: alphamin()
 & ALPHAMIN()
-  alphamin(<word1>[, ... , <wordN>])
+  alphamin(<word>[, ... , <wordN>])
 
-  Takes any number of arguments, and returns the word which is
-  lexicographically smallest: the word that would be first in
+  Takes any number of <word> arguments, and returns the one which is
+  lexicographically smallest. That is, the word that would be first in
   alphabetical order.
+  
+  This is equivilent to first(sort(<word> ... <wordN>,a)).
 
+See also: alphamax()
 & AND()
 & CAND()
-  and(<boolean value 1>, <boolean value 2>[, ... , <boolean value N>])
-  cand(<boolean value 1>, <boolean value 2>[, ... , <boolean value N>])
+  and(<boolean>, <boolean>[, ... , <booleanN>])
+  cand(<boolean1>, <boolean2>[, ... , <booleanN>])
  
-  Takes boolean values, and returns 1 if all of them are true.  and()
-  always evaluates all arguments (including side effects), while
-  cand() stops evaluation after the first argument that evaluates to
-  false.
+  These functions take any number of boolean values, and return 1 if
+  all are true, and 0 otherwise. and() will always evaluate all its
+  arguments (including side effects), while cand() stops evaluation
+  after the first false argument.
 
 See also: BOOLEAN VALUES, or(), xor(), not()
 & ANDFLAGS()
-  andflags(<object>,<string of flag letters>)
-
-  This function returns 1 if <object> has all the flags in a specified
-  string, and 0 if it does not. The string is specified with a single
-  letter standing for each flag, like the output of the FLAGS()
-  function. A '!'  preceding a flag letter means "not flag".
-
-  Thus, ANDFLAGS(me,WD) would return 1 if I was set WIZARD and DARK.
-  ANDFLAGS(me,W!Dc) would return 1 if I was set WIZARD, not DARK, and
-  CONNECTED.
-
-  If a letter does not correspond to any flag, <object> doesn't have
-  it, so the function returns 0. There can be an arbitrary number of
-  flags. Do not put spaces between flag letters.
-& ANDLFLAGS()
-  andlflags(<object>, <list of flags>)
-
-  This function returns 1 if <object> has all the flags in a specified
-  list, and 0 if it does not. The list is a space-separated list of
-  flag names.  A '!' preceding a flag name means "not flag".
-
-  Thus, ANDLFLAGS(me,wizard dark) would return 1 if I was set WIZARD
-  and DARK.  ANDFLAGS(me,wizard !Dark connected) would return 1 if I
-  was set WIZARD, not DARK, and CONNECTED.
-
-  If a name does not correspond to any flag, <object> doesn't have it,
-  so the function returns 0. There can be an arbitrary number of
-  flags.
+  andflags(<object>, <string of flag letters>)
+  andlflags(<object>, <list of flag names>)
+  
+  These functions return 1 if <object> has all of the given flags, and 0 if
+  it does not. andflags() takes a string of single flag letters, while
+  andlflags() takes a space-separated list of flag names. In both cases, a
+  ! before the flag means "not flag".
+  
+  If any of the flags given are invalid, <object> cannot have them, so the
+  functions return 0.
+  
+  Example: Check to see if %# is set Wizard and Dark, but not Ansi.
+    > say andflags(%#, WD!A)
+    > say andlflags(%#, wizard dark !ansi)
+  
+See also: orflags(), flags(), lflags()
 & ANDLPOWERS()
   andlpowers(<object>, <list of powers>)
 
@@ -487,16 +493,18 @@
 
   Thus, ANDLPOWERS(me, no_quota no_pay) would return 1 if I was
   powered no_quota and no_pay.  ANDLPOWERS(me, poll !guest) would
-  return 1 if I could change the poll and was not a guest.
+  return 1 if I had the poll power but not the guest power.
 
   If a name does not correspond to any power, <object> doesn't have
   it, so the function returns 0. There can be an arbitrary number of
   powers.
+
+See also: powers(), orlpowers(), POWERS LIST, @power
 & ANSI()
   ansi(<codes>, <string>)
  
   This allows you to highlight a string using ANSI terminal effects.
-  The codes are:
+  Valid <codes> are:
  
         f - flash                       F - not flash
         h - hilite                      H - not hilite
@@ -526,6 +534,8 @@
   Returns the absolute possessive pronoun - his/hers/its/theirs - for
   an object. The %a substitution returns the absolute possessive
   pronoun of the enactor.
+  
+See also: obj(), poss(), subj()
 & ART()
   art(<string>)
 
@@ -535,27 +545,31 @@
   asin(<sine>[,<angle type>])
  
   Returns the angle with the given <sine> (arc-sine), with the angle
-  expressed in the given angle type, or radians by default.
+  expressed in the given <angle type>, or radians by default.
 
-  See 'HELP CTU()' for more on the angle type.
+  See 'HELP ANGLES' for more on the angle type.
+
+See also: acos(), atan(), cos(), ctu(), sin(), tan()
 & ATAN()
 & ATAN2()
-  atan(<tangent>[,<angle type>])
-  atan2(<number>, <number>[,<angle type>])
+  atan(<tangent>[, <angle type>])
+  atan2(<number1>, <number2>[, <angle type>])
 
   Returns the angle with the given <tangent> (arc-tangent), with the
-  angle expressed in the given angle type, or radians by default.
+  angle expressed in the given <angle type>, or radians by default.
 
-  atan2(y, x) is like atan(fdiv(y, x)), except x can be 0, and the
+  atan2(x, y) is like atan(fdiv(x, y)), except y can be 0, and the
   signs of both arguments are used in determining the sign of the
   result. It is useful in converting between cartesian and polar
   coordinates.
 
-  See 'HELP CTU()' for more on the angle type.
+  See 'HELP ANGLES' for more on the angle type.
+
+See also: acos(), asin(), cos(), ctu(), sin(), tan()
 & ATRLOCK()
   atrlock(<object>/<attrib>[, <on|off>])
 
-  When given a single object/attribute pair as an argument, returns 1
+  When given a single <object>/<attribute> pair as an argument, returns 1
   if the attribute is locked, 0 if unlocked, and #-1 if the attribute
   doesn't exist or can't be read by the function's caller.
 
@@ -564,7 +578,7 @@
 & ATTRIB_SET()
   attrib_set(<object>/<attrib>[, <value>])
 
-  Sets or clears an attribute. With a value, it sets the attribute,
+  Sets or clears an attribute. With a <value>, it sets the attribute,
   without one, it clears the attribute. This is an easier-to-read
   replacement for the old set(<object>, <attrib>:<value>) notation,
   and a less destructive replacement for wipe() that won't destroy
@@ -572,24 +586,30 @@
 
   If there is a second argument, then attrib_set() will create an
   attribute, even if the second argument is empty (in which case
-  attrib_set() will create an empty attribute).  This means that
-  attrib_set(me/foo,%0) will _always_ create an attribute.
+  attrib_set() will create an empty attribute).  If the empty_attrs
+  configuration option is off, the attribute will be set to a single
+  space. This means that attrib_set(me/foo,%0) will _always_
+  create an attribute.
 
-  Of course, if the empty_attrs configuration option is turned off,
-  then the above paragraph doesn't apply.  See '@config attribs'.
-  
+See also: set()
 & BAND()
-  band(<integer1>, <integer2>[, ... , <integerN>])
+  band(<integer>, <integer>[, ... , <integerN>])
 
-  Does a bitwise AND of all its arguments, returning the result (A
+  Does a bitwise AND of all its arguments, returning the result (a
   number with only the bits set in every argument set in it).
+  
+See also: BITWISE FUNCTIONS
 & BASECONV()
   baseconv(<number>, <from base>, <to base>)
 
   Converts <number>, which is in base <from base> into base <to base>.
   The bases can be between 2 (binary) and 64, inclusive.
 
-  All bases over 64 use base64 url string:
+  Numbers 36 and under use the standard numbers:
+
+  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+
+  All bases over 36 use base64 url string:
 
   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
 
@@ -597,7 +617,7 @@
 & BEEP()
   beep([<number>])
  
-  Sends <number> "alert" bell characters. <number> must be in the
+  Returns <number> "alert" bell characters. <number> must be in the
   range 1 to 5, or, if unspecified, defaults to 1.  This function may
   only be used by royalty and wizards.
  
@@ -609,46 +629,50 @@
   case-sensitive.
  
   Examples:
-   > think before(foo bar baz,bar)
-   foo
-   > think before(foo bar baz,r)
-   foo ba
+     > say before(foo bar baz,bar)
+     You say, "foo"
+     > say before(foo bar baz,r)
+     You say, "foo ba"
 
 See also: after(), first()
 & BRACKETS()
-  brackets([<string>])
+  brackets(<string>)
 
   Returns a count of the number of left and right square brackets,
   parentheses, and curly braces in the string, in that order, as a
   space-separated list of numbers. This is useful for finding missing
-  or extra brackets in MUSH code.
+  or extra brackets in MUSH code. <string> is evaluated.
 
   Example:
-  > @desc me=This is [ansi(h,a test)] of the { brackets() function.
-  > think brackets(v(desc))
-  1 1 2 2 1 0
+    > @desc me=This is [ansi(h,a test)] of the { brackets() function.
+    > think brackets(v(desc))
+    1 1 2 2 1 0
 & BNAND()
-  bnand(<integer>, <integer>)
+  bnand(<integer1>, <integer2>)
 
-  Returns its first argument with every bit that was set in the second
-  argument cleared.
+  Returns <integer1> with every bit that was set in <integer2> cleared.
+
+See also: BITWISE FUNCTIONS
 & BNOT()
   bnot(<integer>)
 
-  Returns the bitwise complement of its argument. Every bit set in it
+  Returns the bitwise complement of <integer>. Every bit set in it
   is cleared, and every clear bit is set.
+
+See also: BITWISE FUNCTIONS
 & BOR()
   bor(<integer>, <integer>[, ... , <integerN>])
 
   Does a bitwise OR of all its arguments, returning the result.
   (A number with a bit set if that bit appears in any of its arguments).
+  
+See also: BITWISE FUNCTIONS
 & BOUND()
   bound(<number>, <lower bound>, <higher bound>)
 
   bound() returns <number> if it is between <lower bound> and <higher
-  bound>. If it's lower than the lower bound, the lower bound is
-  returned. If it's higher than the higher bound, the higher bound is
-  returned.
+  bound>. If it's lower than <lower bound>, <lower bound> is returned.
+  If it's higher than <higher bound>, <higher bound> is returned.
   
 See also: ceil(), floor(), round(), trunc()
 & BXOR()
@@ -656,19 +680,26 @@
 
   Does a bitwise XOR of all its arguments, returning the result.
   (A number with a bit set if it's set in only one of its arguments).
+  
+See also: BITWISE FUNCTIONS
 & CAPSTR()
   capstr(<string>)
   
   Returns <string> with the first character capitalized.
 
-  Example: capstr(foo bar baz) returns "Foo bar baz"
+  Example:
+    > think capstr(foo bar baz)
+    Foo bar baz
 
 See also: lcstr(), ucstr()
 & CAT()
-  cat(<string1>[, ... , <stringN>])
+  cat(<string>[, ... , <stringN>])
 
-  cat() concatenates strings, separating each string by a space.  So
-  "[cat(one, two)]" will return 'one two'.
+  cat() concatenates strings, separating each string by a space.
+  
+  Example:
+    > think cat(one, two)
+    one two
 
 See also: strcat()
 & CEIL()
@@ -692,10 +723,13 @@
   Examples:
     > say center(X,5,-)
     You say, "--X--"
+
     > say center(X,5,-=)
     You say, "-=X=-"
+
     > say center(.NEAT.,15,-,=)
     You say, "----.NEAT.====="
+
     > say center(hello,16,12345)
     You say, "12345hello543215"
 
@@ -703,25 +737,25 @@
 & CHECKPASS()
   checkpass(<player>, <string>)
 
-  Returns 1 if <string> matches the player's password otherwise 0.  If
+  Returns 1 if <string> matches <player>'s password, and 0 otherwise.  If
   <player> has no password, this function will always return 1.
-  <player> should be specified as a dbref or *<name>.
 
-  This function is restricted to wizards.
+  This function can only be used by wizards.
 
+See also: @password, @newpassword
 & CHR()
 & ORD()
   chr(<number>)
   ord(<character>)
 
-  ord() returns the numerical value of the given character.  chr()
+  ord() returns the numerical value of the given character. chr()
   returns the character with the given numerical value.
 
   Examples:
-  > think ord(A)
-  65
-  > think chr(65)
-  A
+    > say ord(A)
+    You say, "65"
+    > say chr(65)
+    You say, "A"
 & CLONE()
   clone(<object>)
  
@@ -735,18 +769,18 @@
   Returns the number of commands issued by a player during this
   connection as indicated by WHO.
 
-  The caller can use the function on himself, but using on any other
-  player requires privileged power such as Wizard, Royalty or SEE_ALL.
+  You must be a Wizard, Royalty or See_All to use this function on anyone
+  but yourself.
 
-See also: Connection Functions
+See also: CONNECTION FUNCTIONS
 & SENT()
   sent(<player|descriptor>)
 
   Returns the number of characters sent by a player during this
   connection as indicated by SESSION.
 
-  The caller can use the function on himself, but using on any other
-  player requires privileged power such as Wizard, Royalty or SEE_ALL.
+  You must be a Wizard, Royalty or See_All to use this function on anyone
+  but yourself.
 
 See also: Connection Functions
 & RECV()
@@ -755,15 +789,15 @@
   Returns the number of characters received by a player during this
   connection as indicated by SESSION.
 
-  The caller can use the function on himself, but using on any other
-  player requires privileged power such as Wizard, Royalty or SEE_ALL.
+  You must be a Wizard, Royalty or See_All to use this function on anyone
+  but yourself.
 
 See also: Connection Functions
 & COMP()
   comp(<value1>, <value2>[,<type>])
 
-  Comp compares two values.  It returns 0 if they are the same, -1 if
-  value1 is less than/precedes alphabetically value2, and 1 otherwise.
+  comp() compares two values.  It returns 0 if they are the same, -1 if
+  <value1> is less than/precedes alphabetically <value2>, and 1 otherwise.
 
   By default the comparison is a case-sensitive lexicographic (string)
   comparison. By giving the optional <type>, the comparison can be
@@ -777,11 +811,12 @@
         F               Floating point numbers
 
   Whether or not the a sort type is case-sensitive or not depends on
-  the particular mush and its environment.
+  the particular MUSH and its environment.
+See also: strmatch(), eq()
 & CON()
   con(<object>)
 
-  Returns the dbref of the first object in a container.
+  Returns the dbref of the first object in the <object>'s inventory.
 
   You can get the complete contents of any container you may examine,
   regardless of whether or not objects are dark.  You can get the
@@ -794,49 +829,56 @@
 & CONDALL()
 & NCOND()
 & NCONDALL()
-  cond(<cond1>, <expr1>, [<condN>, <exprN>], ...[<default>])
-  condall(<cond1>, <expr1>, [<condN>, <exprN>], ...[<default>])
-  ncond(<cond1>, <expr1>, [<condN>, <exprN>], ...[<default>])
-  ncondall(<cond1>, <expr1>, [<condN>, <exprN>], ...[<default>])
+  cond(<cond>, <expr>[, ... , <condN>, <exprN>][, <default>])
+  condall(<cond>, <expr>[, ... , <condN>, <exprN>][, <default>])
+  ncond(<cond>, <expr>[, ... , <condN>, <exprN>][, <default>])
+  ncondall(<cond>, <expr>[, ... , <condN>, <exprN>][, <default>])
 
-  cond() evaluates <cond>s until one returns a boolean true
-  value. Should none return true, <default> is returned.
+  cond() evaluates <cond>s until one returns a true value. Should
+  none return true, <default> is returned.
 
   condall() returns all <expr>s for those <cond>s that evaluate to
-  true.
+  true, or <default> if none are true.
 
   ncond() and ncondall() are identical to cond(), except it returns
   <expr>s for which <cond>s evaluate to false.
 
   Examples:
-  > say cond(0,This is false,#-1,This is also false,#123,This is true)
-  You say, "This is true"
+    > say cond(0,This is false,#-1,This is also false,#123,This is true)
+    You say, "This is true"
 
-  > say ncond(0,This is false,#-1,This is also false,#123,This is true)
-  You say, "This is false"
+    > say ncond(0,This is false,#-1,This is also false,#123,This is true)
+    You say, "This is false"
   
-  > say ncondall(0,This is false,#-1,This is also false,#123,This is true)
-  You say, "This is falseThis is also false"
+    > say ncondall(0,This is false,#-1,This is also false,#123,This is true)
+    You say, "This is falseThis is also false"
+    
+See also: firstof(), allof()
 & CONFIG()
-  config()
-  config(<option>)
+  config([<option>])
 
-  With no arguments, this function returns a list of config option
-  names.  Given a config option name, this function returns its value.
+  With no arguments, config() returns a list of config option names.
+  If <option> is given, config() returns the value of the given option
   Boolean configuration options will return values of "Yes" or "No".
 
-  Ex: config(money_singular) => "Penny"
+  Example:
+  > think config(money_singular)
+  Penny
 
 & CONN()
   conn(<player|descriptor>)
  
   This function returns the number of seconds a player has been
-  connected.  <player name> must be the full name of a player, or a
-  player's dbref.  Players who are not connected have a conn value of
-  "-1", as do dark wizards, when conn() is used on them by a
-  non-priv'ed player.
+  connected. <player> should be the full name of a player or a dbref.
+  You can also use a <descriptor> to get connection information for
+  a specific connection when a player is connected more than once.
+  Wizards can also specify the descriptor of a connection which is still
+  at the login screen.
+  
+  This function returns -1 for invalid <player|descriptor>s, offline 
+  players and players who are dark, if the caller is not able to see them.
  
-See also: CONNECTED
+See also: CONNECTION FUNCTIONS
 & CONTROLS()
   controls(<object>, <victim>[/<attribute>])
   
@@ -850,8 +892,7 @@
   <object> or <victim>, or have the See_All power, to use this
   function.
 
-See also: CONTROL
-  
+See also: visible(), CONTROL
 & CONVSECS()
 & CONVUTCSECS()
   convsecs(<seconds>[, <zone>])
@@ -866,18 +907,20 @@
   the time based on UTC time instead of the server's local time.
   
   Examples:
-  > say [secs()]
-  You say, "709395750"
-  > say [convsecs(709395750)]
-  You say, "Wed Jun 24 10:22:54 1992"
-  > say [convutcsecs(709395750)]
-  You say, "Wed Jun 24 14:22:30 1992"
+    > say secs()
+    You say, "709395750"
+    
+    > say convsecs(709395750)
+    You say, "Wed Jun 24 10:22:54 1992"
+    
+    > say convutcsecs(709395750)
+    You say, "Wed Jun 24 14:22:30 1992"
 
 See also: convtime(), time()
 & CONVTIME()
   convtime(<time string>)
 
-  This functions converts a time string (in the local time zone) to
+  This functions converts a time string (in the server's time zone) to
   the number of seconds since Jan 1, 1970 GMT. A time string is of the
   format: Ddd MMM DD HH:MM:SS YYYY where Ddd is the day of the week,
   MMM is the month, DD is the day of the month, HH is the hour in
@@ -890,33 +933,39 @@
   week and year, and a 'Month Day Year' format.
 
   Example:
-  > say [time()]
-  You say, "Wed Jun 24 10:22:54 1992"
-  > say [convtime(Wed Jun 24 10:22:54 1992)]
-  You say, "709395774"
+    > say time()
+    You say, "Wed Jun 24 10:22:54 1992"
+    
+    > say convtime(Wed Jun 24 10:22:54 1992)
+    You say, "709395774"
 
 See also: convsecs(), time()
 & COS()
-  cos(<angle>[,<angle type>])
+  cos(<angle>[, <angle type>])
  
   Returns the cosine of <angle>. Angle must be in the given angle
   type, or radians by default.
 
   Examples:
-  > say cos(90, d)
-  You say, "0" 
-  > say cos(1.570796)
-  You say, "0"
+    > say cos(90, d)
+    You say, "0" 
+  
+    > say cos(1.570796)
+    You say, "0"
 
-  See 'HELP CTU()' for more on the angle type.
+  See 'HELP ANGLES' for more on the angle type.
+
+See also: acos(), asin(), atan(), ctu(), sin(), tan()
 & PCREATE()
   pcreate(<name>, <password>[, <dbref>])
 
-  Creates a player with a given name and password. Wizard-only.
+  Creates a player with a given <name> and <password>. This function
+  can only be used by wizards.
+  
   The optional third argument can be used to specify a garbage object
   to use for the new player.
 
-See also: @pcreate
+See also: @pcreate, create()
 & CREATE()
    create(<object>[, <cost>[, <dbref>]])
 
@@ -924,7 +973,10 @@
    and returns the dbref number of the created object. It returns #-1 on
    error. 
 
-   Wizards may also specify a <dbref>, as per @create.  
+   Wizards may also specify a <dbref>; if this refers to a garbage object,
+   the new object is created with this dbref.
+   
+See also: @create, pcreate()
 & CTIME()
 & CSECS()
   ctime(<object>[, <utc>])
@@ -935,50 +987,62 @@
   which case the time is in the UTC timezone.
  
   csecs() returns the time as the number of seconds since the epoch.
+  Anyone can get the creation time of any object in the game.
 
-  You must be able to examine an object to see its creation time.
+See also: mtime(), time(), secs(), objid()
+& ANGLES
+
+  In any function which accepts an angle type, the argument can be one of
+  'd' for degrees, 'r' for radians, or 'g' for gradians. Gradians are not
+  used often, but it's included for completeness.
+
+  As a refresher, there are 180 degrees in pi radians in 200 gradians.
 
-See also: mtime(), time(), secs()
 & CTU()
-  ctu(<angle>,<from>,<to>)
+  ctu(<angle>, <from>, <to>)
 
   Converts between the different ways to measure angles.  <from>
   controls what the angle is treated as, and <to> what form it is
-  turned into. They can be 'd' for degrees, or 'r' for radians.  There
-  is also a third way to measure angle, 'g' for gradians, but it's not
-  used often and is only included for completeness.
-
-  As a refresher, there are 180 degrees in pi radians in 200 gradians.
-
+  turned into. See HELP ANGLES for more information.
+  
   Example:
-  > say 90 degrees is [ctu(90, d, r)] radians
-  You say, "90 degrees is 1.570796 radians"
+    > say 90 degrees is [ctu(90, d, r)] radians
+    You say, "90 degrees is 1.570796 radians"
+
+See also: acos(), asin(), atan(), cos(), sin(), tan()
 & DEC()
   dec(<integer>)
   dec(<string-ending-in-integer>)
 
-  Dec returns the integer minus 1. If given a string that ends in an
-  integer, it decrements only the final integer portion. That is:
+  desc() returns the given <integer> minus 1. If given a string that ends in
+  an integer, it decrements only the final integer portion. That is:
 
-  > think dec(3)
-  2
-  > think dec(hi3)
-  hi2
-  > think dec(1.3.3)
-  1.3.2
-  > think dec(1.3)
-  1.2
+    > think dec(3)
+    2
+    
+    > think dec(hi3)
+    hi2
+    
+    > think dec(1.3.3)
+    1.3.2
+    
+    > think dec(1.3)
+    1.2
 
   Note especially the last example, which will trip you up if you use
   floating point numbers with dec() and expect it to work like sub().
 
-See also: inc()
+See also: inc(), sub()
 & DECOMPOSE()
   decompose(<string>)
 
   decompose() works like escape() with the additional caveat that it
   inserts parse-able characters to recreate <string> exactly after one
   parsing. It takes care of multiple spaces, '%r's, and '%t's.
+  
+  Example:
+    > think decompose(This is \[a [ansi(y,test)]\][space(3)])
+    This is \[a%b[ansi(y,test)]\] %b%b
 
 See also: @decompile2, escape(), secure()
 & DECODE64()
@@ -988,7 +1052,7 @@
 
   Requires SSL support; see @config compile.
 
-See also: encode64()
+See also: encode64(), encrypt(), decrypt()
 & DECRYPT()
   decrypt(<string>, <password>[, <encoded>])
 
@@ -998,16 +1062,16 @@
   If the optional <encoded> argument is true, it indicates that the
   input string is encoded in base 64.
 
-See also: encrypt(), encode64()
+See also: encrypt(), encode64(), decode64()
 & DEFAULT()
-  default([<obj>/]<attr>[, ... ,[<obj>]/<attr>], <default case>)
+  default([<obj>/]<attr>[, ... ,[<objN>]/<attrN>], <default>)
  
   This function returns the value of the first possible <obj>/<attr>,
   as if retrieved via the get() function, if the attribute exists and
-  is readable by you.  Otherwise, it evaluates the default case, and
-  returns that.  Note that the default case is only evaluated if the
-  attribute does not exist or cannot be read. Note further than an
-  empty attribute counts as an existing attribute.
+  is readable by you.  Otherwise, it evaluates <default>, and returns
+  that.  Note that <default> is only evaluated if none of the given
+  attributes exist or can be read. Note further than an empty attribute
+  counts as an existing attribute.
 
   This is useful for code that needs to return the value of an
   attribute, or an error message or default case, if that attribute
@@ -1017,24 +1081,25 @@
     > &TEST me=apple orange banana
     > say default(me/Test, No fruits!)
     You say "apple orange banana"
+
     > &TEST ME
     > say default(me/Test, No fruits!)
     You say "No fruits!"
  
-See also: get(), eval(), ufun(), edefault(), udefault(), uldefault()
- 
+See also: get(), hasattr(), ufun(), edefault(), udefault(), uldefault()
 & DELETE()
   delete(<string>, <first>, <len>)
  
   Return a modified <string>, with <len> characters starting after the
   character at position <first> deleted. In other words, it copies
-  <first> characters, skips <len> characters>, and then copies the
+  <first> characters, skips <len> characters, and then copies the
   remainder of the string. If <len> is negative, deletes characters
   leftwards from <first>.  Characters are numbered starting at 0.
 
   Examples:
     > say delete(abcdefgh, 3, 2)
     You say, "abcfgh"
+
     > say delete(abcdefgh, 3, -2)
     You say, "abefgh"
 
@@ -1043,18 +1108,18 @@
   die(<number of times to roll die>, <number of sides on die>[, <show>])
  
   This function simulates rolling dice. It "rolls" a die with a given
-  number of sides, a certain number of times, and sums the results.
+  number of sides, a certain number of times, and adds the results.
   For example, DIE(2, 6) would roll "2d6" - two six-sided dice,
   generating a result in the range 2-12. The maximum number of dice
-  this function will roll in a single call is 20.  If a third argument
-  is given and it's a true value, the result will be a space-seperated
-  list of the individual rolls rather than their sum.
+  this function will roll in a single call is 700.  If <show> is true,
+  the result will be a space-seperated list of the individual rolls rather
+  than their sum.
 
   Examples:
-  > think die(3, 6)
-  6
-  > think die(3, 6, 1)
-  5 2 1  
+    > think die(3, 6)
+    6
+    > think die(3, 6, 1)
+    5 2 1  
 & DIG()
   dig(<name>[, <exit to>[, <exit from>]])
  
@@ -1066,7 +1131,7 @@
 & DIGEST()
   digest(<algorithm>, <string>)
 
-  Returns a checksum (Hash, digest, etc.) of <string> using the given
+  Returns a checksum (hash, digest, etc.) of <string> using the given
   <algorithm>. If the mush is compiled with SSL support (See @config
   compile), <algorithm> can be one of:
 
@@ -1081,18 +1146,22 @@
 
   Returns the distance between two points in the Cartesian
   plane that have coordinates (<x1>, <y1>) and (<x2>, <y2>).
+  
+See also: dist3d()
 & DIST3D()
   dist3d(<x1>, <y1>, <z1>, <x2>, <y2>, <z2>)
 
   Returns the distance between two points in space, with
   coordinates (<x1>, <y1>, <z1>) and (<x2>, <y2>, <z2>).
+  
+See also: dist2d()
 & DIV()
 & FLOORDIV()
   div(<number>, <number>)
   floordiv(<number>, <number>)
  
-  Div returns the integer part of the quotient of the first number
-  divided by the second number.  Floordiv returns the largest integer
+  div() returns the integer part of the quotient of the first number
+  divided by the second number.  floordiv() returns the largest integer
   less than or equal to the quotient of the first number divided by
   the second.  For positive numbers, these are the same thing, but for
   negative numbers they may be different:
@@ -1109,8 +1178,9 @@
 & DOING()
   doing(<player|descriptor>)
 
-  Given the name of a connected player, returns that player's @doing
-  string if they can be seen on the WHO list.
+	When given the name of a connected player or descriptor, doing()
+	returns the player's @doing. If <player> is offline, (or dark, and the
+	caller is mortal), doing() returns #-1.
 
 See also: @poll, @doing, poll()
 & E()
@@ -1123,29 +1193,26 @@
  
   This function returns the evaluated value of <obj>/<attr>, as if
   retrieved via the get_eval() function, if the attribute exists and
-  is readable by you. Otherwise, it evaluates the default case, and
-  returns that. The default case is only evaluated if the attribute
+  is readable by you. Otherwise, it evaluates <default case>, and
+  returns that. <default case> is only evaluated if the attribute
   does not exist or cannot be read.
  
   Example:
     > &TEST me=You have lost [rand(10)] marbles.
     > say edefault(me/Test,You have no marbles.)
     You say "You have lost 6 marbles."
+
     > &TEST me
     > say edefault(me/Test,You have no marbles.)
     You say "You have no marbles."
   
-See also: get(), eval(), ufun(), default(), udefault()
- 
+See also: get(), eval(), ufun(), default(), udefault(), hasattr()
 & EDIT()
   edit(<string>, <search>, <replace>[, ... , <searchN>, <replaceN>])
  
-  This functions in a similar way to the @edit command; instead of
-  taking an attribute from an object, it takes an arbitrary string.
-  It searches the string for <search> and replaces with <replace>,
-  then repeats the process if additional search-replace pairs are
-  given.
-
+  For each given <search> and <replace> pair, edit() replaces all
+  occurances of <search> in <string> with the corresponding <replace>.
+  
   If <search> is a caret (^), <replace> is prepended.
   If <search> is a dollar sign ($), <replace> is appended.
   If <search> is an empty string, <replace> is inserted between
@@ -1153,14 +1220,14 @@
   If <replace> is an empty string, <search> is deleted from the string.
 
   Example:
-  > say [edit(this is a test,^,I think%b,$,.,a test,an exam)]
-  You say "I think this is an exam." 
+    > say [edit(this is a test,^,I think%b,$,.,a test,an exam)]
+    You say "I think this is an exam." 
 
   edit() can not replace a literal single ^ or $. Use regedit() for that.
   
 See also: @edit, regedit()
 & ELEMENT()
-  element(<list>, <item>,<single-character separator>)
+  element(<list>, <item>, <separator>)
   
   This returns the position of <item> in <list>, where <list>'s items
   are separated by <separator>. A wildcard match is done, so this
@@ -1168,20 +1235,22 @@
   required, not optional.
   
   Example:
-    > say [element(this|is|a|test|string,is,|)]
-    You say, "2"
+    > say element(this|is|a|test|string,*st,|)
+    You say, "4"
 
-See also: match(), grab()
+See also: match(), grab(), member()
 & ELEMENTS()
-  elements(<list of words>, <list of numbers>[,<delim>[, <osep>]])
+  elements(<list of words>, <list of numbers>[, <delim>[, <osep>]])
  
   This function returns the words in <list of words> that are in the
-  positions specified by <list of numbers>. Optionally, a list
-  delimiter other than a space can be used.
+  positions specified by <list of numbers>. The <list of words> are
+  assumed to be space-separated, unless a <delim> is given. If <osep> is
+  given, the matching words are separated by <osep>, otherwise by <delim>.
  
   Examples:
     > say elements(Foo Ack Beep Moo Zot,2 4)
     You say "Ack Moo"
+
     > say elements(Foof|Ack|Beep|Moo,3 1,|)
     You say "Beep|Foof"
 
@@ -1189,19 +1258,22 @@
 & ELOCK()
   elock(<object>[/<locktype>], <victim>)
 
-  elock() returns 1 if the <victim> would pass the lock on <object>,
-  and 0 if it would fail. You must control <object>.
+  elock() returns 1 if the <victim> would pass the @lock/<locktype> on
+  <object>, and 0 if it would fail. You must control <object>.
   
-  You can also provide a switch after <object> if you wish to check
-  something other than the basic lock. This can be used to test
-  user-defined locks. elock() can take as many switches as @lock.
+  If no <locktype> is specified, the Basic lock is checked. <locktype>
+  can be any @lock, including "user:" user-defined @locks.
 
-  For example:
-      @lock/drop Dancing Slippers=#0
-      think elock(Dancing Slippers/drop, Princess)
-      > 0
+  Example:
+    > @lock/drop Dancing Slippers=#0
+    > think elock(Dancing Slippers/drop, Princess)
+    0
   
-See also: @lock, locktypes
+    > @lock/user:test map==*Fred|=*George
+    > think elock(map/test,*Snape)
+    0
+
+See also: @lock, locktypes, testlock()
 & EMIT()
 & NSEMIT()
   emit(<message>)
@@ -1210,6 +1282,8 @@
   Sends a message to the room, as per @emit.
 
   nsemit() is a wizard-only variation that works like @nsemit.
+  
+See also: pemit(), remit(), lemit(), oemit(), zemit()
 & ENCODE64()
   encode64(<string>)
 
@@ -1217,7 +1291,7 @@
 
   Requires SSL support; see @config compile.
 
-See also: decode64()
+See also: decode64(), encrypt(), decrypt()
 & ENCRYPT()
   encrypt(<string>, <password>[, <encode>]) 
 
@@ -1248,28 +1322,27 @@
   You can also limit the range of the dbrefs searched by giving
   <begin> and <end>.
 & EQ()
-  eq(<number1>, <number2>)
+  eq(<number>, <number>[, ... , <numberN>])
 
-  Takes two numbers, and returns 1 if they are equal, 0 otherwise.
+  Takes two or more <number>s, and returns 1 if they are all equal,
+  and 0 otherwise.
   
 See also: neq()
 & ESCAPE()
   escape(<string>)
  
-  The ESCAPE() function "escapes out" potentially "dangerous"
+  The escape() function "escapes out" potentially "dangerous"
   characters, preventing function evaluation in the next pass of the
   parser. It returns <string> after adding the escape character ('\')
   at the beginning of the string, and before the following characters:
 
   %  ;  [  ]  {  }  \ ( ) , ^ $
   
-  This function prevents strings entered by players from causing side
-  effects, such as performing an unintended GET() of an attribute. It
-  is only needed when the resulting string will be passed through
-  @force or used as an attribute for an object (like the description
-  of a mail message object).  Since the function preserves the
-  original string, it is, in most cases, a better choice than
-  SECURE().
+  This function prevents code injection in strings entered by players. It
+  is only needed when <string> will be passed through a command or function
+  which will evaluate it again, which can usually be avoided. Since the
+  function preserves the original string, it is, in most cases, a better
+  choice than secure(), but decompose() is often better still.
 
 See also: decompose(), secure()
 & EVAL()
@@ -1277,31 +1350,22 @@
   eval(<object>, <attribute>)
   get_eval(<object>/<attribute>)
  
-  Eval() works the same way as xget(), except that it performs
-  %-substitutions and function evaluation on the attribute before
-  returning the value. eval() changes the enactor (%#) to the object
-  executing the eval (%!). It does not modify the stack (%0-%9), so
-  the attribute being evaled sees the same values for them that the
+  eval() and get_eval() are similar to ufun(), in that they evaluate the 
+  given <attribute> on <object>. However, they change the enactor (%#) to 
+  the object executing the eval (%!). It does not modify the stack (%0-%9),
+  so the attribute being evaled sees the same values for them that the 
   calling code does. Unless you need this behavior, it is better to
   use u() instead, which hides the caller's stack.
 
-    Example:
-      &TEST me=%B%B%B-[name(me)]
-      think xget(me,test)
-      > %B%B%B-[name(me)]
-      think eval(me,test)
-      >    -Shalott
+  Example:
+    > &TEST me=%B%B%B-[name(me)]
+    think eval(me,test)
 
-  Get_eval() does the same thing, except it uses the format of get()
-  instead of xget() -- using a slash rather than a comma to separate
-  the object from the attribute. It is included for TinyMUSH 2.x
-  compatibility.
-  
-See also: get(), u(), xget()
+See also: get(), u(), xget(), edefault()
 & EXIT()
   exit(<object>)
 
-  Returns the dbref of the first exit in a room.
+  Returns the dbref of the first exit in room <object>.
 
   You can get the complete exit list of any room you may examine,
   regardless of whether or not exits are dark.  You can get the
@@ -1314,31 +1378,33 @@
   exp(<number>)
  
   Returns e to the power of <number>.
+  
+See also: e(), power()
 & EXTRACT()
   extract(<list>[, <first>[, <length>[,<delimiter>]]])
 
-  This function returns <length> elements of a list, counting from the
-  <first> element. If <length> is not specified, the default is 1, so
-  extract(list,3) acts like elements(list,3).  If <first> is not
-  specified, the default is the 1, so extract(list) acts like
-  first(list).
+  This function returns <length> elements of <list>, counting from the
+  <first>th element. If <length> is not specified, the default is 1, so
+  extract(<list>,3) acts like elements(<list>,3).  If <first> is not
+  specified, the default is the 1, so extract(<list>) acts like
+  first(<list>).
 
-  For example:
-    think extract(This is a test string,3,2)
-    > a test
+  Example:
+    > think extract(This is a test string,3,2)
+    a test
 
 See also: index(), elements(), grab()
 & FDIV()
   fdiv(<numerator>, <denominator>)
  
-  Returns the quotient of the two numbers. Note that the DIV() and
-  MOD() functions cannot be used on floating point numbers.
+  Returns the quotient of the two numbers. Note that the div() and
+  mod() functions cannot be used on floating point numbers.
 
-See also: div()
+See also: div(), mod()
 & FILTER()
 & FILTERBOOL()
-  filter([<obj>/]<attr>, <list>[,<delimiter>[, <osep>]])
-  filterbool([<obj>]/<attr>, <list>[,<delimiter>[, <osep>]])
+  filter([<obj>/]<attr>, <list>[, <delimiter>[, <osep>]])
+  filterbool([<obj>]/<attr>, <list>[, <delimiter>[, <osep>]])
 
   This function returns the elements of <list> for which a
   user-defined function evaluates to "1", or to a boolean true value
@@ -1346,89 +1412,110 @@
   argument (just as with the ufun() function), and the element of the
   list being tested is passed to that user-defined function as %0.
   
-  Thus, "filter(obj/attr, x1 x2 x3)" is nearly equivalent to "iter(x1
-  x2 x3, switch(ufun(obj/attr, ##),1,##,))" though the iter version
-  may have extra blank spaces.
+  Thus, "filter(<obj>/<attr>, <list>)" is nearly equivalent to 
+  "iter(<list>, switch(ufun(<obj>/<attr>, %i0),1,%i0,))" though the iter
+  version may have extra blank spaces.
   
   Example:
-  
-    > &IS_ODD test=[mod(%0,2)]
-    > say [filter(test/is_odd, 1 2 3 4 5 6)]
+    > &IS_ODD test=mod(%0,2)
+    > say filter(test/is_odd, 1 2 3 4 5 6)
     You say, "1 3 5"
 
 See also: anonymous attributes
 & FINDABLE()
   findable(<object>, <victim>)
  
-  This function returns 1 if <object> can locate <victim>, or 0, if it
+  This function returns 1 if <object> can locate <victim>, or 0 if it
   cannot. If one of the objects does not exist, it will return #-1
-  ARGN NOT FOUND (where N is the argument which is the invalid
-  object).
- 
+  ARGN NOT FOUND (where N is the argument which is the invalid object).
+  
+See also: locate(), loc() 
 & FIRST()
-  first(<list>[,<delimiter>])
+  first(<list>[, <delimiter>])
 
   Returns the first element of a list.
 
 See also: before(), rest(), last()
 & FIRSTOF()
-  firstof(<expr1>, <expr2>[, ... , <exprN>])
+  firstof(<expr>[, ... , <exprN>], <default>)
 
-  Returns the first evaluated expression that is true.  If no
-  arguments are true, then the last argument, <exprN>, is returned as
-  the default expression, whether it is true or false.
+  Returns the first evaluated <expr> that is true. If no <expr> arguments
+  are true, <default> is returned.
 
   The meaning of true or false is dependent on configuration options
   as explained in the 'BOOLEAN VALUES' help topics.
 
-  This function does evaluate each argument while testing, including
-  side-effects, stopping (short-circuits) when the true expression is
-  found.
-
-  > say firstof(0,2)
-  You say, "2"
-  > say firstof(10,11,0)
-  You say, "10"
-  > say firstof(grab(the cat,mommy),grab(in the hat,daddy),#-1 Error)
-  You say, "#-1 Error"
-  > say firstof(get(%#/royal cheese),#-1 This Has No Meaning,0,)
-  You say, ""
+  This function evaluates arguments one at a time, stopping as soon as
+  one is true.
+  
+  Examples:
+    > say firstof(0,2)
+    You say, "2"
+    
+    > say firstof(10,11,0)
+    You say, "10"
+    
+    > say firstof(grab(the cat,mommy),grab(in the hat,daddy),#-1 Error)
+    You say, "#-1 Error"
+    
+    > say firstof(get(%#/royal cheese),#-1 This Has No Meaning,0,)
+    You say, ""
 
 See also: allof(), BOOLEAN VALUES
 & FLAGS()
-  flags(<object>)
-  flags(<object>/<attribute>)
   flags()
+  flags(<object>[/<attribute>])
 
-  Flags returns a string consisting of the flags attached to the
-  object or the attribute on the object. The string is a single word
-  made up of all the appropriate flag letters.
-
-  Given no arguments, this function returns a string consisting of all
-  the flag letters of all the flags the server knows. Note that some
-  flags may not have flag letters, and multiple flags may have the
-  same letter (and will appear twice).
+  With no arguments, flags() returns a string consisting of the flag letters
+  for each flag on the MUSH. Note that some flags have no letter, and
+  mutlple flags may have the same letter (and so will appear multiple times).
+  
+  If an <object> is given, flags() returns 'P', 'T', 'R' or 'E', depending on
+  whether <object> is a player, thing, room, or exit, followed by the flag 
+  letter for each flag set on <object>.
+  
+  With an <object>/<attribute>, the flag letters for each flag set on the
+  given <attribute> are returned.
+  
+  Example:
+    > @create Test
+    > @set Test=no_command puppet
+    > think flags(Test)
+    Tnp
+  
+    > think flags(me/describe)
+    $v
 
-See also: lflags()
+See also: lflags(), list()
 & LFLAGS()
-  lflags(<object>)
-  lflags(<object>/<attribute>)
   lflags()
+  lflags(<object>[/<attribute>])
 
-  Lflags returns a space-separated list consisting of the names of
-  flags attached to the object or the attribute on the object.
+  With an argument, lflags() returns a space-separated list consisting of the
+  names of all the flags attached to <object>, or <object>'s <attribute>.
 
   Given no arguments, this function returns a space-separated list of
-  all flag names known to the server.
+  all flag names known to the server, as per @list/flags.
+  
+  Example:
+    > @create Test
+    > @set Test=no_command puppet
+    > think flags(Test)
+    NO_COMMAND PUPPET
+    
+    > think flags(me/describe)
+    NO_COMMAND VISUAL
 
-See also: flags()
+See also: flags(), list()
 & FLIP()
 & REVERSE()
   flip(<string>)
-  reverse(<string>)
 
-  This function reverses a string. For example, "flip(foo bar baz)"
-  returns "zab rab oof".
+  flip() reverses a string. reverse() is an alias for flip().
+  
+  Example:
+    > say flip(foo bar baz)
+    You say, "zab rab oof"
 
 See also: revwords()
 & FLOOR()
@@ -1436,51 +1523,49 @@
  
   Returns the greatest integral value less than or equal to <number>.
 
-See also: ceil(), bound(), round(), trunc()
+See also: ceil(), bound(), round(), trunc(), floordiv()
 & FMOD()
   fmod(<number>, <divisor>)
 
-  Similar to remainder() but may take floating point arguments. The
-  return value is <number> - n * <divisor>, where n is the quotient of
+  Similar to remainder() but may take floating point arguments. The return
+  value is <number> - n * <divisor>, where n is the quotient of 
   <number> / <divisor>, rounded towards zero. The result has the same
-  sign as <number> and a magnitude less than the magnitude of
-  <divisor>.
+  sign as <number> and a magnitude less than the magnitude of <divisor>.
 
   Example:
-  > think fmod(6.1,2.5)
-  1.1
+    > think fmod(6.1,2.5)
+    1.1
+See also: fdiv(), div(), mod()
 & FOLD()
-  fold([<obj>/]<attr>, <list>[, <base case>[,<delimiter>]])
+  fold([<obj>/]<attr>, <list>[, <base case>[, <delimiter>]])
   
-  This function "folds" a list through a user-defined function,
-  specified by the first argument to fold(), which is analogous to
-  ufun()'s first argument.
+  This function "folds" a list through the user-defined function,
+  set in the specified <obj>/<attribute>.
   
-  If no base case is provided, fold() passes the first element of
+  If no <base case> is provided, fold() passes the first element of
   <list> as %0, and the second element of <list> as %1, to the
   user-defined function. The user-defined function is then called
   again, with the result of the first evaluation being %0, and the
   next (third) element of the list as %1. This is repeated until all
-  the elements of the list have been used.
+  the elements of the list have been used. The result of the last
+  call of <obj>/<attr> is returned.
   
   If a base case is provided, it is passed as %0, and the first
   element of list is passed as %1, to the user-defined function. The
   process for the no-base-case fold() is then used.
   
-  See 'help FOLD2' for examples.
- 
+  See 'help fold2' for examples.
 & FOLD2
  
   Examples:
-  
     > &REP_NUM test=%0[repeat(%1,%1)]
-    > say [fold(test/rep_num,1 2 3 4 5)]
+    > say fold(test/rep_num,1 2 3 4 5)
     You say, "122333444455555"
-    > say [fold(test/rep_num,1 2 3 4 5,List:)]
+    > say fold(test/rep_num,1 2 3 4 5,List:)
     You say, "List:122333444455555"
   
     > &ADD_NUMS test=add(%0,%1)
-    > say [fold(test/add_nums,1 2 3 4 5)]
+    > say fold(test/add_nums,1 2 3 4 5)
     You say, "15"
 
 See also: anonymous attributes
@@ -1488,44 +1573,51 @@
   followers(<object>)
 
   Returns the list of things and players following object. You must
-  control object.
+  control <object>.
+  
+See also: following(), follow, unfollow
 & FOLLOWING()
   following(<object>)
 
   Returns the list of things and players that the object is following.
-  You must control object.
+  You must control <object>.
+  
+See also: followers(), follow, unfollow
 & FOREACH()
   foreach([<object>/]<attribute>, <string>[, <start>[, <end>]])
  
-  Maps a function onto a string.
+  This function is similar to map(), but instead of calling the given
+  <object>/<attribute> for each word in a list, it is called for each
+  character in <string>.
  
-  Each character in <string> has the user-defined function of the
-  first argument performed on it; the character is passed to the
-  function as %0, and its position in the string as %1 (the first
-  character has position 0). The results are concatenated. If a start
-  character is given, everything before that character is copied
-  without passing it to the function, and everything after it until
-  the end of the string or an end character is passed to the
-  function. Anything left after the end character is also copied
-  unevaluated. The start and end characters themselves are not copied.
+  For each character in <string>, <object>/<attribute> is called, with the
+  character passed as %0, and its position in the string as %1 (the first
+  character has position 0). The results are concatenated.
+  
+  If <start> is given, everything before the first occurance of <start> is
+  copied as-is, without being passed to the <object>/<attribute>. If <end>
+  is given, everything after the first occurance of <end> is copied as-is.
+  The <start> and <end> characters themselves are not copied.
  
-Continued in HELP FOREACH2
+  See 'help foreach2' for examples.
 & FOREACH2
-  Examples:
  
-    > &add_one me=[add(%0,1)]
-    > say [foreach(add_one, 54321)]
+  Examples:
+    > &add_one me=add(%0,1)
+    > say foreach(add_one, 54321)
     You say, "65432"
- 
     > say [foreach(add_one, This is #0# number, #, #)]
     You say, "This is 1 number"
+ 
+    > &upper me=ucstr(%0)
+    > say foreach(upper, quiet quiet >shout< quiet, >, <)
+    You say, "quiet quiet SHOUT quiet"
 
-    > &is_alphanum me=[regmatch(%0, \[\[:alnum:\]\])]%b
-    > say [foreach(is_alphanum,jt1o+)]
+    > &is_alphanum me=regmatch(%0, \[\[:alnum:\]\])%b
+    > say foreach(is_alphanum,jt1o+)
     You say, "1 1 1 1 0 "
 
-See also: anonymous attributes
- 
+See also: map(), anonymous attributes
 & FRACTION()
   fraction(<number>)
 
@@ -1535,36 +1627,41 @@
   always return the original <number>, but something close to it.
 
   Examples:
-  > think fraction(.75)
-  3/4
-  > think fraction(pi())
-  348987/111086
-  > think fraction(2)
-  2
+    > think fraction(.75)
+    3/4
+    
+    > think fraction(pi())
+    348987/111086
+    
+    > think fraction(2)
+    2
 & FULLNAME()
   fullname(<object>)
 
-  Fullname() returns the name of object <object>. It is identical to
+  fullname() returns the full name of object <object>. It is identical to
   name() except that for exits, fullname() returns the complete exit
   name, including all aliases.
   
-  >"[fullname(south)]
-  You say, "South;sout;sou;so;s"
+  Example:
+    > say fullname(south)
+    You say, "South;sout;sou;so;s"
 
-  Related functions: NAME(), ACCNAME(), INAME()
+See also: name(), accname(), iname(), alias(), fullalias()
 & FUNCTIONS()
-  functions([<arg>])
+  functions([<type>])
 
-  Returns a space-separated list of the names of functions. If <arg>
+  Returns a space-separated list of the names of functions. If <type>
   is "local", only @functions are listed. If "builtin", only builtin
   functions.  If "all" or omitted, both are returned.
 & GET()
   get(<object>/<attribute>)
 
-  The get() function returns the string stored in an object's
-  attribute.  You may get the attributes of objects you control, the
-  attributes you own on other objects, and publicly accessible
-  attributes.
+  The get() function returns the string stored in an <object>'s <attribute>
+  attribute, without evaluating it. You may get the attributes of objects
+  you control, the attributes you own on other objects, and publicly
+  accessible attributes.
+  
+See also: hasattr(), visible(), ufun(), default(), udefault()
 & GETPIDS()
   getpids(<object>[/<attribute>])
 
@@ -1576,41 +1673,39 @@
 & GRAB()
 & REGRAB()
 & REGRABI()
-  grab(<list>, <pattern>[,<delimiter>])
-  regrab(<list>, <regexp>[,<delimiter>])
-  regrabi(<list>, <regexp>[,<delimiter>])
+  grab(<list>, <pattern>[, <delimiter>])
+  regrab(<list>, <regexp>[, <delimiter>])
+  regrabi(<list>, <regexp>[, <delimiter>])
   
-  This function returns the first word in list which matches the
-  pattern.  For grab(), the pattern is specified as in match(); i.e.,
-  it can contain wildcards. For regrab(), the pattern is a regular
-  expression.  regrabi() is case-insensitive.
+  These functions return the first word in <list> which matches the
+  pattern.  For grab(), <pattern> is a wildcard pattern ('help wildcards').
+  For regrab() and regrabi(), the pattern is a regular expression.
+  regrabi() is case-insensitive.
   
-  Basically, this is a much more efficient way to do: extract(list,
-  match(list, pattern, delimiter), 1, delimiter) or the regular
-  expression variation thereof.
+  Basically, this is a much more efficient way to do:
+    elements(<list>, match(<list>, <pattern>[, <delimiter>])[, <delimiter>])
+  or the regular expression variation thereof.
 
-See also: match(), extract(), element(), elements(), index(), regmatch(),
-  graball()
+See also: graball(), match(), extract(), element(), elements(), regmatch()
 & GRABALL()
 & REGRABALL()
 & REGRABALLI()
-  graball(<list>, <pattern>[,<delim>[, <output separator>]])
-  regraball(<list>, <regexp>[,<delim>[, <output separator>]])
-  regraballi(<list>, <regexp>[,<delim>[, <output separator>]])
+  graball(<list>, <pattern>[, <delim>[, <osep>]])
+  regraball(<list>, <regexp>[, <delim>[, <osep>]])
+  regraballi(<list>, <regexp>[, <delim>[, <osep>]])
   
-  These functions work identically to the grab() and
-  regrab()/regrabi() functions, save that they return all matches, not
-  just the first: They return all words in the <list> which match
-  <pattern>.  If none match, an empty string is returned.
+  These functions work identically to the grab() and regrab()/regrabi()
+  functions, except they return all matches, not just the first:
+  They return all words in the <list> which match <pattern>. If none
+  match, an empty string is returned.
   
   Examples:
-
-  > say graball(This is a test of a test,test)
-  You say "test test"
-  > say graball(This is testing a test,tes*)
-  You say "testing test"
-  > say regraball(This is testing a test,s$)
-  You say "This is"
+    > say graball(This is a test of a test,test)
+    You say "test test"
+    > say graball(This is testing a test,tes*)
+    You say "testing test"
+    > say regraball(This is testing a test,s$)
+    You say "This is"
   
 See also: match(), matchall(), grab(), regmatch()
 & GREP()
@@ -1636,137 +1731,150 @@
 
   grep()/wildgrep()/regrep() are case-sensitive. 
   grepi()/wildgrepi()/regrepi() are case-insensitive.
+  
+See also: lattr(), WILDCARDS
 & GT()
-  gt(<num>, <num>)
+  gt(<number>, <number>[, ... , <numberN>])
 
-  Takes two numbers, and returns 1 if and only if the first is greater
-  than the second, and 0 otherwise.
+  Takes two or more numbers, and returns 1 if and only if each number
+  is greater than the number after it, and 0 otherwise.
+
+See also: gte(), lt(), lte(), eq(), neq()
 & GTE()
-  gte(<num>, <num>)
+  gte(<number>, <number>[, ... , <numberN>])
 
-  Takes two numbers, and returns 1 if and only if the first is greater
-  than or equal to the second, and 0 otherwise.
+  Takes two or more numbers, and returns 1 if and only if each number
+  is greater than or equal to the number after it, and 0 otherwise.
+See also: gt(), lt(), lte(), eq(), neq()
 & HASATTR()
 & HASATTRP()
 & HASATTRVAL()
 & HASATTRPVAL()
-  hasattr(<object>, <attribute name>)
-  hasattrp(<object>, <attribute name>)
-  hasattrval(<object>, <attribute name>)    
-  hasattrpval(<object>, <attribute name>)   
+  hasattr(<object>, <attribute>)
+  hasattrp(<object>, <attribute>)
+  hasattrval(<object>, <attribute>)    
+  hasattrpval(<object>, <attribute>)   
   
-  The hasattr() functions check to see if an object has an attribute.
+  The hasattr*() functions check to see if <object> has a given attribute.
   They return #-1 if the object does not exist or the attribute can't
   be examined by the player. Otherwise, they return 1 if the attribute
   is present and 0 if it is not.
 
-  hasattr() returns 1 if the object has the attribute, 0 if it
-  doesn't.
+  hasattr() checks to see if <attribute> exists on <object> only.
   
-  hasattrp() also checks for attributes inherited from parent objects.
+  hasattrp() also checks for <attribute> on <object>'s parent/ancestor.
 
-  hasattrval() returns 1 if the attribute exists and isn't empty.
+  hasattrval() only returns 1 if <attribute> exists and is non-empty.
   
-  hasattrpval() is hasattrval() but checks parents.
+  hasattrpval() is like hasattrval() but also checks parents.
   
   All four functions will also work with one argument in the form of
   <object>/<attribute>.
 
+See also: visible()
 & HASFLAG()
-  hasflag(<object>[/<attrib>], <flag name>)
- 
-  Returns 1 if the object has the named flag, and 0 if it does not.
-  If the object does not exist, #-1 will be returned. You do not have
-  to control the object.
+  hasflag(<object>[/<attrib>], <flag>)
  
-  Example: hasflag(me, opaque) will return "1" or "0".
-
-  Unlike orflags() and andflags(), hasflag uses the *flag name*, not
-  the single character abbreviation. Many flag names have shorter
-  abbreviations which will also work (W for Wizard, roy for royalty).
+  With no <attrib>, hasflag() returns 1 if <object> has the <flag> flag
+  set. If <attrib> is specified, the attribute is checked for the <flag>
+  attribute flag instead. If the flag is not present, 0 is returned.
   
-  The "flags" ROOM, EXIT, and PLAYER are actually types. If you want
-  to check if an object "has" one of these flags, you must use the
-  HASTYPE() function.
-
-  If an attribute is given, checks to see if the attribute has the
-  given attribute flag. See 'help attribute flags' for attribute flag
-  names.
+  hasflag() will accept a full flag name ("Wizard") or a flag letter ("W").
+  You can check the flags of any object, whether you control them or not.
 
-See also: orlflags(), andlflags(), orflags(), andflags()
+  Example:
+    > think hasflag(me, wizard)
+    1
+  
+See also: orlflags(), andlflags(), orflags(), andflags(), flags(), lflags(),
+  attribute flags, @flag, haspower(), hastype()
 & HASPOWER()
-  haspower(<object>, <power name>)
+  haspower(<object>, <power>)
  
-  Returns 1 if the object has the named power, and 0 if it does not.
-  If the object does not exist, #-1 will be returned.
+  Returns 1 if <object> has the named power, and 0 if it does not.
+  
+  You can check the powers of any object, whether you control it or not.
 
-  You may or may not have to be able to examine the object to use
-  this.
+See also: @power, powers list, hasflag()
 & HASTYPE()
   hastype(<object>, <type list>)
-
-  Returns 1 if the object is of the named type, otherwise 0.  Valid
-  types are: ROOM, EXIT, PLAYER, THING, GARBAGE. You can test to see
-  if the object is one of a number of types by using a space-
-  separated list of types.  If an invalid type is given, #-1 NO SUCH
-  TYPE is returned.
+  
+  Returns 1 if <object> belongs to one of the types given in <type list>,
+  and 0 otherwise. Valid types are PLAYER, THING, ROOM, EXIT and GARBAGE.
+  
+  Example:
+    > @create Test Object
+    > think hastype(test object, PLAYER EXIT)
+    0
+    > think hastype(test object, PLAYER THING)
+    1
+    
+See also: TYPES, type()
 & HIDDEN()
   hidden(<player|descriptor>)
 
-  Returns 1 if the player is hidden, otherwise 0.
-  Can only be called by someone privileged to see hidden players.
-  If you're not, #-1 is returned.
+  If you can see hidden players, this function returns 1 if <player> (or the
+  player connected to <descriptor>) is hidden, and 0 otherwise. If you cannot
+  see hidden players, hidden() returns #-1.
+
+See also: @hide
 & HOME()
   home(<object>)
  
-  Returns the object's 'home'.  This is the home for a player or
-  thing, the drop-to of a room, or source of an exit.
+  Returns the object's 'home', where it is @link'd to. This is the home for a
+  player or thing, the drop-to of a room, or source of an exit.
+  
+See also: @link
 & HOST()
 & HOSTNAME()
   host(<player|descriptor>)
-  hostname(<player|descriptor>)
 
-  Returns the hostname of a player as indicated by WHO.  This may be
-  more reliable that get(<player>/lastsite) if the player has multple
-  connections from different locations, and the function is called
-  with a descriptor argument.
+  Returns the hostname a player is connected from, as shown on the wizard
+  WHO. This may be more reliable that get(<player>/lastsite) if the player
+  has multple connections from different locations, and the function is
+  called with a descriptor argument.
 
   The caller can use the function on himself, but using on any other
   player requires privileged power such as Wizard, Royalty or SEE_ALL.
+  
+  hostname() is an alias for host().
 
 See also: Connection Functions, ipaddr(), ports(), lports()
 & IDLE()
 & IDLESECS()
   idle(<player|descriptor>)
-  idlesecs(<player|descriptor>)
  
   This function returns the number of seconds a player has been idle,
   much as WHO does. <player name> must be the full name of a player,
-  or a player's dbref. Players who are not connected have an idlesecs
-  of "-1", as do dark wizards, when idle() is used on them by a
-  non-priv'ed player.
-
+  or a player's dbref. You can also specify a <descriptor>, useful if a
+  player is connected multiple times, or for connections which are still at
+  the login screen. Players who are not connected have an idle time of "-1",
+  as do dark wizards, when idle() is used on them by a non-priv'ed player.
+  
+  idlesecs() is an alias for idle().
+  
+See also: Connection Functions, conn()
 & IF()
 & IFELSE()
   if(<condition>, <true expression>[, <false expression>])
   ifelse(<condition>, <true expression>, <false expression>)
 
-  These functions evaluate the <condition> and return <true
-  expression> if the <condition> is true, or <false expression> (if
-  provided) if the <condition> is false.
+  These functions evaluate the <condition> and return <true expression> if
+  the <condition> is true, or <false expression> (if provided) if the
+  <condition> is false. Only the returned <expression> is evaluated.
 
-See also: BOOLEAN VALUES, switch()
+See also: BOOLEAN VALUES, switch(), @break
 & INAME()
   iname(<object>)
 
-  iname() returns the name of object <object>, as it would appear if
-  you were inside it. It is identical to name() except that if the
-  object has a NAMEFORMAT or NAMEACCENT attribute, it is used.
+  iname() returns the name of <object>, as it would appear if you were inside
+  it. It is identical to name() except that if the object has a NAMEFORMAT or
+  NAMEACCENT attribute, it is used.
 
   You must be see_all, control <object>, or be inside it to use this
   function.
 
-See also: @nameformat, name(), fullname()
+See also: @nameformat, @nameaccent, name(), fullname(), accname()
 & INC()
   inc(<integer>)
   inc(<string-ending-in-integer>)
@@ -1774,65 +1882,62 @@
   Inc returns the integer plus 1. If given a string that ends in an
   integer, it increments only the final integer portion. That is:
 
-  > think inc(3)
-  4
-  > think inc(hi3)
-  hi4
-  > think inc(1.3.3)
-  1.3.4
-  > think inc(1.3)
-  1.4
+  Examples:
+    > think inc(3)
+    4
+    
+    > think inc(hi3)
+    hi4
+    
+    > think inc(1.3.3)
+    1.3.4
 
   Note especially the last example, which will trip you up if you use
   floating point numbers with inc() and expect it to work like add().
 
-See also: dec()
+See also: dec(), add(), sub()
 & INDEX()
-  index(<list>,<character>, <first>, <length>)
+  index(<list>, <character>, <first>, <length>)
   
-  This function is similar to EXTRACT(), except that it requires four
-  arguments, while EXTRACT() uses defaults for its arguments if they
+  This function is similar to extract(), except that it requires four
+  arguments, while extract() uses defaults for its arguments if they
   aren't given. The function returns <length> items starting from the
-  <first> position. Trailing spaces are trimmed. The comma cannot be
-  used as the <character> separator unless it's escaped with a \.
+  <first> position. Trailing spaces are trimmed.
   
   Examples:
-  
-    > say [index(Cup of Tea | Mug of Beer | Glass of Wine, |, 2, 1)]
+    > say index(Cup of Tea | Mug of Beer | Glass of Wine, |, 2, 1)
     You say, "Mug of Beer"
 
-    > say [index(%rtoy boat^%rblue tribble^%rcute doll^%rred ball,^,2,2)]
+    > say index(%rtoy boat^%rblue tribble^%rcute doll^%rred ball,^,2,2)
     You say, "
     blue tribble^
     cute doll"
 
 See also: extract(), elements(), grab()
 & INSERT()
-  insert(<list>, <position>, <new item>[,<single-character separator>])
+  insert(<list>, <position>, <new item>[, <delim>])
 
   If <position> is a positive integer, this inserts <new item> BEFORE
-  the item at <position> from the left in <list>.
-
-  That means that <new item> then becomes the <position>th element of
-  <list>. If a separator is not given, a space is assumed. Null items
-  are counted when determining position, as in 'items()'.
-
+  the item at <position> from the left in <list>. That means that
+  <new item> then becomes the <position>th element of <list>. 
+  
   If <position> is a negative integer, this inserts <new item> AFTER
   the item at the absolute value of <position> from the RIGHT in
-  <list>.
-
-  This is the same as reversing the list before inserting <new item>,
+  <list>. This is the same as reversing the list before inserting <new item>,
   and then reversing it again into correct order.  For example, when
   <position> is -1, <new item> will be the last in the list; when
   <position> is -2, <new item> will be the second item from the right,
   and so on.
   
+  If a <delim> is not given, a space is assumed. Null items are counted
+  when determining position, as in 'items()'.
+	  
   Examples:
-    > say [insert(This is a string,4,test)]
+    > say insert(This is a string,4,test)
     You say, "This is a test string"
-    > say [insert(one|three|four,2,two,|)]
+    > say insert(one|three|four,2,two,|)
     You say, "one|two|three|four"
-    > say [insert(meep bleep gleep,-3,GOOP)]  
+    > say insert(meep bleep gleep,-3,GOOP)
     You say, "meep GOOP bleep gleep"
 
 & ISDAYLIGHT()
@@ -1843,7 +1948,7 @@
 & ISDBREF()
   isdbref(<string>)
  
-  This function returns 1 if the string is a valid object dbref (or
+  This function returns 1 if <string> is a valid object dbref (or
   object id), and 0 if the string is not a valid object dbref/objid.
  
 See also: DBREFS, isobjid()
@@ -1870,7 +1975,7 @@
   This function returns 1 if the string is a valid object id, and 0 if
   the string is not a valid object id.
   
-  See also: DBREFS, isdbref(), objid()
+See also: DBREFS, isdbref(), objid()
 & ISWORD()
   isword(<string>)
   
@@ -1878,10 +1983,10 @@
   or 0, if any character isn't a letter.  Case does not matter.
     
 & ITEMS()
-  items(<list>,<single-character separator>)
+  items(<list>, <delim>)
 
-  items() counts the number of items in a list using an arbitrary
-  (required) separator. Null items are counted, so:
+  items() counts the number of items in a list using an arbitrary <delim>.
+  Null items are counted, so:
 
         items(X|X,|)     => 2     (2 X items)
         items(X||X,|)    => 3     (2 X items and 1 null item)
@@ -1890,12 +1995,13 @@
         items(,|)        => 1     (a single null item)
 
    Another way to think about this is that items() counts the number
-   of delimiters in the string, and adds 1.
-
+   of times <delim> appears in <list>, and adds 1.
+   
+See also: words()
 & ITEMIZE()
 & ELIST()
-  itemize(<list>[,<delim>[, <conjunction>[, <punctuation>]]])
-  elist(<list>[, <conjunction>[,<delim>[, <output delim>[, <punctuation>]]]])
+  itemize(<list>[, <delim>[, <conjunction>[, <punctuation>]]])
+  elist(<list>[, <conjunction>[, <delim>[, <osep>[, <punctuation>]]]])
 
   These functions take the elements of <list> (separated by <delim> or
   a space by default), and:
@@ -1903,67 +2009,66 @@
    If there's two, return <e1> <conjunction> <e2>
    If there's more than two, return <e1><punc> <e2><punc> ... <conj> <en>
    
-  The default <conjunction> is "and", default punctuation is ","
+  elist() uses <osep> after <punc>/<conj> instead of a space.
+  The default <conjunction> is "and", default punctuation is ",".
   Examples:
-    > say [itemize(eggs)] * [itemize(eggs bacon)]
+    > say itemize(eggs) * [itemize(eggs bacon)]
     You say, "eggs * eggs and bacon" 
-    > say [itemize(eggs bacon spam)]
+    > say itemize(eggs bacon spam)
     You say, "eggs, bacon, and spam"
-    > say [itemize(eggs bacon spam, ,&,;)]
+    > say itemize(eggs bacon spam, ,&,;)
     You say, "eggs; bacon; & spam"
 & ITER()
 & PARSE()
-  iter(<list>, <pattern>[,<delimiter>[, <output separator>]])
-  parse(<list>, <pattern>[,<delimiter>[, <output separator>]])
+  iter(<list>, <pattern>[, <delimiter>[, <output separator>]])
   
-  This works in a manner very similar to @map, except that it returns
-  a string directly.  <list> is a space-separated list of words, and
-  <pattern> is what will be "mapped" onto each element of the list,
-  with the token "##" being replaced successively by the next word in
-  the list, and the token "#@" being replaced by the word's position
-  in the list (also see 'help itext()' and see 'help inum()').  The
-  result is concatenated and returned as a space separated list.  This
-  is similar to @dolist, but the results are made into a list rather
-  than executed.
-
-  The list may be <delimiter>-separated.
-
-  By default, the return list will be space-separated. However, by
-  including the output separator (which requires explicitly including
-  the delimiter), you can have it separated by any string.
+  For each word in <list>, iter() evaluates <pattern> once, and returns a
+  list of the results of those evaluations. Words in <list> are separated
+  by <delimiter>, if given, and spaces if not. Words in the resulting list
+  are separated by the given <ouput separator>, or the delimiter if no
+  output separator is used.
+  
+  Prior to each evaluation, every occurrence of the string "##" in <pattern>
+  is replaced with the current word from <list>. However, because this 
+  replacement occurs before substitution, it cannot be used well in nested
+  iter()s, and should not be used on user input or untrusted <list>s, as the
+  word will be evaluated. Instead, you can use the %iX substitution, or the 
+  itext() function.
+  
+  The string "#@" will be replaced with the position of the current word
+  in <list>. Like "##", the replacement occurs before substitution. Use
+  the inum() function for nested iter()s.
+  
+  If you nest iter()s, ## and #@ refer to the first/outermost iter(). The
+  ilev() function can be used to get the current iter() nesting level.
 
-Continued in HELP ITER2
+  See 'help iter2' for examples.
 & ITER2   
-  parse() is a synonym for iter(). If you nest iters, ## and #@ refer
-  to the first iter(). See 'help ITEXT()' and 'help INUM()' for how to
-  retrieve their values for any nested iter. See 'help MAP()' for a
-  similar function.
-
-  Note that ## and #@ are replaced before evaluation, so the word will
-  be evaluated, which can be a problem when iter()ing on an untrusted
-  list.  iter-with-itext or map() should be preferred to iter-with-##
-  whenever you're iterating over user-provided values.
-
-  > say [iter(This is a test string., [strlen(##)])]
-  You say, "4 2 1 4 7"
+  Examples:
+    > say iter(This is a test string., strlen(%i0))
+    You say, "4 2 1 4 7"
   
-  > say [iter(lnum(5), mul(add(##,##),2))]
-  You say, "0 4 8 12 16"
+    > say iter(lnum(5), mul(add(##,#@),2))
+    You say, "2 6 10 14 18"
   
-  > say [iter(lexits(here), [name(##)] (owned by [name(owner(##))]))]
-  You say, "South (owned by Claudia) North (owned by Roy)"
+    > say iter(lexits(here), name(##) (owned by [name(owner(##))]))
+    You say, "South (owned by Claudia) North (owned by Roy)"
   
-  > &STRLEN_FN me=[strlen(%0)]
-  > say [iter(This is a test string., [u(STRLEN_FN, ##)])]
-  You say, "4 2 1 4 7"
+    > &STRLEN_FN me=strlen(%0)
+    > say iter(This is a test string., u(STRLEN_FN, %i0))
+    You say, "4 2 1 4 7"
 
- This example could be replaced by the use of map() like so:
-  > say [map(strlen_fun, This is a test string)]
+  This example could be replaced by the use of map() like so:
+    > say map(strlen_fun, This is a test string)
 
-  > say [iter(lnum(3), ##, ,%r)]
-  You say, "0
-  1
-  2"
+    > say iter(lnum(3), ##, ,%r)
+    You say, "0
+    1
+    2"
+  
+  parse() is an alias for iter().
+  
+See also: itext(), inum(), ilev(), map(), @dolist
 & ILEV()
 & ITEXT()
 & INUM()
@@ -1974,24 +2079,27 @@
   inum(<n>)
 
   These functions, when called within an iter(), return the equivalent
-  of ## (itext) or #@ (inum), with reference to the nth more outermost
-  iter(), where n=0 refers to the current iter(), n=1 to an iter() in
-  which the current iter() is nested, etc. %iX is shorthand for
-  itext(X) (up to itext(9).  ilev() returns the current nesting depth,
+  of ## (itext) or #@ (inum), with reference to the <n>th more outermost
+  iter(), where <n>=0 refers to the current iter(), <n>=1 to an iter() in
+  which the current iter() is nested, etc. %i<n> is shorthand for
+  itext(<n>) (up to itext(9)).  ilev() returns the current nesting depth,
   or -1 if it is outside an iter().  Thus, itext(ilev()) will return
   the ## of the outermost iter().
 
-  > say [iter(red blue green,iter(fish shoe, #@:##))]
-  You say, "1:red 1:red 2:blue 2:blue 3:green 3:green"
+  Examples:
+    > say iter(red blue green, iter(fish shoe, #@:##))
+    You say, "1:red 1:red 2:blue 2:blue 3:green 3:green"
   
-  > say [iter(red blue green,iter(fish shoe, [inum(ilev())]:[itext(1)]))]
-  You say, "1:red 1:red 2:blue 2:blue 3:green 3:green"
+    > say iter(red blue green, iter(fish shoe, inum(ilev()):[itext(1)]))
+    You say, "1:red 1:red 2:blue 2:blue 3:green 3:green"
 
-  > say [iter(red blue green,iter(fish shoe, [inum(0)]:[itext(0)]))]
-  You say, "1:fish 2:shoe 1:fish 2:shoe 1:fish 2:shoe"
+    > say iter(red blue green,iter(fish shoe, inum(0):[itext(0)]))
+    You say, "1:fish 2:shoe 1:fish 2:shoe 1:fish 2:shoe"
   
-  > say [iter(red blue green,iter(fish shoe, %i1:%i0))]
-  You say, "red:fish red:shoe blue:fish blue:shoe green:fish green:shoe"
+    > say iter(red blue green,iter(fish shoe, %i1:%i0))
+    You say, "red:fish red:shoe blue:fish blue:shoe green:fish green:shoe"
+  
+See also: iter()
 & IPADDR()
   ipaddr(<player|descriptor>)
 
@@ -2005,97 +2113,101 @@
 
 See also: Connection Functions, hostname(), ports(), lports()
 & LAST()
-  last(<list>[,<delimiter>])
+  last(<list>[, <delimiter>])
   
-  Returns the last element of a list.
+  Returns the last element of a list. Elements in <list> are separated by
+  <delimiter>, if given, or by a space if not.
 
-See also: first(), rest()
+See also: first(), rest(), before(), after()
 & LATTR()
 & LATTRP()
-  lattr(<object>[/<attribute pattern>][, <delim>])
-  lattrp(<object>[/<attribute pattern>][, <delim>])
+  lattr(<object>[/<attribute pattern>][, <output separator>])
+  lattrp(<object>[/<attribute pattern>][, <output separator>])
  
-  Returns a delim-separated list of the attribute names on the object
-  that you are permitted to examine. To see the complete list, you
-  must either be a Wizard or Royalty, own the object, have the See_All
-  power, or have the object set VISUAL in order to use this function
-  on the object. The delimiter defaults to space if not given.
+  Returns a list of all the attributes on <object> which you can see, and
+  which match the wildcard <attribute pattern>. If no <attribute pattern> is
+  given, it defaults to "*". Note that this does not include branches in
+  attribute trees; you must use the "**" wildcard to include those.
   
-  If a wildcarded attribute pattern is provided, only attribute names
-  matching that pattern will be returned. lattr() uses the same
-  wildcards as examine (?, *, **).
+  The resulting list will be separated by <output separator>, or a space if
+  no separator is given.
 
   lattrp() also includes attributes inherited from parents.
 
-See also: nattr(), examine
+See also: nattr(), hasattr(), examine, wildcards
 & NATTR()
 & NATTRP()
 & ATTRCNT()
 & ATTRPCNT()
-  nattr(<object>[/<attribute-pattern>])
-  nattrp(<object>[/<attribute-pattern>])
-  attrcnt(<object>[/<attribute-pattern>]) 
-  attrpcnt(<object>[/<attribute-pattern>]) 
+  nattr(<object>[/<attribute pattern>])
+  nattrp(<object>[/<attribute pattern>])
 
-  This function (known by two names) returns the number of attributes
-  on the object that you are permitted to examine.  This function is
-  considerably faster than words(lattr()) and doesn't suffer from
-  buffer length constraints.  It's designed primarily for statistical
-  purposes.
+  nattr() returns the number of attributes on <object> that you can see
+  which match the given <attribute pattern>. It is considerably faster
+  than words(lattr()) and doesn't suffer from buffer length constraints.
+  It's designed primarily for statistical purposes.
 
-  nattrp() and attrpcnt() also count matching attributes on the parent.
+  nattrp() also counts matching attributes on the parent. attrcnt() and
+  attrpcnt() are aliases.
 
-See also: lattr()
+See also: lattr(), hasattr()
 & LCON()
   lcon(<object>)
 
-  Returns a list of the dbrefs of contents in a container.
+  Returns a list of the dbrefs of objects which are located in <object>.
 
-  You can get the complete contents of any container you may examine,
+  You can get the complete contents of any object you may examine,
   regardless of whether or not objects are dark.  You can get the
   partial contents (obeying DARK/LIGHT/etc.) of your current location
   or the enactor (%#).  You CANNOT get the contents of anything else,
   regardless of whether or not you have objects in it.
+  
+  When used on exits, this function returns #-1.
 
 See also: lexits(), lplayers(), con(), next(), lvcon()
 & LCSTR()
   lcstr(<string>)
 
   Returns <string> with all letters converted to lowercase.
-  Example: lcstr(Foo BAR bAz) returns "foo bar baz"
+  
+  Example:
+    > say lcstr(Foo BAR bAz)
+    You say, "foo bar baz"
 
 See also: capstr(), ucstr()
 & LDELETE()
-  Ldelete(<list>, <position(s)>[,<single-character separator>])
+  Ldelete(<list>, <position(s)>[, <delimiter>])
   
-  This deletes the item(s) at <position(s)> in the list. If a
-  separator character is not given, a space is assumed. Null items are
-  counted, as in 'items()'. Positions are numeric and must be
-  separated by spaces.
+  This deletes the item(s) at <position(s)> in the list. If a delimiter is
+  not given, a space is assumed. Null items are counted, as in 'items()'.
+  Positions are numeric and must be separated by spaces.
   
   Examples:
-    > say [ldelete(This is a long test string,4)]
+    > say ldelete(This is a long test string,4)
     You say, "This is a test string"
-    > say [ldelete(lemon|orange|apple,2,|)]
+    > say ldelete(lemon|orange|pear|apple,2 3,|)
     You say, "lemon|apple"
+See also: delete(), remove()
 & LEFT()
   left(<string>, <length>)
 
-  Returns the first <length> characters from string.
+  Returns the first <length> characters from <string>.
 
-See also: right(), mid()
+See also: right(), mid(), ljust()
 & NSLEMIT()
 & LEMIT()
   lemit(<message>)
   nslemit(<message>)
 
-  Sends a message to the outermost room, as per @lemit.
+  lemit() emits a message in the caller's outermost room, as per @lemit.
 
   nslemit() is a wizard-only variation that works like @nslemit.
+  
+See also: @lemit, remit()
 & LETQ()
-  letq([<reg1>, <value1>,...<regN>, <valueN>,] <expr>)
+  letq([<reg1>, <value1>[, ... , <regN>, <valueN>,] <expr>)
 
-  letq() saves the current values of the given q-registers, sets them
+  letq() saves the current values of the given q-<reg>isters, sets them
   to new values, evaluates <expr> and then restores the saved
   registers.  It does not restore registers that are not listed. None
   of the values can see the updated contents of the registers -- they
@@ -2105,12 +2217,12 @@
 
   Example:
 
-    > think [setr(A, 1)]:[letq(A, 2, %qA)]:%qA
+    > think setr(A, 1):[letq(A, 2, %qA)]:%qA
     1:2:1
 
 See also: setq(), setr(), localize(), ulocal()
 & LEXITS()
-  lexits(<object>)
+  lexits(<room>)
 
   Returns a list of the dbrefs of exits in a room.
 
@@ -2122,44 +2234,48 @@
 
 See also: lcon(), exit(), next(), lvexits()
 & LJUST()
-  ljust(<string>, <length>[,<fill>])
+  ljust(<string>, <length>[, <fill>])
   
-  This function pads a string with trailing characters
-  ("left-justifies") so it is <length> long. If <string> is longer
-  than <length>, the <string> is returned; it is not truncated. If
-  <fill> is not specified, a space is used.
+  This function pads a string with trailing characters ("left-justifies") 
+  so it is <length> long. If <string> is longer than <length>, the <string>
+  is returned; it is not truncated. If <fill> is not specified, a space is
+  used. <fill> can be more than one character in length.
   
   Examples:
   
-    > say [ljust(foo,6)]
+    > say ljust(foo,6)
     You say, "foo   "
   
     > say %r0[ljust(foo,6,-)]7%r01234567
     You say, "
     0foo---7
     01234567"
+    
+    > say ljust(foo,12,=+)
+    You say, "foo=+=+=+=+="
 
-See also: align(), center(), rjust()
+See also: align(), center(), rjust(), left()
 & LINK()
-  link(<name>, <destination>[, <preserve>])
+  link(<object>, <destination>[, <preserve>])
  
-  This function links object <name> to <destination>. While normally
-  used on exits, it has all of the other capabilities of @link as
-  well.  It returns nothing. If the optional third argument is true,
-  acts like @link/preserve.
+  This function links <object> to <destination>. While normally used on
+  exits, it has all of the other capabilities of @link as well.  It returns
+  nothing. If the optional third argument is true, acts like @link/preserve.
 
-  This is a side-effect function and may not be enabled on some MUSHes.
+See also: @link, open()
 & LIST()
   list(<option>)
  
   This function takes the same arguments as the @list command, and
   returns the same things.
+  
+See also: @list, flags(), lflags(), config(), functions()
 & LIT()
   lit(<string>)
 
-  This function returns the string literally - without even squishing
-  spaces, and without evaluating *anything*. This can be useful for
-  writing ASCII maps with spaces or whatever.
+  This function returns <string> literally - without even squishing spaces, 
+  and without evaluating *anything*. This can be useful for writing ASCII 
+  maps with spaces or whatever.
 
   It can be a bit tricky to get a literal string with spaces into an
   attrib, however, since spaces are usually squished in setting an
@@ -2173,8 +2289,10 @@
     near       far
 
   Leaving out the {}'s will not work in the above.
+  
+See also: decompose()
 & LMATH()
-  lmath(<op>, <list>[,<delim>])
+  lmath(<op>, <list>[, <delim>])
 
   This function performs generic math operations on <list>, returning
   the result. Each element of the list is treated as one argument to
@@ -2182,24 +2300,29 @@
   3).  Using @function, one can easily write ladd, lsub, etc as per
   TinyMUSH.
 
-  Supported <op>'s are: add and band bor bxor dist2d dist3d div fdiv
-  max mean median min modulo mul nand nor or remainder stddev sub xor
+  Supported <op>'s are:
+  add and band bor bxor dist2d dist3d div eq fdiv gt gte lt lte max mean
+  median min modulo mul nand neq nor or remainder stddev sub xor
 
   Examples:
-  >think lmath(add, 1|2|3, |)
-  6
-  >think lmath(max, 1 2 3)
-  3
-  >&FUN_FACTORIAL me=[lmath(mul,lnum(1,%0))]
-  >think u(fun_factorial,5)
-  120
+    > think lmath(add, 1|2|3, |)
+    6
+    
+    > think lmath(max, 1 2 3)
+    3
+    
+    > &FUN_FACTORIAL me=lmath(mul,lnum(1,%0))
+    > think u(fun_factorial,5)
+    120
 & LN()
   ln(<number>)
  
   Returns the natural log of <number>.
+  
+See also: log()
 & LNUM()
   lnum(<number>)
-  lnum(<start number>, <end number>[, <output separator>])
+  lnum(<start number>, <end number>[, <output separator> [, <step>]])
 
   With one argument, lnum returns a list of numbers, from 0 to <number
   - 1>.  For example, lnum(4) returns the list "0 1 2 3". This is
@@ -2211,87 +2334,120 @@
   With three arguments, the output is separated by the separator given
   in the third argument. lnum(1,4,|) => 1|2|3|4
 
+  A fourth argument dictates the step. By default, the step is 1.
+  lnum(1,10,%b,2) -> 1 3 5 7 9
+  lnum(0,10,%b,2) -> 0 2 4 6 8 10
+
 & LOC()
   loc(<object>)
   
-  Loc returns the dbref of the location that object is at.  The object
-  has to either be yours or be in the same room as you to work. The
-  location of an exit is its destination (the source of an exit is its
-  home). The location of a room is its drop-to (if one is not set,
-  then the location is #-1).
+  For things and players, loc() returns the dbref of the object which
+  contains <object>. For exits, it returns the destination (the source is
+  an exits home()). For rooms, it returns the drop-to, if one is set, or 
+  #-1 otherwise.
+  
+  You must be able to examine <object>, or be near it, for this function
+  to work.
+  
+  You can also get the location of the enactor using the %L substitution,
+  whether you are near to/can examine it or not.
+  
+See also: locate(), rloc(), home()
 & LOCALIZE()
   localize(<code>)
 
-  Localize() saves the q-registers, evaluates its argument, and restores
-  the registers afterwards. It has much the same relation to s() that
-  ulocal() does to u(), except localize()'s argument is only evaluated
-  once, instead of twice like s()'s. Useful in @functions or to wrap around
-  fragments of code too small to go into another attribute.
+  localize() saves the q-registers, evaluates its argument, and restores
+  the registers afterwards. It has the same effect as ulocal(), but doesn't
+  require setting the code into an attribute. 
 
   Example:
-  > say [setr(0, Outside)]-[s(\[setr(0, Inside)\])]-%q0
-  You say, "Outside-Inside-Inside"
-  > say [setr(0, Outside)]-[localize(setr(0, Inside))]-%q0
-  You say, "Outside-Inside-Outside"
+    > say setr(0, Outside)-[setr(0, Inside)]-%q0
+    You say, "Outside-Inside-Inside"
+  
+    > &INSIDE me=setr(0,Inside)
+    > say setr(0, Outside)-[ulocal(INSIDE)]-%q0
+    You say, "Outside-Inside-Outside"
 
-See also: letq(), setq(), setr(), r(), ulocal(), uldefault(), s()
+    > say setr(0, Outside)-[localize(setr(0, Inside))]-%q0
+    You say, "Outside-Inside-Outside"
+
+See also: letq(), setq(), setr(), r(), ulocal(), uldefault()
 & LOCATE()
   locate(<looker>, <name>, <parameters>)
  
-  This function attempts to find the number called <name> relative to
-  <looker>. You must control <looker> or have the See_All power.  This
-  is a bit like the NUM() function, but with a wider, controllable
-  "range".
- 
+  This function attemps to find an object called <name>, relative to
+  the object <looker>. It's similar to the num() function, but you can
+  be more specific about which type of object to find, and where to look
+  for it. You must control <looker> or have the See_All power to use this
+  function.
+  
+  <parameters> is a string of characters which control the type of the object
+  to find, and where (relative to <looker>) to look for it.
+  
   You can control the preferred type of the match with:
-    E   -   Exits
-    L   -   Unlocked exits preferred over locked exits
-    N   -   No type (this is the default)
-    P   -   Players
-    R   -   Rooms
-    T   -   Things
-    F   -   Return #-1 if what's found is of a different type than the
-            preferred one.
-    X   -   Never return #-2. Use the last dbref found if the match is  
-            ambiguous.
- 
- If you specify more than one type, any will be preferred. Unless you
-  specify an F option, if an object of a different type is found and
-  none of the preferred type are, the found object will be returned.
- 
-  (Read "help locate2" for more.)
- 
+    E - Exits
+    L - Unlocked exits preferred over locked exits
+    N - No type (this is the default)
+    P - Players
+    R - Rooms
+    T - Things
+    F - Return #-1 if what's found is of a different type than the
+        preferred one.
+    X - Never return #-2. Use the last dbref found if the match is  
+        ambiguous.
+
+  If type(s) are given, locate() will attempt to find an object with one of
+  the given types first. If none are found, it will attempt to find any type
+  of object, unless 'F' is specified, in which case it will return #-1.
+  
+  Continued in 'help locate2'.
 & LOCATE2
  
   You can control where to look with:
-    a   -   Absolute match (look for #<object>)
-    c   -   Exits carried by <looker>
-    e   -   Exits in <looker>'s location
-    h   -   "here"  (the location of <looker>)
-    i   -   Inventory of <looker>
-    l   -   Location (container) of <looker>
-    m   -   "me"  (<looker> itself)
-    n   -   Neighbors (other objects in same location as <looker>)
-    p   -   Player names prefixed by '*'
-    y   -   Player names with or without a '*' prefix
-    z   -   English-style matching (my 2nd book) of <name>
-    *   -   All of the above (try a complete match)
- 
-Just string all the parameters together, without separating them by
-spaces, i.e.  LOCATE(#100, Test, Tn) would check #100's neighbors for
-an object named "Test", preferring a thing over other types.
+    a - Absolute match (check to see if <name> is a dbref)
+    c - Exits in the room <looker>
+    e - Exits in <looker>'s location
+    h - If <name> is "here", return <looker>'s location
+    i - Match <name> against the names of objects in <looker>'s inventory
+    l - Match <name> against the name of <looker>'s location
+    m - If <name> is "me", return <looker>'s dbref
+    n - Match <name> against the names of objects in <looker>'s location
+    p - If <name> begins with a *, match the rest against player names
+    y - Match <name> against player names whether it begins with a * or not
+    z - English-style matching (my 2nd book) of <name> (see 'help matching')
+    * - All of the above (try a complete match)
  
+  Just string all the parameters together, without separating them by spaces.
+  
+  See 'help locate3' for examples.
+& LOCATE3
+
+  Examples:
+  Find the dbref of the player whose name matches %0, or %#'s dbref if %0 is
+  "me".
+  > think locate(%#, %0, PFym)
+  'PF' matches objects of type 'player' and nothing else, 'm' checks for the
+  string "me", and 'y' matches the names of players.
+  
+  
+  Find the dbref of an object near %# called %0, including %# himself and his
+  location. Prefer players or things, but accept rooms or exits if no players
+  or things are found.
+  > think locate(%#, %0, PThmlni)
+  This prefers 'P'layers or 'T'hings, and compares %0 against the strings
+  "here" and "me", and the names of %#'s location, his neighbours, and his
+  inventory.
+
+See also: num(), rnum() 
 & LOCK()
   lock(<object>[/<locktype>][, <new value>])
 
-  lock() returns the text string equivalent of the lock on an object
-  that you control. You can also provide a locktype (e.g. "enter",
-  "use", etc.)  switch after the object, if you want to check
-  something other than the regular lock.  If a new value is specified,
-  it will attempt to change the lock before reporting it.
-
-  This is a side-effect function and may not be enabled on some
-  MUSHes.
+  lock() returns the text string equivalent of the @lock on <object>.
+  <locktype> can be any valid switch for @lock ("Enter", "user:foo", etc)
+  and defaults to "Basic". You must be able to examine the lock.
+  
+  If a <new value> is given, lock() attempts to change the lock as @lock
+  would. You must control the object..
  
 See also: @lock, locktypes, elock(), lockflags(), llockflags(), lset(),
   llocks(), lockowner()
@@ -2303,21 +2459,23 @@
   llocks(), aliased locks(), list locks set on <object>, including
   user-defined locks (prefixed with USER:)
 
-  > @lock me==me
-  > @lock/use me==me
-  > @lock/user:itsme me==me
-  > th llocks(me)
-  Basic USER:ITSME Use
+  Example:
+    > @lock me==me
+    > @lock/use me==me
+    > @lock/user:itsme me==me
+    > th llocks(me)
+    Basic USER:ITSME Use
 
 See also: lock(), lset(), lockflags(), llockflags(), lockowner()
 & LOCKFLAGS()
   lockflags(<object>[/<locktype>])
   lockflags()
 
-  lockflags() returns a string consisting of the flags attached to the
-  specified lock on the object. The string is a single word made up of
-  all the appropriate flag letters.
-
+  If an <object> is given, lockflags() returns a string consisting of the
+  one-character abbreviations for all the lock flags on <object>'s <locktype>
+  lock, or Basic lock if no locktype is given. You must be able to examine
+  the lock.
+  
   Given no arguments, this function returns a string consisting of all
   the flag letters the server knows.
 
@@ -2326,11 +2484,12 @@
   llockflags(<object>[/<locktype>])
   llockflags()
 
-  llockflags returns a space-separated list consisting of the names of
-  flags attached to the specified lock on the object.
-
+  If an <object> is given, llockflags() returns a space-separated list of
+  the lock flags on <object>'s <locktype> lock, or Basic lock if no
+  locktype is given. You must be able to examine the lock.
+  
   Given no arguments, this function returns a space-separated list of
-  all flag names known to the server.
+  all the names of all lock flags known to the server.
 
 See also: lockflags(), lset(), lock(), llocks(), lockowner()
 & LOCKOWNER()
@@ -2347,6 +2506,8 @@
   This functions sets or clears flags on locks.
   
   See 'help @lset' for more information on what flags are available.
+  
+See also: lockflags(), llockflags(), lock(), lockowner()  
 & LOG()
   log(<number>[, <base>])
  
@@ -2358,10 +2519,12 @@
 & LPARENT()
   lparent(<object>)
   
-  This function returns a list consisting of the object's db# (as per
-  num()), the db# of its parent, grandparent, greatgrandparent, etc.
+  This function returns a list consisting of <object>'s dbref (as per
+  num()), the dbref of its parent, grandparent, greatgrandparent, etc.
   The list will not, however, show parents of objects which the player
-  is not privileged to examine.
+  is not privileged to examine. Ancestor objects are not included.
+  
+See also: parent(), children(), PARENTS, ANCESTORS
 & LPLAYERS()
   lplayers(<object>)
 
@@ -2382,7 +2545,7 @@
   lpos(<string>, <character>)
 
   This function returns a list of the positions where <character>
-  occupies in <string>, with the first character of the string being
+  appears in <string>, with the first character of the string being
   0. Note that this differs from the pos() function, but is consistent
   with other string functions like mid() and delete().
 
@@ -2390,10 +2553,10 @@
   not found anywhere in <string>, an empty list is returned.
 
   Example:
-  > say lpos(a-bc-def-g, -)
-  You say, "1 4 8"
+    > say lpos(a-bc-def-g, -)
+    You say, "1 4 8"
 
-See also: pos()
+See also: pos(), member(), match()
 & LSEARCH()
 & NLSEARCH()
 & SEARCH()
@@ -2408,11 +2571,12 @@
   nchildren(<object>)
  
   This function is similar to the @search command, except it returns
-  just a list of dbref numbers. It is computationally expensive, and
-  costs 100 pennies to perform. The function must have at least three
-  arguments.  Wizards can specify "all" or <player> for the <player>
-  field; mortals must use "me". If you do not want to restrict
-  something, use "none" for <class> and/or <restriction>.
+  just a list of dbref numbers. Some uses are computationally expensive,
+  and cost 100 pennies; see 'help @search' for details. The function must
+  have at least three arguments.  Wizards can specify "all" or <player>
+  for the <player> field; mortals must use "me" or a ZMP whose @lock/zone
+  they pass. If you do not want to restrict something, use "none" for
+  <class> and <restriction>.
 
   The possible <class>es and <restriction>s are the same as those
   accepted by @search. lsearch() can accept multiple class/restriction
@@ -2426,18 +2590,16 @@
   nlsearch(...) and nchildren(...) return the count of results that
   would be returned by lsearch() or children() with the same args.
     
-  See 'help lsearch2' for more details.
+  Continued in 'help lsearch2'.
 & LSEARCH2
 & SEARCH2 
    
-  If <class> is one of the eval ones (EVAL, EEXITS, EROOMS, EOBJECTS
+  If <class> is one of the eval classes (EVAL, EEXITS, EROOMS, ETHINGS
   or EPLAYERS), note that any brackets, percent signs, or other
   special characters should be escaped, as the code in <restriction>
-  will be evaluated twice - Once as an argument to lsearch(), and then
-  again for each object looked at in the search.
-
-  <class> can be 'NONE' to make lsearch() act like a @search without a
-  class.
+  will be evaluated twice - once as an argument to lsearch(), and then
+  again for each object looked at in the search. Before the per-object
+  evaluation, the string "##" is replaced with the object dbref.
 
   lsearchr() is like an lsearch() run through revwords(). Results are
   returned from highest dbref to lowest.  search() is an alias for
@@ -2454,26 +2616,39 @@
 & LSTATS()
 & STATS()
   lstats(<player>)
-  stats(<player>)
  
   This function returns the breakdown of objects in the database, in a
   format similar to "@stats". If <player> is "all", a breakdown is
   done for the entire database. Otherwise, the breakdown is returned
-  for that particular player. Only wizards can LSTATS() other players.
-  The list returned is in the format: <Total objects> <Rooms> <Exits>
-  <Things> <Players> <Garbage>
+  for that particular player.
+  
+  Only wizards and those with the Search power can LSTATS() other players.
+  The list returned is in the format: 
+  <Total objects> <Rooms> <Exits> <Things> <Players> <Garbage>
 
   stats() is an alias for lstats().
 & LT()
-  lt(<num>, <num>)
+  lt(<number1>, <number2>[, ... , <numberN>])
 
-  Takes two numbers, and returns 1 if and only if the first is less
-  than the second, and 0 otherwise.
+  Takes two or more numbers, and returns 1 if and only if each number
+  is less than the number after it, and 0 otherwise.
+
+  Examples:
+    > th lt(1,2)
+    1
+    > th lt(1,2,3)
+    1
+    > th lt(1,3,2)
+    0
+  
+See also: lte(), gt(), gte(), lnum()
 & LTE()
-  lte(<num>, <num>)
+  lte(<number1>, <number2>[, ... , <numberN>])
 
-  Takes two numbers, and returns 1 if and only if the first is less
-  than or equal to the second, and 0 otherwise.
+  Takes two or more numbers, and returns 1 if and only if each number
+  is less than or equal to the number after it, and 0 otherwise.
+  
+See also: lt(), gt(), gte(), lnum()
 & LVCON()
   lvcon(<object>)
 
@@ -2481,7 +2656,7 @@
   <object> and visible (non-dark). You must be in <object> or control
   it to use this function.
 
-See also: lcon()
+See also: lcon(), lvplayers(), lvthings(), lvexits()
 & LVEXITS()
   lvexits(<room>)
 
@@ -2489,202 +2664,219 @@
   from <room>. You must be in the room or control it to use this
   function.
 
-See also: lexits()
+See also: lexits(), lvcon(), lvplayers(), lvthings()
 & LVPLAYERS()
   lvplayers(<object>)
 
   This function returns the dbrefs of all connected and non-dark players
   in an object. You must be in the object or control it to use this 
   function.
+  
+See also: lplayers(), lvcon(), lvthings(), lvexits()
 & LVTHINGS()
   lvthings(<object>)
 
   This function returns the dbrefs of all non-dark things inside an
   object. You must be in the object or control it to use this
   function.
+  
+See also: lthings(), lvplayers(), lvcon(), lvexits()
 & LWHO()
 & LWHOID()
-  lwho()
-  lwho(<viewer>)
-  lwhoid(<viewer>)
+  lwho([<viewer>[, <status>]])
+  lwhoid([<viewer>[, <status>]])
 
-  lwho() returns a list of the dbref numbers for all
-  currently-connected players. When mortals use this function, the
-  dbref numbers of DARK wizards or royalty do NOT appear on the dbref
-  list.
+  lwho() returns a list of the dbref numbers for all currently-connected
+  players. When mortals use this function, the dbref numbers of DARK
+  wizards or royalty do NOT appear on the dbref list.
 
-  If lwho() is given an argument, and used by an object that can see
-  DARK and Hidden players, lwho() returns the output of lwho() from
-  <viewer>'s point of view.
+  If a <viewer> is given, and used by an object that can see DARK and
+  Hidden players, lwho() returns the output of lwho() from <viewer>'s
+  point of view.
+  
+  <status> can be used to include "#-1" dbrefs for unconnected ports, and
+  must be one of "all", "online" or "offline". It is primarily useful when
+  using a <status> with lports(), to make the dbrefs and ports match up.
+  Only See_All players can see offline dbrefs.
 
   lwhoid() returns a list of objid's instead.
 
 See also: mwho(), nwho(), xwho()
 & MAP()
-  map([<object>/]<attribute>, <list>[,<delim>[, <osep>]])
+  map([<object>/]<attribute>, <list>[, <delim>[, <osep>]])
   
-  Maps a function onto a list.
- 
-  This function works much like ITER(). Each element of <list> has the
-  user-defined function of the first argument performed on it; the
-  element is passed to the function as %0, and its position in <list>
-  as %1. <delim> is used as the element delimiter; if it is not
-  specified, a space is used. The resulting output is delimited by
-  <osep>, if given, or else by the delimiter
- 
-  Examples:
+  This function works much like ITER(). The given <attribute> is evaluated 
+  once for each element of <list>, and the results of the evaluations are
+  returned. For each evaluation, the current list element is passed to the
+  attribute as %0, and it's position in the list as %1. Elements of <list>
+  are separated by <delim>, or a space if none is given, and the results are
+  returned separated by <osep>, if given, or the delimiter otherwise.
   
-    > &times_two me=[mul(%0,2)]
- 
-    > say [map(times_two, 5 4 3 2 1)]
+  This is roughly equivilent to:
+  iter(<list>, ufun(<object>/<attribute>, %i0, inum(0)), <delim>, <osep>)
+  
+  Examples:
+    > &times_two me=mul(%0,2)
+
+    > say map(times_two, 5 4 3 2 1)
     You say, "10 8 6 4 2"
  
     > say [map(times_two,1;2;3;4;5,;)]
     You say, "2;4;6;8;10"
 
-See also: anonymous attributes
+See also: anonymous attributes, iter(), @dolist
 & MATCH()
-  match(<list>, <pattern>[,<delimiter>])
-
-  This function tests if the pattern matches an element of the list.
-  The pattern can contain the wildcards * and ?.  ? matches to any one
-  character, while * matches to any number of characters including
-  none.  So s?x would match to sex or six, but not to socx, but s*x
-  would match to all of them. If no match is found, 0 is returned. If
-  a match is found, it returns the number of the element of the list
-  that matched.
-
-  This attempts to match to a list element, not to an entire string.
-  To match an entire string (for example, to match "red blue green" to
-  "*bl*"), use the strmatch() function.
-
-See also: element(), grab()
 & MATCHALL()
-  matchall(<list>, <pattern>[,<delim>[, <osep>]])
- 
-  This function works identically to the match() function, save that
-  it returns all matches, not just the first: It returns the index
-  numbers of all elements in <list> which match <pattern>. If none
-  match, an empty string is returned.  The resulting output is
-  delimited by <osep>, if given, or else by the delimiter.
-
+  match(<list>, <pattern>[, <delimiter>])
+  matchall(<list>, <pattern>[, <delimiter>[, <output separator>]])
+  
+  match() returns the index of the first element of <list> which matches
+  the wildcard pattern <pattern>. The first word has an index of 1. If no
+  matches are found, 0 is returned.
+  
+  matchall() is similar, but returns the indexes of all matching elements.
+  If no elements match, an empty string is returned.
+  
+  In both cases, elements of <list> are separated by <delimiter>, if it's
+  given, or a space otherwise. The results of matchall() are separated by
+  <ouput separator>, if given, and <delimiter> if not.
+  
+  To get the matching elements, instead of the indexes of where they appear
+  in the list, use grab()/graball(). To see if a single string matches a
+  wildcard pattern, use strmatch().
+  
   Examples:
- 
-  > say matchall(This is a test of a test,test)
-  You say "4 7"
-  > say matchall(This is testing a test,tes*)
-  You say "3 5"
- 
-See also: match(), strmatch(), graball()
+    > say match(I am testing a test, test*)
+    You say, "3"
+  
+    > say matchall(I am testing a test, test*)
+    You say, "3 5"
+  
+    > say match(foo bar baz boing, sprocket)
+    You say, "0"
+  
+    >say matchall(foo bar baz boing, sprocket)
+    You say, ""
+  
+See also: grab(), strmatch(), member(), WILDCARDS
+
 & MAX()
   max(<number>[, ... , <numberN>])
 
   This function returns the largest number in its list of arguments.
   It can take any number of arguments.
+  
+See also: min(), lmath(), bound()
 & MEAN()
   mean(<number>[, ... , <numberN>])
 
   Returns the mean (arithmetic average) of its arguments.
 
-See also: median(), stddev()
+See also: median(), stddev(), lmath()
 & MEDIAN()
   median(<number>[, ... , <numberN>)
 
   Returns the median (the middlemost numerically) of its arguments.
 
-See also: mean(), stddev()
+See also: mean(), stddev(), lmath()
 & MEMBER()
-  member(<list>, <word>[,<delimiter>])
-
-  Takes a list and a word, and returns the position of <word> if
-  <word> is a element of <list>, and 0 if it's not in the list.
+  member(<list>, <word>[, <delimiter>])
 
-  member() is case-sensitive and requires an exact match. For wild
-  card patterns, use match().
+  member() returns the position where <word> first occurs in <list>. If
+  <word> is not present in <list>, it returns 0. Elements of <list> are
+  <delimiter>-separated, or space-separated if no <delimiter> is given.
+  
+  member() is case-sensitive, and does not perform wildcard matching.
+  If you need to do a wildcard match, use match(). To compare two strings
+  (instead of a word and list elements), consider comp().
+  
+See also: match(), grab(), comp(), strmatch()
 & MERGE()
   merge(<string1>, <string2>, <characters>)
   
-  This function merges <string1> and <string2>, depending on
-  <characters>.  If a character in <string1> is the same as one in
-  <characters>, it is replaced by the character in the corresponding
-  position in <string2>.  The two strings must be of the same length.
+  This function merges <string1> and <string2>, depending on <characters>.
+  If a character in <string1> is the same as one in <characters>, it is
+  replaced by the character in the corresponding position in <string2>.
+  The two strings must be of the same length.
   
   Example:
-    > say [merge(AB--EF,abcdef,-)]
+    > say merge(AB--EF,abcdef,-)
     You say, "ABcdEF"
  
   Spaces need to be treated specially. An empty argument is considered
   to equal a space, for <characters>.
   
   Example:
-    > say [merge(AB[space(2)]EF,abcdef,)]
+    > say merge(AB[space(2)]EF,abcdef,)
     You say, "ABcdEF"
 
 See also: splice(), tr()  
 & MESSAGE()
-  message(<player list>, <message>, <attribute>[,<arg1>,...])
+  message(<player list>, <message>, <attribute>[, <arg1>[, ... , <arg10>]])
 
   message() is the function form of @message.
 & MID()
   mid(<string>, <first>, <length>)
 
-  Mid returns a segment of the string, the <length> characters to the
-  right of the <first> character.  Note that the first character in a
-  string is numbered zero, and not one. If <length> is negative, it
-  returns characters to the left of the <first> character. The <first>
-  character is always part of the <length> characters.
+  mid() returns <length> characters from <string>, starting from the <first>
+  character. If <length> is positive, it counts forwards from the <first>
+  character; for negative <length>s, it counts backwards. Note that the
+  first character in <string> is numbered 0, not 1.
 
   Examples:
-    > say mid(foobar, 2, 2)
-    You say, "ob"
-    > say mid(foobar, 2, -2)
-    You say, "oo"
+    > say mid(testing, 2, 2)
+    You say, "st"
+    > say mid(testing, 2, -2)
+    You say, "es"
 
-See also: left(), right()  
+See also: left(), right(), delete() 
 & MIN()
   min(<number>[, ... , <numberN>])
 
   This function returns the smallest number in its list of arguments.
   It can take any number of arguments.
+  
+See also: max(), lmath(), bound()
 & MIX()
  
-  mix([<object>/]<attribute>, <list 1>, <list 2>[, ... , <list n>,<delim>])
+  mix([<object>/]<attribute>, <list1>, <list2>[, ... , <list10>, <delim>])
  
   This function is similar to MAP(), except that it takes the elements
-  of two or more lists, one by one, and passes them to the
-  user-defined function as %0, %1, up to %9, respectively, for
-  elements of <list 1> to <list 10>. If the lists are of different
-  sizes, the shorter ones are padded with empty elements. <delim> is
-  used to separate elements; if it is not specified, it defaults to a
-  space. If using more than 2 lists, the last argument must be a
-  delimiter.
+  of up to ten lists, one by one, and passes them to the user-defined
+  function as %0, %1, up to %9, respectively, for elements of <list1> to
+  <list10>. If the lists are of different sizes, the shorter ones are padded
+  with empty elements. <delim> is used to separate elements; if it is not
+  specified, it defaults to a space. If using more than 2 lists, the last 
+  argument must be a delimiter.
 
-  See 'MIX2' for examples
+  See 'help mix2' for examples.
 & MIX2  
   Examples of mix():
  
-  > &add_nums me=[add(%0, %1)]
-  > say [mix(add_nums,1 2 3 4 5, 2 4 6 8 10)]
+  > &add_nums me=add(%0, %1)
+  > say mix(add_nums,1 2 3 4 5, 2 4 6 8 10)
   You say, "3 6 9 12 15"
-  > &lengths me=[strlen(%0)] and [strlen(%1)].
-  > say [mix(lengths, some random, words)]
+  
+  > &lengths me=strlen(%0) and [strlen(%1)].
+  > say mix(lengths, some random, words)
   You say, "4 and 5. 6 and 0."
-  > &add_nums me=[add(%0, %1, %2)]
-  > say [mix(add_nums, 1:1:1, 2:2:2, 3:3:3, :)]
-  You say, "6:6:6"
+  
+  > &add_nums me=lmath(add, %0 %1 %2)
+  > say mix(add_nums, 1:2:3, 4:5:6, 7:8:9, :)
+  You say, "12:15:18"
 
-See also: anonymous attributes
+See also: anonymous attributes, map(), step()
 & MOD()
 & MODULO()
 & MODULUS()
 & REMAINDER()
-  mod(<number>, <number>)
-  modulo(<number>, <number>)
-  modulus(<number>, <number>)
-  remainder(<number>, <number>)
+  mod(<number1>, <number2>)
+  modulo(<number1>, <number2>)
+  modulus(<number1>, <number2>)
+  remainder(<number1>, <number2>)
 
-  Remainder returns the remainder of the integer division of the first
-  number by the second.  Modulo returns the modulo of the two numbers.
+  remainder() returns the remainder of the integer division of the first
+  number by the second.  modulo() returns the modulo of the two numbers.
   For positive numbers, these are the same, but they may be different
   for negative numbers:
 
@@ -2693,41 +2885,44 @@
      modulo(13,-4)      ==>  -3     but     remainder(13,-4)   ==>  1
      modulo(-13,-4)     ==>  -1     and     remainder(-13,-4)  ==>  -1 
  
-  Remainder result always has the same sign as the first argument.
-  Modulo result always has the same sign as the second argument.
+  remainder()s result always has the same sign as the first argument.
+  modulo()s result always has the same sign as the second argument.
 
-  Mod and modulus are just aliases for modulo.
+  mod() and modulus() are aliases for modulo().
 
-See also: div()
+See also: div(), fdiv(), lmath()
 & MONEY()
   money(<object>)
   money(<integer>)
 
-  The first form returns the amount of money <object> has.  The second
-  form returns the name for a given amount of money, appropriately
+  The first form returns the amount of money <object> has. If <object> is
+  no_pay, the value of the 'max_pennies' @config option is returned. The
+  second form returns the name for a given amount of money, appropriately
   inflected as singular or plural.
 
-  > say [money(Javelin)]
-  You say, "150"
+  Examples:
+    > say money(Javelin)
+    You say, "150"
  
-  > say [money(1)]
-  You say, "Penny"
+    > say money(1)
+    You say, "Penny"
 
-  > say [money(2)]
-  You say, "Pennies"
+    > say money(2)
+    You say, "Pennies"
 
-  > &counter me=$count *: @emit %0 [money(%0)]
-  > count 2
-  2 Pennies
+    > &counter me=$count *: @emit %0 [money(%0)]
+    > count 2
+    2 Pennies
 
+See also: score
 & MTIME()
 & MSECS()
-  mtime(<object>[, <utc>])
+  mtime(<object>[, <utc?>])
   msecs(<object>)
  
   mtime() returns the date and time that one of <object>'s attributes or
   locks was last added, deleted, or modified. The time returned is in the
-  server's local timezone, unless <utc> is true, in which case the time is
+  server's local timezone, unless <utc?> is true, in which case the time is
   in the UTC timezone.
   
   msecs() returns the time as the number of seconds since the epoch.
@@ -2735,34 +2930,40 @@
   Only things, rooms, and exits have modification times. You must be able to
   examine an object to see its modification time.
 
-See also: ctime(), time(), secs()
+See also: ctime(), time(), secs(), convtime(), convsecs()
 & MUDNAME()
   mudname()
  
-  Returns the name of the MUD.  This is usually (but not necessarily)
-  the name that appears in the various mud lists, and is the name that
-  the mud is listed under in reports from any inter-mush bots like
-  mudnet that it's connected to.  Example: > say mudname() You say
-  "TestMUSH"
+  Returns the name of the MUSH, as set in the 'mud_name' @config option. 
+  
+  Example: 
+    > say mudname()
+    You say, "TestMUSH"
 
+see also: config()
 & MUL()
-  mul(<number>, <number>[, ... , <numberN>])
+  mul(<number1>, <number2>[, ... , <numberN>])
 
   Returns the product of some numbers.
+  
+See also: lmath(), div(), fdiv()
 & MUNGE()
-  munge([<object>/]<attribute>, <list 1>, <list 2>[,<delimiter>[, <osep>]])
+  munge([<object>/]<attribute>, <list1>, <list2>[, <delimiter>[, <osep>]])
  
   This function takes two lists of equal length. It passes the
-  entirety of <list 1> to the user-defined function as %0, and the
+  entirety of <list1> to the user-defined function as %0, and the
   delimiter as %1.  Then, this resulting list is matched with elements
-  in <list 2>, and the rearranged <list 2> is returned. This is useful
-  for doing things like sorting a list, and then returning the
-  corresponding elements in the other list. If a resulting element
+  in <list 2>, and the rearranged <list2> is returned.
+  
+  This is useful for doing things like sorting a list, and then returning
+  the corresponding elements in the other list. If a resulting element
   from the user-defined function doesn't match an element in the
-  original <list 1>, a corresponding element from <list 2> does not
+  original <list1>, a corresponding element from <list2> does not
   appear in the final result.
+  
+  <delimiter> defaults to a space, and <osep> defaults to <delimiter>.
 
-  See 'MUNGE2' for examples.
+  See 'help munge2' for examples.
 & MUNGE2
   For example: Consider attribute PLACES, which contains "Fort Benden
   Ista", and another attribute DBREFS contains the dbrefs of the main
@@ -2772,11 +2973,11 @@
   Fort Ista", so we want the final list to be "#9000 #20 #5000". The
   functions, using munge(), are simple:
   
-  > &sort me=[sort(%0)]
-  > say [munge(sort,v(places),v(dbrefs))]
-  You say, "#9000 #20 #5000"
+    > &sort me=sort(%0)
+    > say munge(sort, v(places), v(dbrefs))
+    You say, "#9000 #20 #5000"
  
-  See 'MUNGE3' for another example.
+  See 'help munge3' for another example.
 & MUNGE3
   Another common task that munge() is well suited for is sorting a
   list of dbrefs of players by order of connection. This example
@@ -2784,9 +2985,9 @@
   other example, it builds the list to sort on out of the list to
   return.
   
-  > &faction_members me=#3 #12 #234
-  > say [munge(sort,iter(v(faction_members),conn(##)),v(faction_members))]
-  You say, "#12 #234 #3"
+    > &faction_members me=#3 #12 #234
+    > say munge(sort, iter(v(faction_members),conn(##)), v(faction_members))
+    You say, "#12 #234 #3"
 
 See also: anonymous attributes
 & MWHO()
@@ -2794,107 +2995,119 @@
   mwho()
   mwhoid()
 
-  mwho() returns a list of the dbref numbers for all
-  current-connected, non-hidden players. It's exactly the same as
-  lwho() used by a mortal, and is suitable for use on privileged
-  global objects who need an unprivileged who-list.
+  mwho() returns a list of the dbref numbers for all current-connected, 
+  non-hidden players. It's exactly the same as lwho() used by a mortal,
+  and is suitable for use on privileged global objects who need an 
+  unprivileged who-list. In some cases, lwho(<viewer>) may be preferable
+  to mwho(), as it includes hidden players for <viewer>s who can see them.
   
   mwhoid() returns a list of objids instead.
+  
+See also: lwho(), nwho()
 & ALIAS()
-  alias(<player>[, <new alias>])
-
-  Alias returns the alias of <player>. If multiple aliases are set,
-  alias returns the first component of the alias.
-
-  If function side effects are allowed, this function, given two
-  arguments, acts just like @alias <object>=<new alias>.
-
-  Related functions: FULLALIAS()
-
 & FULLALIAS()
-  fullalias(<player>)
-
-  fullalias() returns the alias of <player>. It is identical to
-  alias() except when multiple aliases are set, fullalias() returns
-  the complete alias list.
-
-  >"[fullalias(Noltar)]
-  You say, "$;No;Nol;Noli;Nolt"
-
-  Related functions: ALIAS()
+  alias(<object>[, <new alias>])
+  fullalias(<object>)
+  
+  alias() returns the first of <object>'s aliases. fullalias() returns all
+  the aliases set for <object>. Note that, while any object can have an alias
+  set, they are only meaningful for players.
+  
+  With two arguments, alias() attempts to change the alias for <object> to
+  <new alias>, as per @alias.
+  
+  Example:
+    > ex *Noltar/ALIAS
+    ALIAS [#7$v]: $;No;Nol;Noli;Nolt
+    > say alias(*Noltar)
+    You say, "$"
+    > say fullalias(Noltar)
+    You say, "$;No;Nol;Noli;Nolt"
 
+See also: fullname()
 & NAME()
   name(<object>[, <new name>])
  
-  Name returns the name of object <object>. For exits, name returns
+  name() returns the name of object <object>. For exits, name() returns only
   the displayed name of the exit.
  
-  If function side effects are allowed, this function, given two
-  arguments, acts just like @name <object>=<new name>.
+  With two arguments, name() attempts to rename <object> to <new name>, as
+  per @name.
 
   name() with no arguments currently returns nothing. This should be
   an error, but enough old code has been written that expects this
   behavior that it will continue to do this for the time being. Don't
   rely on it.
 
-  Related functions: FULLNAME(), ACCNAME(), INAME() 
+Related functions: fullname(), accname(), iname(), alias()
 & NAMELIST()
-  namelist(<player-list>)
+  namelist(<player-list>[, [<object>/]<attribute>])
 
-  Namelist takes a list of players of the form used by the page
-  command and returns a corresponding list of dbrefs.
+  namelist() takes a list of players of the form used by the page command
+  and returns a corresponding list of dbrefs. Invalid and ambiguous names
+  return the dbrefs #-1 and #-2, respectively.
+  
+  If an <object>/<attribute> is given, the specified attribute will be
+  called once for each invalid name, with the name as %0 and the dbref
+  returned (#-1 for an unmatched name, #-2 for an ambiguous one) as %1.
 
-  >"[namelist(#1 Javelin "ringo spar" bogus)]
-  You say, "#1 #7 #56 #-1"
+  Example:
+    > &test me=pemit(%#,Bad name "%0")
+    > say namelist(#1 Javelin "ringo spar" bogus, test)
+    Bad name "bogus"
+    You say, "#1 #7 #56 #-1"
 
+See also: namegrab(), name(), locate()
 & NAMEGRAB()
 & NAMEGRABALL()
   namegrab(<dbref list>, <name>)
   namegraball(<dbref list>, <name>)
 
-  The namegrab() function, when given a list of dbrefs and a name,
-  returns the first dbref in the list that would match <name> as if
-  you were checking num() or locate(). An exact match has priority
-  over non-exact matches.
+  The namegrab() function returns the first dbref in the list that would
+  match <name> as if you were checking num() or locate(). An exact match
+  has priority over partial matches.
 
-  namegraball() returns all dbrefs whose names would be matched
-  by <name>.
+  namegraball() returns all dbrefs whose names would be matched by <name>.
 
-  eg: @@(#0: Room Zero. #1: One. #2: Master Room)
-    > th namegrab(#0 #1 #2,room)
-    #0
-    > th namegrab(#0 #1 #2,master room)
-    #2
-    > th namegraball(#0 #1 #2,room)
-    #0 #2
+  Example: #0 = Room Zero, #1 = One, #2 = Master Room
+    > say namegrab(#0 #1 #2,room)
+  You say, "#0"
+    > say namegrab(#0 #1 #2,master room)
+    You say, "#2"
+    > say namegraball(#0 #1 #2,room)
+    You say, "#0 #2"
+  
+See also: namelist(), locate(0
 & NAND()
-  nand(<boolean>[, ... , <booleanN>])
+  nand(<boolean1>[, ... , <booleanN>])
 
   Returns 1 if at least one of its arguments is false, 0 if all are
   true. Equivalent to not(and()), but more efficient.
+  
+See also: lmath(), and(), cand(), or(), nor()
 & NEARBY()
   nearby(<object 1>, <object 2>)
 
-  Returns 1 if object 1 is "nearby" object 2. "Nearby" is defined as:
-  object 1 is in the same location as object 2, or,
-  object 1 is being carried by object 2, or,
-  object 1 is carrying object 2.
-  You must control at least one of the objects.
+  Returns 1 if <object 1> is "nearby" <object 2>, and 0 otherwise. "Nearby"
+  means the objects are in the same location, or that one is located inside
+  the other. You must control at least one of the objects; if you don't, or
+  if one of the objects can't be found, nearby() returns #-1.
 & NEQ()
-  neq(<num1>, <num2>)
+  neq(<number1>, <number2>[, ... , <numberN>])
 
-  Basically the same as [not(eq(<num1>,<num2>))].
+  Returns 0 if all the given <number>s are the same, and 1 otherwise. 
+  Basically the same as [not(eq(<number1>, <number2>[, ... , <numberN>]))]
+  but more efficient.
 
-See also: eq(), not()
+See also: eq(), not(), lmath()
 & NEXT()
   next(<object>)
 
-  If object is an exit in a room, then next() will return the next non
-  exit in the list of exits for that room.  If object is a thing or a
-  player, then next will return the next object in the contents list
-  that the object is in.  Otherwise, it returns a '#-1' string.  '#-1'
-  is also used to denote that there are no more exits/things/players
-  in the container.
+  If <object> is an exit, then next() will return the next exit in <object>'s
+  source room. If <object> is a thing or a player, then next() will return
+  the next object in the contents list of <object>'s location.  Otherwise, 
+  it returns a #-1. #-1 is also used to denote that there are no more exits
+  or objects after <object>.
 
   You can get the complete contents of any container you may examine,
   regardless of whether or not objects are dark.  You can get the
@@ -2911,39 +3124,40 @@
   object is @created (or @dug, or @opened, or @pcreated, etc.), it
   will have this dbref.
 
+See also: @stats, stats()
 & NOR()
   nor(<boolean>[, ... , <booleanN>])
 
-  Returns 1 if all its arguments are false, 0 if one is true.
+  Returns 1 if all its arguments are false, 0 if any are true.
   Equivalent to not(or()), but more efficient.
 
-See also: and(), or(), xor(), not()
+See also: and(), or(), xor(), not(), nand()
 & NOT()
-  not(<boolean value>)
+  not(<boolean>)
 
-  Takes a boolean value, and returns its inverse.  I.E. if the input
-  is equivalent to true(1), it returns a 0, and if the input is
-  equivalent to false(0), it returns a 1.
+  not() returns 1 if <boolean> is false, and 0 if it's true.
 
   The definition of truth and falsehood depends on configuration settings;
-  see 'BOOLEAN VALUES' for details.
+  see 'help boolean values' for details.
  
-See also: and(), or(), nor(), xor()
-
+See also: Boolean Functions, t(), and(), or(), nor(), xor()
 & NUM()
   num(<object>)
 
-  Returns the dbref number of the object, which must be in the same
-  room as the object executing num.
+  Returns the dbref number of <object>. <object> must be the name of an
+  object which is near to the caller, or the name of a player prefixed with
+  a '*'.
+  
+See also: locate(), rnum()
 & NVCON()
 & NCON()
   ncon(<object>)
   nvcon(<object>)
 
-  These functions return a count of the contents in a container.
-
-  ncon(<object>)  is identical to words(lcon(<object>))
-  nvcon(<object>) is identical to words(lvcon(<object>))
+  These functions return a the number of objects inside <object>. They are
+  identical to words(lcon(<object>)) and words(lvcon(<object>)), 
+  respectively, but are more efficient and do not suffer from buffer
+  constraints.
 
 See also: nexits(), nplayers(), xcon(), lcon(), lvcon()
 & NVEXITS()
@@ -2951,10 +3165,9 @@
   nexits(<room>)
   nvexits(<room>)
 
-  These functions return a count of the exits in a room.
-
-  nexits(<room>)  is identical to words(lexits(<room>))
-  nvexits(<room>) is identical to words(lvexits(<room>))
+  These functions return a count of the exits in a room. They are equivilent
+  to words(lexits(<room>)) and words(lvexits(<room>)) respectively, though
+  are more efficient, and don't suffer from buffer constraints.
 
 See also: ncon(), nplayers(), xexits(), lexits(), lvexits()
 & NVPLAYERS()
@@ -2962,10 +3175,10 @@
   nplayers(<object>)
   nvplayers(<object>)
 
-  These functions return a count of the players in a container.
-
-  nplayers(<object>)  is identical to words(lplayers(<object>))
-  nvplayers(<object>) is identical to words(lvplayers(<object>))
+  These functions return a count of the players in <object>. They are
+  equivilent to words(lplayers(<object>)) and words(lvplayers(<object>))
+  respectively, though are more efficient and do not suffer from buffer
+  constraints.
 
 See also: ncon(), nexits(), xplayers(), lplayers(), lvplayers()
 & NVTHINGS()
@@ -2973,29 +3186,30 @@
   nthings(<object>)
   nvthings(<object>)
 
-  These functions return a count of the things in a container.
-
-  nthings(<object>)  is identical to words(lthings(<object>))
-  nvthings(<object>) is identical to words(lvthings(<object>))
+  These functions return a count of the things in a container. They are
+  equivilent to words(lthings(<object>)) and words(lvthings(<object>))
+  respectively, though are more efficient and do not suffer from buffer
+  constraints.
 
 See also: ncon(), nexits(), xthings(), lthings(), lvthings()
 & NMWHO()
 & NWHO()
-  nwho()
-  nwho(<viewer>)
+  nwho([<viewer>])
   nmwho()
 
-  nwho() returns a count of all currently-connected players. When
-  mortals use this function, DARK wizards or royalty are NOT counted.
-
+  nwho() returns a count of all currently-connected players. When mortals 
+  use this function, DARK wizards or royalty are NOT counted. See_All players
+  can specify a <viewer> to get a count of the number of players that 
+  <viewer> can see is online.
+  
   nmwho() returns a count of all currently connected, non-hidden
   players.  It's exactly the same as nwho() used by a mortal, and is
   suitable for use on privileged global objects that always need an
   unprivileged count of who is online.
 
-  If nwho() is given an argument, and is used by an object that can
-  see DARK and Hidden players, nwho() returns the count of online
-  players based on what <viewer> can see.
+  These functions are equivilent to words(lwho([<viewer>])) and 
+  words(mwho()), but are more efficient, and don't suffer from buffer
+  constraints.
 
 See also: lwho(), mwho(), xwho(), xmwho()
 & OBJ()
@@ -3004,32 +3218,30 @@
 
   Returns the objective pronoun - him/her/it - for an object. The %o
   substitution will return the objective pronoun of the enactor.
+  
+See also: subj(), poss(), aposs()
 & OBJEVAL()
   objeval(<object>, <expression>)
  
   Allows you to evaluate <expression> from the viewpoint of <object>.
   If side-effect functions are enabled, you must control <object>; if
-  not, you must either control <object> or have the see_all power.  If
+  not, you must either control <object> or have the see_all power. If
   <object> does not exist or you don't meet one of the criterion, the
-  function evaluates with your privileges.
- 
-  This function is useful for securing objects which need to evaluate
-  attributes on things owned by others.
-  
+  expression evaluates with your privileges. 
 & OBJID()
   objid(<object>)
 
-  This function returns the object id, a value which uniquely
-  identifies it for the life of the MUSH. The object id is the
-  object's dbref, a colon character, and the object's creation time,
-  in seconds since the epoch.
+  This function returns the object id of <object>, a value which uniquely
+  identifies it for the life of the MUSH. The object id is the object's
+  dbref, a colon character, and the object's creation time,
+  in seconds since the epoch, equivilent to 
+  [num(<object>)]:[csecs(<object>)]
 
   The object id can be used nearly anywhere the dbref can, and ensures
   that if an object's dbref is recycled, the new object won't be
   mistaken for the old object.
 
-  The substitution %: returns the object id of the enacting object.
-
+  The substitution %: returns the object id of the enactor.
 & OBJMEM()
   objmem(<object>)
 
@@ -3037,7 +3249,6 @@
   the object. It can only be used by players with Search powers.
 
 See also: playermem()
-
 & OEMIT()
 & NSOEMIT()
   oemit([<room>/]<object> [... <object>], <message>)
@@ -3051,49 +3262,40 @@
 & OPEN()
   open(<exit name>, <room>)
  
-  This function opens an exit called <exit name> and links it to
-  <room>, which must be a dbref number. It returns the dbref number of
-  the new exit.
- 
+  This function opens an exit called <exit name> in the caller's current
+  location, and then attempts to link it to the room <room>, as per
+  @open <exit name>=<room>. If you want to open an unlinked exit, use
+  an empty string for <room>.
+
+See also: @open, @link 
 & OR()
 & COR()
-  or(<boolean value 1>, <boolean value 2>[, ... , <boolean value N>])
-  cor(<boolean value 1>, <boolean value 2>[, ... , <boolean value N>])
+  or(<boolean1>, <boolean2>[, ... , <booleanN>])
+  cor(<boolean1>, <boolean2>[, ... , <booleanN>])
  
-  Takes boolean values, and returns a 1 if at least one of the inputs
-  is true.  or() always evaluates all arguments (including side
-  effects), while cor() stops evaluation after the first argument that
-  evaluates to true.
+  These functions take a number of boolean values, and return 1 if any of
+  them are true, and 0 if all are false. or() always evaluates all of its
+  arguments, while cor() stops evaluating as soon as one is true.
 
-See also: BOOLEAN VALUES, and()
+See also: BOOLEAN VALUES, and(), nor(), firstof(), allof()
 & ORFLAGS()
-  orflags(<object>,<string of flag characters>)
-  
-  This function returns 1 if <object> has at least one of the flags in
-  a specified string, and 0 if it does not. The string is specified
-  with a single letter standing for each flag, like the output of the
-  FLAGS() function. A '!' preceding a flag letter means "not flag".
-
-  Thus, ORFLAGS(me,Wr) would return 1 if I am set WIZARD or ROYALTY.
-  ORFLAGS(me,D!c) would return 1 if I am DARK or not CONNECTED.
-
-  If a letter does not correspond to any flag, <object> doesn't have
-  it, so it is simply ignored. There can be an arbitrary number of
-  flags. Do not put spaces between flag letters.
 & ORLFLAGS()
+  orflags(<object>, <string of flag characters>)
   orlflags(<object>, <list of flag names>)
 
-  This function returns 1 if <object> has at least one of the flags in
-  a specified list, and 0 if it does not. The list is a
-  space-separated list of flag names.  A '!' preceding a flag name
-  means "not flag".
-
-  Thus, ORLFLAGS(me,wizard royalty) would return 1 if I am set WIZARD
-  or ROYALTY.  ORLFLAGS(me,dark !connected) would return 1 if I am
-  DARK or not CONNECTED.
-
-  If a name does not correspond to any flag, <object> doesn't have it,
-  so it is simply ignored. There can be an arbitrary number of flags.
+  These functions return 1 if <object> has any of the given flags, and 0 if
+  it does not. orflags() takes a string of single flag letters, while
+  orlflags() takes a space-separated list of flag names. In both cases, a
+  ! before the flag means "not flag".
+  
+  If any of the flags given are invalid, <object> cannot have them, and it
+  is ignored.
+  
+  Example: Check to see if %# is set Wizard, Dark, or not set Ansi.
+    > say orflags(%#, WD!A)
+    > say orlflags(%#, wizard dark !ansi)
+  
+See also: andflags(), flags(), lflags()
 & ORLPOWERS()
   orlpowers(<object>, <list of powers>)
 
@@ -3109,30 +3311,37 @@
   If a name does not correspond to any power, <object> doesn't have
   it, so it is simply ignored. There can be an arbitrary number of
   powers.
+  
+See also: powers(), andlpowers(), POWERS LIST, @power
 & OWNER()
   owner(<object>[/<attribute>])
  
   Given just an object, it returns the owner of the object.  Given an
   object/attribute pair, it returns the owner of that attribute.
+  
+See also: lockowner()
 & PARENT()
   parent(<object>[, <new parent>])
  
   This function returns the dbref number of an object's parent. You
   must be able to examine the object to do this.  If you specify a
-  second argument, it tries to re-parent the object.  In this case,
-  you must control the object.
+  second argument, parent() attempts to change the parent first.
+  You must control <object>, and be allowed to @parent to <new parent>.
+  
+See also: @parent, ancestors
 & PEMIT()
 & NSPEMIT()
 & PROMPT()
 & NSPROMPT()
-  pemit(<object list>, <message>)
-  nspemit(<object list>, <message>)
+  pemit(<object list|port number>, <message>)
+  nspemit(<object list|port number>, <message>)
   prompt(<object list>, <message>)
   nsprompt(<object list>, <message>)
 
-  pemit() will send each object on the list a message, as per the
-  @pemit/list command. It returns nothing. It respects page-locks and
-  HAVEN flags on players.
+  With an <object list>, pemit() will send each object on the list a message,
+  as per the @pemit/list command. It returns nothing. It respects page-locks
+  and HAVEN flags on players. With a <port number>, pemit() sends the
+  message to the specified port only, like @pemit/port.
 
   nspemit() is a wizard-only variation that works like @nspemit/list.
 
@@ -3147,21 +3356,21 @@
   Returns the value of "pi" (3.14159265358979323846264338327, rounded
   to the game's float_precision setting).
 & PIDINFO()
-  pidinfo(<pid>[,<list of fields>[,<output separator>]])
+  pidinfo(<pid>[, <list of fields>[, <output separator>]])
 
-  This function returns information about a process id if the player
-  has permission to see the process. 
-  The <list of fields> is a space-separated list that may contain the
-  following elements:
-	queue       the queue ("wait" or "semaphore") for the process
-	player      the queueing player
-        time        remaining time for timed queued entries (or -1)
-        object      the semaphore object for semaphores (or #-1)
-        attribute   the semaphore attribute for semaphores (or #-1)
-        command     the queued command
-   If <list of fields> is not provided, all fields are returned.
-   If <output separator> is provided, the output is separated by
-   that delimiting character.
+  This function returns information about a process id if the player has 
+  permission to see the process. The <list of fields> is a space-separated 
+  list that may contain the following elements:
+  
+    queue       the queue ("wait" or "semaphore") for the process
+    player      the queueing player
+    time        remaining time for timed queued entries (or -1)
+    object      the semaphore object for semaphores (or #-1)
+    attribute   the semaphore attribute for semaphores (or #-1)
+    command     the queued command
+    
+  If <list of fields> is not provided, all fields are returned. The fields
+  are separated by <output separator>, which defaults to a space.  
 
 See also: @ps, lpids(), getpids()
 & PLAYERMEM()
@@ -3175,25 +3384,23 @@
 & PLAYER()
   player(<port>)
 
-  Returns the dbref of the player connected to a given port.  You must
-  be see_all or otherwise privleged to use this function on ports that
-  players besides yourself are using.
+  Returns the dbref of the player connected to a given port. Mortals can
+  only use this function on their own ports, while See_All players can use
+  it on any port.
 
 See also: lports(), ports()
 & PMATCH()
-  pmatch(<string>)
+  pmatch(<name>)
+  
+  pmatch() attempts to find a player called <name>, which should be the full
+  or partial name of a player (possibly prefixed with a "*") or a dbref.
+  First, it checks to see if <name> is the full name (or alias) of a player;
+  if so, their dbref is returned. Otherwise, it checks for partial matches
+  against the names of online players. If there are no matches, #-1 is
+  returned. If there are multiple matches, pmatch() returns #-2. Otherwise,
+  the matching player's dbref is returned.
  
-  Given the partial name of a connected player, returns that player's
-  dbref number. This partial name completion works similarly to the
-  partial name completion of the "page" command - i.e. it first
-  attempts to match the full names of all players (connected or not),
-  and if that fails, it tries to match the partial names of connected
-  players visible to the enactor. If no player is matched, it returns
-  "#-1". If more than one match is possible for a partial name, it
-  returns "#-2".
-
-  Pmatch() will also accept *<player> or #<db#>. If given a non-player
-  dbref #, pmatch() will return #-1.
+See also: num(), namelist(), locate()
 & POLL()
   poll()
 
@@ -3201,7 +3408,7 @@
 
 See also: @poll, doing(), @doing 
 & LPIDS()
-  lpids(<object>[,<queue type>])
+  lpids(<object>[, <queue type>])
 
   Returns a space-separated list of queue process ids enqueued by <object>,
   typically a player. If <queue type> is "w", only wait queue
@@ -3211,42 +3418,49 @@
 See also: @ps, getpids(), pidinfo()
 & LPORTS()
 & PORTS()
-  lports([<viewer>])
+  lports([<viewer>[, <status>]])
   ports(<player name>)
  
-  These function returns the list of descriptors ("ports") that are
-  used by connected players. lports() returns all ports, in the same
-  order as lwho() returns dbrefs, and ports() returns those a specific
-  player is connected to, from most recent to least recent. Only
-  players who are See_All or privileged may use these functions; in
-  other cases, lports() returns #-1, and ports() an empty list. As an
-  exception, players can use ports() on themselves. If lports() is
-  given a <viewer>, only the ports of connections which <viewer> can
-  see are returned (in the same order as dbrefs returned by
-  lwho(<viewer>)).
+  These functions return the list of descriptors ("ports") that are used by 
+  connected players. lports() returns all ports, in the same order as 
+  lwho() returns dbrefs, and ports() returns those a specific player is 
+  connected to, from most recent to least recent. Mortals can use ports()
+  on themselves, but only See_All players can use ports() on others, or use
+  lports().
+  
+  If lports() is given a <viewer>, only the ports of connections which
+  <viewer> can see are returned, in the same way as lwho(<viewer>) works.
+    
+  The <status> argument for lports() controls whether or not ports which
+  are not connected to (ie, at the login screen) are included, and must be
+  one of "all", "online" or "offline". Only See_All players can see
+  unconnected ports.
 
   These port numbers also appear in the wizard WHO, and can be used
-  with @boot/port, page/port, and the functions that return
-  information about a connection to make them use a specific
-  connection rather than the least-idle one when a player has multiple
-  connections open. Players can get information about their own
-  connections. See_all is needed to use them to get information about
-  other people's ports.
+  with @boot/port, page/port, and the functions that return information
+  about a connection to make them use a specific connection rather than 
+  the least-idle one when a player has multiple connections open. Players 
+  can get information about their own connections. See_all is needed to 
+  use them to get information about other people's ports.
 
-See also: player()
+See also: player(), Connection Functions
 & POS()
-  pos(<string1>, <string2>)
+  pos(<needle>, <haystack>)
 
-  This function returns the position that string1 begins in string2,
-  with the first position being 1.  If string1 is not in string2, then
-  it returns #-1.
+  This function returns the position that <needle> begins in <haystack>.
+  Unlike most other string functions, the first character of <haystack> is
+  numbered 1, not 0. If <needle> is not present in <haystack>, pos() returns
+  #-1.
   
+See also: member(), match()  
 & POSS()
 & %p
   poss(<object>)
 
   Returns the possessive pronoun - his/her/its - for an object. The %p
   substitution also returns the possessive pronoun of the enactor.
+  
+See also: subj(), obj(), aposs()
 & POWER()
   power(<number>, <exponent>)
  
@@ -3261,25 +3475,28 @@
   the object.  If the object does not exist, #-1 will be returned.
 
   The second form attempts to set <power> on <object>, as per @power.
-
+  
+See also: andlpowers(), orlpowers()
 & QUOTA()
   quota(<player>)  
   
   Returns the player's quota, the maximum number of objects they can
   create, if quotas are in effect. Returns 99999 for players with
   unlimited quotas, so it's safe to use in numerical comparisons.
+  
+See also: @quota, @squota, @allquota
 & R()
 & R-FUNCTION
   r(<register>)
   
-  The r() function is used to access "local registers", and returns
-  the contents of the specified register. There are 36 such registers,
-  numbered 0 through 9, and A through Z.
+  The r() function is used to access "local registers", and returns the 
+  contents of the specified register. There are 36 such registers, numbered 
+  0 through 9, and A through Z.
  
-  The '%qN' percent-substitution can also be used to access these
-  local registers, where N is register <register> needed.
+  The '%q<register>' percent-substitution can also be used to access these
+  local registers.
   
-  See 'HELP SETQ()' for details about registers.
+See also: setq(), letq()
 & RAND()
   rand(<num>)
   rand(<min>, <max>)
@@ -3287,81 +3504,83 @@
   Return a random number.
   
   The first form returns an integer between 0 and <num>-1, inclusive.
-  The second returns an integer between <min> and <max>,
-  inclusive. Both numbers must be positive.
+  The second returns an integer between <min> and <max>, inclusive. Both 
+  numbers must be positive.
 
   If called with an invalid argument, rand() returns an error message
   beginning with #-1.
+  
+See also: randword()
 & RANDWORD()
 & PICKRAND()
-  randword(<list>[,<delim>])
+  randword(<list>[, <delimiter>])
   
-  Returns a randomly selected element from <list>. <delim> is the list
-  delimiter: if not specified, whitespace delimits the list.
+  Returns a randomly selected element from <list>. Elements of the list are
+  separated by <delimiter>, which defaults to a space.
   
-  pickrand() may be an alias for randword() on some servers.
+  pickrand() is an alias for randword().
+  
+See also: rand()
 & REGEDIT()
 & REGEDITALL()
 & REGEDITI()
 & REGEDITALLI()
-  regedit(<string>, <regexp>, <replacement>[, ... , <regexpN>, <replaceN>])
-  regediti(<string>, <regexp>, <replacement>[, ... , <regexpN>, <replaceN>])
-  regeditall(<string>, <regexp>, <replacement>[, ... , <regexpN>, <replaceN>])
-  regeditalli(<string>, <regexp>, <replacement>[, ... , <regexpN>, <replaceN>])
+  regedit(<string>, <regexp>, <replace>[, ... , <regexpN>, <replaceN>])
+  regediti(<string>, <regexp>, <replace>[, ... , <regexpN>, <replaceN>])
+  regeditall(<string>, <regexp>, <replace>[, ... , <regexpN>, <replaceN>])
+  regeditalli(<string>, <regexp>, <replace>[, ... , <regexpN>, <replaceN>])
 
-  These functions are a version of edit() that uses regular
-  expressions.  The part of <string> that matches the <regexp> is
-  replaced by the evaluated <replacement>, with $<number> in
-  <replacement> expanded to the corresponding matching sub-expression
-  of <regexp>, with $0 the entire matched section. If you use named
-  sub-expressions (?P<foo>subexpr), they are referred with with $<foo>
-  (Note that the <>'s are literal).
- 
-  regedit() only replaces the first match. regeditall() replaces all
-  matches.  The versions ending in i are case insensitive. The
-  <replacement> argument is evaluated once for each match, allowing
-  for more complex transformations than is possible with straight
-  replacement.
+  These functions edit <string>, replacing the part of the string which
+  matches the regular expression <regexp> with the accompanying <replace>.
+  In <replace>, the string "$<number>" is expanded during evaluation to the
+  <number>th sub-expression, with $0 being the entire matched section. If you
+  use named sub-expressions (?P<name>subexpr), they are referred to with 
+  "$<name>". Note that, with named sub-expressions, the "<>" are literal.
+  
+  regedit() only replaces the first match, while regeditall() replaces all
+  matches. The versions ending in i are case insensitive. The <replace> 
+  argument is evaluated once for each match, allowing for more complex 
+  transformations than is possible with straight replacement.
 
   Examples:
-  > say regedit(this test is the best string, (?P<char>.)est, $<char>rash)
-  You say "this trash is the best string"
-  > say regeditall(this test is the best string, (.)est, [capstr($1)]rash)
-  You say "this Trash is the Brash string"
+    > say regedit(this test is the best string, (?P<char>.)est, $<char>rash)
+    You say "this trash is the best string"
+    > say regeditall(this test is the best string, (.)est, capstr($1)rash)
+    You say "this Trash is the Brash string"
 
-See also: edit(), regmatch()
+See also: edit(), regmatch(), regrab()
 & REGMATCH()
 & REGMATCHI()
   (Help text from TinyMUSH 2.2.4, with permission)
   regmatch(<string>, <regexp>[, <register list>])
   regmatchi(<string>, <regexp>[, <register list>])
  
-  This function matches the regular expression <regexp> against the
-  entirety of <string>, returning 1 if it matches and 0 if it does
-  not.  regmatchi() does the same thing, but case-insensitively.
+  This function matches the regular expression <regexp> against the entirety
+  of <string>, returning 1 if it matches and 0 if it does not.  regmatchi() 
+  does the same thing, but case-insensitively.
  
-  If <register list> is specified, there is a side-effect: any
-  parenthesized substrings within the regular expression will be set
-  into the specified local registers. The syntax for this is X:Y,
-  where X is the number (0 is the entire matched text) or name of the
-  substring, and Y is the q-register to save it in. If X: isn't given,
-  the nth substring based on the register's position in the list minus
-  one is used. The first element will have the complete matched text,
-  the second the first substring, and so on. This is to maintain
-  compatibility with old code; it's recommended for new uses that the
-  X:Y syntax be used.
+  If <register list> is specified, there is a side-effect: any parenthesized 
+  substrings within the regular expression will be set into the specified 
+  local registers. The syntax for this is X:Y, where X is the number (0 is 
+  the entire matched text) or name of the substring, and Y is the q-register
+  to save it in. If X: isn't given, the nth substring based on the 
+  register's position in the list minus one is used. The first element will 
+  have the complete matched text, the second the first substring, and so on.
+  This is to maintain compatibility with old code; it's recommended for new 
+  uses that the X:Y syntax be used.
 
-  For example, in regmatch( cookies=30 , (.+)=(\[0-9\]*) ) (note use
-  of escaping for MUSH parser), then the 0th substring matched is
-  'cookies=30', the 1st substring is 'cookies', and the 2nd substring
-  is '30'. If <register list> is '0:0 1:3 2:5', then %q0 will become
+  For example, in 
+  regmatch(cookies=30, (.+)=(\[0-9\]*) )
+  (note use of escaping for MUSH parser), then the 0th substring matched is
+  'cookies=30', the 1st substring is 'cookies', and the 2nd substring is
+  '30'. If <register list> is '0:0 1:3 2:5', then %q0 will become 
   "cookies=30", %q3 will become "cookies", and %q5 will become "30".
   If <register list> was '0:0 2:5', then the "cookies" substring would
   simply be discarded.
  
   See 'help regexp syntax' for an explanation of regular expressions.
 
-See also: regrab()
+See also: regrab(), regedit()
 & REMIT()
 & NSREMIT()
   remit(<object>, <message>)
@@ -3371,52 +3590,54 @@
 
   nsremit() is a wizard-only variation that works like @nsremit.
 & REMOVE()
-  remove(<list>, <word>[,<delimiter>])
-
-  Remove takes a list and a word, and returns the list, with the first
-  occurrence of the word deleted from it.
-
-  A word is defined as a string which contains no interior spaces (or
-  <delimiter>'s if <delimiter> is used).  If the word is not in the
-  list, then the list is returned. It is case-sensitive.
-
-  To remove all occurrences of a word from a string, consider
-  using edit().
+  remove(<list>, <words>[, <delimiter>])
 
+  This function removes the first occurance of every word in the list
+  <words> from <list>, and returns the resulting <list>. It is case 
+  sensitive.
+  
+  Elements of <list> and <words> are both separated by <delimiter>, which
+  defaults to a space.
+  
+See also: insert(), ldelete(), setdiff()
 & REPEAT()
   repeat(<string>, <number>)
   
-  This function simply repeats <string>, <number> times.  No spaces
+  This function simply repeats <string>, <number> times. No spaces
   are inserted between each repetition.
   
   Example:
-    > say [repeat(Test, 5)]
+    > say repeat(Test, 5)
     You say, "TestTestTestTestTest"
 
 See also: space()
 & REPLACE()
-  replace(<list>, <position>, <new item>[,<single-character separator>])
+  replace(<list>, <position>, <new item>[, <delimiter>])
   
-  This replaces the item at <position> of <list> with <new item>.  If
-  no separator is given, a space is assumed. Null items are counted
-  when determining position, as in 'items()'.
+  This replaces the item at <position> in <list> with <new item>. If no
+  <delimiter> is given, a space is assumed. Null items are counted
+  when determining position.
   
   Examples:
-    > say [replace(Turn north at the junction,2,south)]
+    > say replace(Turn north at the junction,2,south)
     You say, "Turn south at the junction"
-    > say [replace(blue|red|green|yellow,3,white,|)]
+    
+    > say replace(blue|red|green|yellow,3,white,|)
     You say, "blue|red|white|yellow"
   
 & REST()
-  rest(<list>[,<delimiter>])
+  rest(<list>[, <delimiter>])
 
   Returns a list minus its first element.
 
 See also: after(), first(), last()
 & REVWORDS()
-  revwords(<list of words>[,<delimiter>[, <output separator>]])
+  revwords(<list>[, <delimiter>[, <output separator>]])
  
-  This function reverses the order of words in a list.
+  This function reverses the order of words in a list. List elements are
+  separated by <delimiter>, which defaults to a space. Elements in the
+  reversed list are separated by <ouput separator>, which defaults to
+  the delimiter.
  
   Example:
     > say revwords(foo bar baz eep)
@@ -3426,16 +3647,16 @@
 & RIGHT()
   right(<string>, <length>)
 
-  Returns the <length> rightmost characters from string.
+  Returns the <length> rightmost characters from <string>.
 
 See also: left(), mid()
 & RJUST()
-  rjust(<string>, <length>[,<fill>])
+  rjust(<string>, <length>[, <fill>])
   
-  This function pads a string with leading characters
-  ("right-justifies") so it is <length> long. If <string> is longer
-  than <length>, the <string> is returned; it is not truncated. If
-  <fill> is not specified, a space is used.
+  This function pads a string with leading characters  ("right-justifies") 
+  so it is <length> long. If <string> is longer than <length>, the <string>
+  is returned; it is not truncated. <fill> can be more than one character
+  in length, and defaults to a space.
  
   Examples:
   
@@ -3446,12 +3667,15 @@
     You say, "
     0---foo7
     01234567"
+    
+    > say rjust(foo,12,=-)
+    You say, "=-=-=-=-=foo"
 
 See also: align(), center(), ljust()
 & RLOC()
   rloc(<object>, <levels>) 
   
-  This function may be used to the get the location of an object's
+  This function may be used to the get the location of <object>'s
   location (and on through the levels of locations), substituting for
   repeated nested loc() calls. <levels> indicates the number of
   loc()-equivalent calls to make; i.e., loc(loc(<object>)) is
@@ -3460,32 +3684,33 @@
   
   If rloc() encounters a room, the dbref of that room is returned. If
   rloc() encounters an exit, the dbref of that exit's destination is
-  returned.  It can also return the locations of controlled or nearby
-  objects, or of findable players.
- 
-  Related functions:  LOC(), WHERE(), ROOM()
+  returned.  You must control <object>, be near it, or it must be a
+  findable player.
  
+See also: loc(), where(), room(), rnum(), locate() 
 & RNUM()
-  rnum(<room number>, <object>)
+  rnum(<container>, <object>)
  
-  This function returns the dbref number of an object (player, thing,
-  or exit). The object must be in the specified room. This function is
-  essentially identical to NUM(), except it matches things in the
-  specified room rather than the room that you are in. The RNUM()
-  function is meant to be used in conjunction with Master Room
-  objects.
+  This function looks for an object called <object> located inside 
+  <container>. If a single matching object is found, its dbref is returned.
+  If several matching objects are found, #-2 is returned, and if nothing
+  matches, or you lack permission, #-1 is returned.
+  
+  You must be in <container>, or be able to examine it, to use this function.
 
+See also: locate(), num(), rloc(), room()
 & ROOM()
   room(<object>)
 
-  Returns the "absolute" location of an object. This is always a room;
-  it is the container of all other containers of the object. The
-  "absolute" location of an object is the place @lemit messages are
-  sent to and NO_TEL status determined.  You must control the object,
-  be a wizard or royalty, or be near the object in order for this
-  function to work. The exception to this are players; if <object> is
-  a player, the ROOM() function may be used to find the player's
-  absolute location if the player is not set UNFINDABLE.
+  Returns the "absolute" location of an object. This is always a room; it is 
+  the container of all other containers of the object. The "absolute" 
+  location of an object is the place @lemit messages are sent to and NO_TEL 
+  status determined.  You must control the object, be See_All, or be near 
+  the object in order for this function to work. The exception to this are 
+  players; if <object> is a player, the ROOM() function may be used to find 
+  the player's absolute location if the player is not set UNFINDABLE.
+
+See also: loc(), rloc(), rnum()
 & ROOT()
   root(<number>, <n>)
 
@@ -3507,40 +3732,41 @@
  
 See also: ceil(), floor(), bound(), trunc()
 & FN()
-  fn(<function name>,<arguments>...)
-
-  This function performs the given <function name> using only built-in
-  functions (that is, it prevents any @functions from being
-  evaluated). It is thus useful within @functions that override
-  built-ins in order to be able to call the built-in. Example:
+  fn(<function name>[, <arg0>[, ... , <argN>]])
 
-  > &BRIGHT_PEMIT #10 = [fn(pemit,%0,-->[ansi(h,%1)])]
-  > @function/delete PEMIT
-  > @function PEMIT=#10,BRIGHT_PEMIT
-  > think pemit(me,test)
-  -->test   (in highlighted letters)
+  fn() executes the built-in/hardcoded function <function name>, even if the
+  function has been disabled or overridden with @function. It is primarily 
+  useful within @functions that override built-ins in order to be able to 
+  call the built-in.
+  
+  Example:
+    > &BRIGHT_PEMIT #10=fn(pemit,%0,-->[ansi(h,%1)])
+    > @function/delete PEMIT
+    > @function PEMIT=#10,BRIGHT_PEMIT
+    > think pemit(me,test)
+    -->test   (in highlighted letters)
 
   To restrict the use of fn() to @functions only (to prevent players
   from skirting softcoded replacements), use @function/restrict
   fn=userfn.
 
-  See also: @function, RESTRICT
+See also: @function, RESTRICT
 & S()
 & S-FUNCTION
-  s(string)
-
-  This function performs evaluation on a string and returns that
-  string.  It should be considered extremely dangerous to use on a
-  string that you don't have complete control over (i.e., on user
-  input).  As usual, %n is the name, %s the subjective pronoun, %o the
-  objective, and %p the possessive.  Functions are evaluated.  It is
-  important to note that the pronoun is that of the triggering object.
-
-  So, if the ve of an object were: "[s(This is %n)], and I were to
-  type @trigger <object>/ve, it would return "This is <myname>", but
-  if vf were @trigger me/ve, then triggering the vf makes the ve
-  return "This is <object>"
+  s(<string>)
 
+  This function performs a second round of evaluation on <string>, and
+  returns the result. It should be considered extremely dangerous to use on
+  user input, or any other string which you don't have complete control over.
+  There are very few genuine uses for this function; things can normally be
+  achieved another, safer way.
+  
+  Example:
+    > &test me=$eval *: say When we eval %0, we get [s(%0)]
+    > eval \[ucstr(test)]
+    You say, "When we eval [ucstr(test)], we get TEST"
+  
+See also: objeval(), decompose()
 & SCAN()
   scan(<object>, <command>)
   scan(<command>)
@@ -3552,15 +3778,17 @@
 
   If no <object> is specified, this function works like @scan run
   by the function's executor.
-
 & SCRAMBLE()
   scramble(<string>)
 
-  This function scrambles a string, returning a random permutation of
-  its characters. For example, "[scramble(abcdef)]" might return
-  "cfaedb".  Note that this function does not pay any attention to
-  spaces or other special characters; it will scramble these
-  characters just like normal characters.
+  This function scrambles a string, returning a random permutation of its 
+  characters. Note that this function does not pay any attention to spaces 
+  or other special characters; it will scramble these characters just like 
+  normal characters.
+  
+  Example:
+  > say scramble(abcdef)
+  You say, "cfaedb"
 
 See also: shuffle()
 & SECS()
@@ -3570,31 +3798,33 @@
   seconds since midnight, January 1, 1970 UTC. UTC is the base time
   zone, formerly GMT. This is a good way of synchronizing things that
   must run at a certain time.
+
+See also: convsecs(), time()  
 & SECURE()
   secure(<string>)
 
   This function returns <string> with all "dangerous" characters
-  replaced by spaces. Dangerous characters are ( ) [ ] { } $ % , ^ and
-  ; This can make output slightly ugly, but it's a good way of
-  preventing other people from doing nasty things with your objects.
+  replaced by spaces. Dangerous characters are ( ) [ ] { } $ % , ^ and ;
+  This can make output slightly ugly, but it's a good way of preventing 
+  other people from doing nasty things with your objects.
 
 See also: decompose(), escape()
 & SET()
-  set(<object>, <flag>)
-  set(<object>/<attribute>, <attribute flag>)
+  set(<object>[/<attribute>], <flag>)
   set(<object>, <attribute>:<value>)
  
-  This function is equivalent to @set, and can be used to switch
-  flags, set attributes, and many other things.  The two arguments to
-  the function are the same as the arguments that would appear on
-  either side of the '=' in @set. This function returns nothing.
+  This function is equivalent to @set, and can be used to toggle flags and 
+  set attributes. The two arguments to the function are the same as the 
+  arguments that would appear on either side of the '=' in @set. This 
+  function returns nothing.
 
-  The attribute setting ability of set() is deprecated.  You should
+  The attribute-setting ability of set() is deprecated. You should
   use attrib_set() instead; it's easier to read, and allows you to
   clear attributes, too.
 
+See also: attrib_set(), @set, wipe()
 & SETDIFF()
-  setdiff(<list1>, <list2>[,<delimiter>[, <sort type>[, <osep>]]])
+  setdiff(<list1>, <list2>[, <delimiter>[, <sort type>[, <osep>]]])
  
   This function returns the difference of two sets -- i.e., the
   elements in <list1> that aren't in <list2>. The list that is
@@ -3610,7 +3840,7 @@
 
 See also: setinter(), setunion()
 & SETINTER()
-  setinter(<list1>, <list2>[,<delimiter>[, <sort type>[,<osep>]]])
+  setinter(<list1>, <list2>[, <delimiter>[, <sort type>[, <osep>]]])
  
   This function returns the intersection of two sets -- i.e., the
   elements that are in both <list1> and <list2>. The list that is
@@ -3627,39 +3857,36 @@
 See also: setdiff(), setunion()
 & SETQ()
 & SETR()
-  setq(<register>, <string>[, ... ,<regN>, <stringN>])
-  setr(<register>, <string>[, ... ,<regN>, <stringN>])
+  setq(<register>, <string>[, ... ,<registerN>, <stringN>])
+  setr(<register>, <string>[, ... ,<registerN>, <stringN>])
   
-  The setq() and setr() functions are used to copy strings into local
-  registers.  setq() returns a null string; it is a purely "side
-  effect" function.  setr() returns the value stored. Multiple
-  registers can be assigned with a single setq() or setr(), with
-  additional pairs of registers and values in the function's
-  arguments. In this case, setr() returns the value stored in the
-  first register listed.  All arguments are evaluated before any
-  registers are set; if you want to use the result of setting one
-  register in setting another, use multiple setq()s.
+  The setq() and setr() functions are used to copy strings into local 
+  registers. setq() returns a null string; it is a purely "side effect" 
+  function. setr() returns the value stored. Multiple registers can be 
+  assigned with a single setq() or setr(), with additional pairs of 
+  registers and values in the function's arguments. In this case, setr() 
+  returns the value stored in the first register listed. All arguments are 
+  evaluated before any registers are set; if you want to use the result of 
+  setting one register in setting another, use multiple setq()s.
 
-  There are thirty-six local registers, numbered 0 through 9 and A
-  through Z.  They are cleared at the start of each new queue cycle
-  (i.e. whenever a new command is evaluated). They are most useful for
-  storing complex function evaluations which are used repeatedly
-  within a single command.
+  There are thirty-six local registers, numbered 0 through 9 and A through Z.
+  They are cleared at the start of each new queue cycle (i.e. whenever a new 
+  command is evaluated). They are most useful for storing complex function 
+  evaluations which are used repeatedly within a single command.
 
   Registers set via setq() or setr() can be accessed via the r() function,
   or via the %qN percent-substitution.
 
-  See 'SETQ2' for examples of its use.
-
+  See 'help setq2' for examples.
 & SETQ2
 
   The setq() function is probably best used at the start of the string
   being manipulated, such as in the following example:
 
-    &TEST object=[strlen(%0)]
-    &CMD object=$test *:"[setq(0,u(TEST,%0))]Test. %0 has length %q0.
-    test Foo
-    > Object says, "Test. Foo has length 3."
+    > &TEST object=strlen(%0)
+    > &CMD object=$test *: say setq(0,u(TEST,%0))Test. %0 has length %q0.
+    > test Foo
+    Object says, "Test. Foo has length 3."
 
   In this case, it is a waste to use setq(), since we only use the
   function result once, but if TEST was a complex function being used
@@ -3672,44 +3899,40 @@
   Swapping the contents of registers can be done without writing to
   temporary registers by setting both registers at once, so the code:
 
-    think setq(0,foo,1,bar)%q0%q1 - [setq(0,%q1,1,%q0)]%q0%q1
-
-  yields "foobar - barfoo".
-
-  See 'SETQ3' for scoping rules of setq().
+    > think setq(0,foo,1,bar)%q0%q1 - [setq(0,%q1,1,%q0)]%q0%q1
+    foobar - barfoo
 
+  See 'help setq3' for scoping rules of setq().
 & SETQ3
-  The registers set by setq() can be used in later commands in the
-  same thread.  That is, the registers are set to null on all
-  $-commands, ^-commands, A-attribute triggers, etc., but are then
-  retained from that point forward through the execution of all your
-  code.  Code branches like @wait and @switch retain the register
-  values from the time of the branch, so the code:
-
-  say setr(a,foo); @wait 0=say %qa; say setr(a,bar)
-
-  produces the following when executed by an object:
-
-  Object says "foo"
-  Object says "bar"
-  Object says "foo"
+  The registers set by setq() can be used in later commands in the same 
+  thread. That is, the registers are set to null on all $-commands, 
+  ^-commands, A-attribute triggers, etc., but are then retained from that 
+  point forward through the execution of all your code.  Code branches like 
+  @wait and @switch retain the register values from the time of the branch.
+  
+  Example:
+    > say setr(a,foo); @wait 0=say %qa; say setr(a,bar)
+    Object says "foo"
+    Object says "bar"
+    Object says "foo"
 & SETUNION()
-  setunion(<list1>, <list2>[,<delimiter>[, <sort type>[, <osep>]]])
+  setunion(<list1>, <list2>[, <delimiter>[, <sort type>[, <osep>]]])
  
-  This function returns the union of two sets -- i.e., all the
-  elements of both <list1> and <list2>, minus any duplicate
-  elements. Think of it as CAT() without words duplicated.  The list
-  returned is sorted. Normally, alphabetic sorting is done. You can
-  change this with the fourth argument, which is a sort type as
-  defined in "help sorting". If used with exactly four arguments where
-  the fourth is not a sort type, it's treated instead as the output
+  This function returns the union of two sets -- i.e., all the elements of 
+  both <list1> and <list2>, minus any duplicate elements. The list returned 
+  is sorted. Normally, alphabetic sorting is done. You can change this with 
+  the fourth argument, which is a sort type as defined in "help sorting". 
+  If used with exactly four arguments where the fourth is not a sort type, 
+  it's treated instead as the output
   separator.
  
   Examples:
     > say setunion(foo baz gleep bar, bar moof gleep)
     You say, "bar baz foo gleep moof"
+
     > say setunion(1.1 1.0, 1.000)
     You say, "1.0 1.000 1.1"
+
     > say setunion(1.1 1.0, 1.000, %b, f)
     You say, "1.0 1.1"
 
@@ -3722,38 +3945,57 @@
 & SHL()
   shl(<number>, <count>)
 
-  Performs a leftwards bit-shift on <number>, shifting it <count>
-  times.  This is equivalent to mul(<number>,power(2,<count>), but
-  much faster.
+  Performs a leftwards bit-shift on <number>, shifting it <count> times. 
+  This is equivalent to mul(<number>,power(2,<count>), but much faster.
+  
+See also: shr()
 & SHR()
   shr(<number>, <count>)
 
-  Performs a rightwards bit-shift on <number>, shifting it <count>
-  times.  This is equivalent to div(<number>,power(2,<count>), but
-  much faster.
+  Performs a rightwards bit-shift on <number>, shifting it <count> times.
+  This is equivalent to div(<number>,power(2,<count>), but much faster.
+  
+See also: shl()
 & SHUFFLE()
-  shuffle(<list>[,<delimiter>[, <osep>]])
+  shuffle(<list>[, <delimiter>[, <osep>]])
   
   This function shuffles the order of the items of a list, returning a
-  random permutation of its elements. "[shuffle(foo bar baz gleep)]"
-  might evaluate to "baz foo gleep bar".
+  random permutation of its elements. 
+  
+  Example:
+    > say shuffle(foo bar baz gleep)
+    You say, "baz foo gleep bar"
 
-See also: scramble()
+See also: scramble(), pickrand()
 & SIGN()
   sign(<number>)
 
-  Essentially returns the sign of a number -- 0 if the number is 0, 1
-  if the number is positive, and -1 if the number is negative.  Thus,
-  SIGN(-4) is -1, SIGN(2) is 1, and SIGN(0) is 0.
+  Essentially returns the sign of a number -- 0 if the number is 0, 1 if the 
+  number is positive, and -1 if the number is negative. This is equivilent
+  to bound(<number>, -1, 1).
+  
+  Example:
+    > say sign(-4)
+    You say, "-1"
+    
+    > say sign(2)
+    You say, "1"
+    
+    > say sign(0)
+    You say, "0"
+  
+See also: abs(), bound
 & SIN()
-  sin(<angle>[,<angle type>)
+  sin(<angle>[, <angle type>])
  
   Returns the sine of <angle>, which should be expressed in the given
   angle type, or radians by default.
 
-  See 'HELP CTU()' for more on the angle type.
+  See 'HELP ANGLES' for more on the angle type.
+  
+See also: acos(), asin(), atan(), cos(), ctu(), tan()
 & SORT()
-  sort(<word1> [... <wordN>][, <sort type>[,<delimiter>[, <osep>]]])
+  sort(<list>[, <sort type>[, <delimiter>[, <osep>]]])
   
   This sorts a list of words. If no second argument is given, it will
   try to detect the type of sort it should do. If all the words are
@@ -3764,52 +4006,53 @@
   The second argument is a sort type. See 'help sorting'.
  
   The optional third argument gives the list's delimiter character.
-  If not present, <delimiter> defaults to a space.  The optional
+  If not present, <delimiter> defaults to a space. The optional
   fourth argument gives a string that will delimit the resulting list;
   it defaults to <delimiter>.
-
+  
+See also: sortby(), sortkey()
 & SORTBY()
-  sortby([<obj>/]<attrib>, <list>[,<delimiter>[, <output separator>]])
+  sortby([<obj>/]<attrib>, <list>[, <delimiter>[, <output separator>]])
  
-  This sorts an arbitrary list according to the u-function
-  <obj>/<attrib>.  This u-function should compare two arbitrary
-  elements, %0 and %1, and return zero (equal), a negative integer
-  (element 1 is less than element 2) or a positive integer (element 1
-  is greater than element 2).
+  This sorts an arbitrary list according to the ufun <obj>/<attrib>. This 
+  ufun should compare two arbitrary elements, %0 and %1, and return 
+  zero (equal), a negative integer (element 1 is less than element 2) or a 
+  positive integer (element 1 is greater than element 2), similar to the
+  comp() function.
  
   A simple example, which imitates a normal alphabetic sort:
-    > &ALPHASORT test=[comp(%0,%1)]
-    > say [sortby(test/ALPHASORT,foo bar baz)]
+    > &ALPHASORT test=comp(%0,%1)
+    > say sortby(test/ALPHASORT,foo bar baz)
     You say, "bar baz foo"
  
   A slightly more complicated sort. #1 is "God", #2 is "Amby", "#3" is "Bob":
-    > &NAMESORT me=[comp(name(%0),name(%1))]
-    > say [sortby(NAMESORT,#1 #2 #3)]
+    > &NAMESORT me=comp(name(%0),name(%1))
+    > say sortby(NAMESORT,#1 #2 #3)
     You say, "#2 #3 #1"
  
   Warning: the function invocation limit applies to this function. If
   this limit is exceeded, the function will fail _silently_. List and
   function sizes should be kept reasonable.
 
-See also: anonymous attributes, sorting, sortkey()
+See also: anonymous attributes, sorting, sort(), sortkey()
 & SORTKEY()
-  sortkey([<obj>/]<attrib>, <list>[, <sort type>[,<delimiter>[, <osep>]]])
+  sortkey([<obj>/]<attrib>, <list>[, <sort type>[, <delimiter>[, <osep>]]])
 
-  This function creates a list of keys by passing every element of
-  <list> into the u-function given in <attrib>. The list is then
-  sorted according to the sorting method in <sort type>, or is
-  automatically guessed.  (As per 'help sorting')
+  This function creates a list of keys by passing every element of <list> 
+  into the ufun given in <attrib>. The list is then sorted according to the 
+  sorting method in <sort type>, or is automatically guessed (as per 
+  'help sorting').
 
   This is equivalent to:
     > &munge_sort me=sort(%0,<sort type>)
-    > munge(munge_sort,map(<attrib>,<list>),<list>)
+    > munge(munge_sort, map(<attrib>, <list>), <list>)
 
-    Only there is no risk with delimiters ocurring within the list.
+  Only there is no risk with delimiters ocurring within the list.
 
   A simple example, which sorts players by their names:
     > @@ #1 is "God", #2 is "Amby", "#3" is "Bob"
     > &KEY_NAME me=name(%0)
-    > say sortkey(key_name,#1 #2 #3)
+    > say sortkey(key_name, #1 #2 #3)
     You say, "#2 #3 #1"
 
 See also: anonymous attributes, sorting, sortby()
@@ -3882,19 +4125,24 @@
 
   The soundslike function returns 1 if the two words have the same
   soundex code (see 'help soundex()' for information), which means, in
-  general, if they sound alike. For example:
+  general, if they sound alike. 
   
-  > think soundslike(robin,robbyn)
-  1
-  > think soundslike(robin,roebuck)
-  0
+  Example:
+    > think soundslike(robin,robbyn)
+    1
+    > think soundslike(robin,roebuck)
+    0
 
+See also: soundex()
 & SPACE()
   space(<number>)
  
-  Prints <number> number of spaces. Useful for times when you want to
-  be able to use lots of spaces to separate things. For example,
-  "a[space(5)]b would print, "Amberyl says, "a b"".
+  Prints <number> spaces. Useful for times when you want to be able to use 
+  lots of spaces to separate things. Same as [repeat(%b, <number>)].
+  
+  Example:
+    > say a[space(5)]b
+    Amberyl says, "a b"
 
 See also: repeat()
 & SPEAK()
@@ -4431,7 +4679,9 @@
   This function returns the elements of <list> in a tabular format.
   All other parameters are optional.
   <field width> specifies how wide each table entry is allowed to be.
-  It defaults to 10 characters
+  It defaults to 10 characters. If <field width> begins with a
+  <, it is left-aligned. > makes it right-aligned, and - makes it
+  centered.
   <line length> is how wide a table row can be. Default is 78 chars.
   <delimiter> is the delimiter used in <list>. Default is white space.
   <output separator> is a single character to be used between entries
@@ -4481,6 +4731,21 @@
 
   Players can use terminfo() on their own connections. Using it on
   other players is restricted to see_all objects.  
+& TESTLOCK()
+  testlock(<lock>, <victim>)
+
+  testlock() returns 1 if the <victim> would pass the lock defined in <lock>
+  as run by the executor, and 0 if it would fail.
+
+  testlock() evaluates the lock from executor's perspective.
+
+  For example:
+      think testlock(TYPE^PLAYER&FLAG^WIZARD, *Gandalf)
+      > 1
+      think testlock(TYPE^PLAYER&FLAG^WIZARD, *Bilbo)
+      > 0
+  
+See also: @lock, locktypes
 & TEXTFILE()
 & TEXTENTRIES()
 & dynhelp()
Index: game/txt/hlp/pennv183.hlp
===================================================================
--- game/txt/hlp/pennv183.hlp	(.../183p10)	(revision 142)
+++ game/txt/hlp/pennv183.hlp	(.../183p11)	(revision 142)
@@ -1,4 +1,4 @@
-& 1.8.3p10
+& 1.8.3p11
 & changes
 This is a list of changes in this patchlevel which are probably of
 interest to players. More information about new commands and functions
@@ -11,6 +11,106 @@
 A list of the patchlevels associated with each release can
 be read in 'help patchlevels'.
 
+Version 1.8.3 patchlevel 11                     Jan 01, 2010
+
+Major changes:
+  * The WHO, DOING and SESSION commands are now normal game commands,
+    and can be @hook'd, typed in lower-case, etc. (The WHO at the login
+    screen is separate.) If you have a softcoded 'who' command, you will
+    need to @hook/override WHO for it to continue working. Suggested by
+    Bane. [MG]
+  * The "take" command has been moved from the hardcode into alias.cnf.
+    If you want to keep it as an alias for "get", you should add the line
+    "command_alias get take" into your alias.cnf. [MG]
+
+Configuration:
+  * The *_file options (connect_file, motd_file, etc) can now be a
+    #dbref/attribute instead of a filename, in which case the given
+    attribute is evaluated and the result shown in place of the text file.
+    Based on patches by Nathan Baum and Mercutio@M*U*S*H. [MG]
+
+Commands:
+  * @decompile now takes multiple attribute patterns after the /
+    (@dec obj/attr attr2) [GM]
+  * @channel/decompile now shows the dbref of the channel mogrifier,
+    instead of its name. [SW]
+  * @pemit now takes a /port switch, which sends the message to the
+    specified port. Suggested by Mercutio. [MG]
+  * @hook/list without a <command> now shows all commands which have hooks.
+    Based on a patch by Trinsec. [MG]
+  * @search now takes multiple <class>=<restriction> pairs. [MG]
+  * The IDLE command now takes an optional argument, which it prints back
+    to the descriptor which sent the command. [MG]
+  * IDLE no longer increases the cmds() for a descriptor. [MG]
+
+Functions:
+  * die() now takes up to 700 dice.
+  * remove() will now remove a list of words.
+  * table() now supports <, > and - as alignment parameters to field width.
+  * testlock(<boolexp>, <victim>) tests a lock without setting it.
+    Suggested by Mercutio@M*U*S*H. [GM]
+  * lnum() now takes a fourth argument: A step. [GM]
+  * cwho() now takes an optional second argument, to control whether
+    online, offline or all players are returned. Suggested by Mercutio,
+    based on a patch by Ifrit. [MG]
+  * room(<room>) now returns <room>, instead of #-1. Also, room(<exit>)
+    returns the exit's source room, rather than the destination. Suggested
+    by Null@M*U*S*H. [MG]
+  * Fixed a bug in how align() strips spaces when wrapping text. Reported
+    by Paige@M*U*S*H. [MG]
+  * pemit(<port number>, <message>) sends <message> to the specified
+    port, like @pemit/port. Suggested by Mercutio. [MG]
+  * lports() and lwho() take an optional second argument to include
+    connections at the login screen. Suggested by Mercutio. [MG]
+  * namelist() now takes an optional #dbref/attr, called for each invalid
+    name in the first argument. [MG]
+  * lmath() can now do lt, lte, gt, gte, eq and neq. Also, lt(), lte(),
+    etc, can all take more than 2 arguments. [GM]
+  * Anyone can now use ctime() on any object. [MG]
+  * locks() reported built-in locks as being user: locks. [MG]
+
+Fixes:
+  * Help fixes by various folks.
+  * lsearch() with invalid syntax was failing to report it as such, causing
+    confusion when lsearch(me,exits) returned the same as lsearch(me). [GM]
+  * fun_merge() was eating characters when ansi was present. Reported
+    by Nammyung. Fixed. [GM]
+  * Windows compile fixes.
+  * Math-y crashbug fixed. Reported by Ghost@M*U*S*H. [GM]
+  * page/port didn't evaluate its arguments properly. Reported
+    by adkins@drigon.com. [SW]
+  * randword() with a single element list wasn't dealing correctly
+    with extra spaces. Reported by Minion. [SW]
+  * @listen/^-listens should now be triggered with the object being
+    spoofed as %#, not the object doing the spoofing, when @message/spoof
+    (and @pemit/spoof, etc) are used. Reported by Mercutio@M*U*S*H. [MG]
+  * Fixed some minor type-related warnings when compiling on cygwin. [MG]
+  * @functions which were set "localize" would report being set "Userfn"
+    as well, and functions set "Userfn" weren't reported as such. [MG]
+  * Objects could be set with flags which weren't valid for their object
+    type, if such flags were in the <type>_flags config option. Found by
+    Kitai. [MG]
+  * Crashbug in the command parser fixed. Found by Freon, patch by Javelin.
+  * Added some missing punctuation in channel messages. Reported by Stoko.
+
+   
+ Minor changes:
+  * @listen/^-listens now carry over ANSI. Requested by Mercutio. [MG]
+  * @adisconnect now has %5, which is true if the disconnecting descriptor
+    was @hide. Suggested by Minion@M*U*S*H [GM]
+  * @pemit <name>= would show nospoof info if <name> was set Nospoof. Now,
+    it does nothing at all. Reported by Minion. [MG]
+  * The connect screen can now contain ANSI color. Patch by Mercutio.
+  * Small bug fix in @search. [MG]
+  * Built-in functions can be set FN_LOCALIZE to preserve %q-regs. [MG]
+  * Refactoring of ufun(), ulocal(), u[l]default() and ulambda(). [MG]
+  * The "Not enough money to queue command" message tells you which object
+    was attempting to queue the command. Suggested by Daniel Powell. [MG]
+
+Tools:
+  * New script in utils/ for searching change logs: grep-cl.pl [SW]
+
+& 1.8.3p10
 Version 1.8.3 patchlevel 10                     Aug 24, 2009
 
 Major changes:
Index: game/txt/hlp/penntop.hlp
===================================================================
--- game/txt/hlp/penntop.hlp	(.../183p10)	(revision 142)
+++ game/txt/hlp/penntop.hlp	(.../183p11)	(revision 142)
@@ -16,10 +16,11 @@
 
   On many MUSHes, list local commands with:       +help
 
-If there are any errors in the help text, please notify a wizard in
-the game, or send mail to pennmush-bugs@pennmush.org, which is the
-address of the team who develop PennMUSH (and its distributed help
-files) but probably have no relation to this MUSH in particular.
+  If there are any errors in the help text, please notify a wizard in
+  the game, or file a report at
+  http://code.google.com/p/pennmush/issues/list, which is the
+  bug-tracking site for PennMUSH (and its distributed help files) but
+  probably has no relation to this MUSH in particular.
 
 & newbie
 
@@ -235,7 +236,7 @@
   The following functions support anonymous attributes:
   
   filter()    filterbool()   fold()      foreach()   map()      mapsql()
-  mix()       munge()        sortby()    sortkey()   step()
+  mix()       munge()        namelist()  sortby()    sortkey()  step()
 & ATTRIB-OWNERSHIP
   ATTRIBUTE OWNERSHIP
   
Index: game/txt/hlp/penncmd.hlp
===================================================================
--- game/txt/hlp/penncmd.hlp	(.../183p10)	(revision 142)
+++ game/txt/hlp/penncmd.hlp	(.../183p11)	(revision 142)
@@ -6,8 +6,8 @@
   give           go             index          kill           leave          
   LOGOUT         look           move           news           page           
   pose           QUIT           read           rules          say
-  score          slay           take           teach          think          
-  unfollow       use            whisper        WHO            with
+  score          slay           teach          think          unfollow
+  use            whisper        WHO            with
   "              :              ;              +              ]
  
   In addition to these, there are several types of '@' commands. @-commands 
@@ -200,6 +200,7 @@
   %2 = bytes received by the disconnecting descriptor
   %3 = bytes sent by the disconnecting descriptor
   %4 = commands issued by the disconnecting descriptor
+  %5 = 1 if the descriptor was hidden on disconnect, 0 otherwise
 
 See also: @aconnect, ACTION LISTS, recv(), sent(), cmds()
 & @adrop
@@ -868,8 +869,8 @@
 
 See also: kill, BEING KILLED, @odeath, @adeath
 & @decompile
-  @decompile[</switch>] <object>[/<attribute-pattern>]
-  @decompile/prefix <object>[/<attribute-pattern>]=<prefix>
+  @decompile[</switch>] <object>[/<attribute-patterns>]
+  @decompile/prefix <object>[/<attribute-patterns>]=<prefix>
 
   This command produces a list of the commands that you would have to
   enter in order to recreate <object>. Useful for either copying objects
@@ -883,10 +884,10 @@
   You can either @decompile an entire object, or just certain parts of it.
   To @decompile just a few attributes, for example, you could type:
 
-      @decompile <object>/<attribute name>
+      @decompile <object>/<attribute name> <attribute name2>
 
-  for each attribute. You can also use wildcards in <attribute name> to
-  @decompile a list of similarly-named attributes.
+  including each attribute. You can also use wildcards in
+  <attribute name(s)> to @decompile a list of similarly-named attributes.
 
 (continued in help @decompile2)
 & @decompile2
@@ -1693,7 +1694,7 @@
 See also: enter, @enter, ENTER_OK, @describe, look, @idescformat
 & @hook
   @hook/<switch> <command>[=<object>, <attribute>]
-  @hook/list <command>
+  @hook/list [<command>]
 
   @hook tells the command parser to evaluate given attributes at certain points
   in command evaluation. The possible points, indicated by the proper switch:
@@ -2779,6 +2780,8 @@
     /spoof     -- the enactor's dbref will be used for nospoof notifications
                   instead of the executor's dbref. Requires control
                   over enactor or Can_nspemit power. 
+    /port      -- <object> is taken to be a port number, instead of a dbref,
+                  and the message is only sent to that port. Wiz/roy only.
 
   Note that page-lock and the HAVEN flag will block @pemits as well, 
   except from Wizards or those with the pemit_all power.
@@ -3002,41 +3005,44 @@
      /zone     --   just matches on zones of your location and yourself.
      /globals  --   just matches on objects in the master room.
 & @search
-  @search [<player>] [<class>=<restriction>] [,<begin>,<end>]
+  @search [<player>] [<classN>=<restrictionN>[,...]][,<begin>,<end>]
   
   This command searches the database and lists objects which meet user
   specified search criteria.  You can limit the scope of the search by
   specifying <begin> and <end> as the first and last dbrefs to search.
   
   If a <player> argument is supplied, only objects owned by that player
-  will be listed. If a <class> argument is supplied only objects of a
-  certain class will  be listed. Possible <class>es include TYPE, NAME,
-  ZONE, PARENT, EXITS, OBJECTS (Or THINGS), ROOMS, PLAYERS, FLAGS, LFLAGS,
-  POWERS, ELOCK, COMMAND, LISTEN, EVAL, EPLAYER, EROOM, EEXIT, and EOBJECT
-  (Or ETHING).
+  will be listed.  Mortals can only search themselves or a ZMP whose
+  @lock/zone they pass. Those with the Search power can also specify "all"
+  to search all players. Defaults to "me" for mortals, and "all" for
+  players with the Search power.
+  
+  <class> and <restriction> arguments can be given to filter the match
+  results. Possible <class>es include TYPE, NAME, ZONE, PARENT, EXITS,
+  THINGS (or OBJECTS), ROOMS, PLAYERS, FLAGS, LFLAGS, POWERS, ELOCK,
+  COMMAND, LISTEN, EVAL, EPLAYER, EROOM, EEXIT, and ETHING (or EOBJECT).
 
-  If <class>=TYPE, possible <restriction>s include OBJECT (Or THING), ROOM,
+  If <class>=TYPE, possible <restriction>s include THING (or OBJECT), ROOM,
   EXIT, PLAYER, GARBAGE. This shows all objects of the specified type.
   
   If <class>=NAME, only objects whose name begin with the string <restriction>
-  will be listed. If <class>=ZONE, only objects in the zone <restriction>
-  will be listed. If <class>=PARENT, only children of parent <restriction>
-  will be listed. For ZONE and PARENT, <restriction> must be specified as a
-  dbref number.
+  will be listed. If <class>=EXITS, OBJECTS, ROOMS or PLAYERS, only objects
+  of that type whose name begins with <restriction> are listed.
+  
+  If <class>=ZONE, only objects in the zone <restriction> will be listed.
+  If <class>=PARENT, only children of parent <restriction> will be listed.
+  For ZONE and PARENT, <restriction> must be specified as a dbref number.
   
   'help @search2' for more.
 & @search2
-  If <class>=EXITS, OBJECTS, ROOMS, or PLAYERS, only objects of that type
-  will be listed.
-
   If <class>=FLAGS or LFLAGS, only objects with the list of flags
   specified by <restriction> will be listed. For FLAGS, flags to match
   should be given as a string of single flag letters, with appropriate
   case. For LFLAGS, flags to match should be given as a space-separated
   list of flag names.
 
-  If <class>=POWERS, only objects with the given power are listed. Only
-  one power may be specified.
+  If <class>=POWERS, only objects with the given powers are listed.
+  <restriction> should be a space-separated list of power names.
 
   If <class>=ELOCK, only objects that pass the given lock string (as in
   help @lock) are listed. For purposes of indirect locks (@#123), 'search'
@@ -3045,7 +3051,7 @@
   If <class>=EVAL, only objects for which <restriction> evaluates to a
   true boolean value will be listed. The token '##' in <restriction>, which
   is a function, is replaced by each dbref sequentially. Classes EPLAYER,
-  EROOM, EEXIT, and EOBJECT work like EVAL but are restricted to a single type.
+  EROOM, EEXIT, and ETHING work like EVAL but are restricted to a single type.
   
   See "help @search3" for more.
 & @search3
@@ -3072,18 +3078,20 @@
   obtain information about other players, and players who pass a ZMP's
   zone-lock may obtain information about the ZMP.
 
-  Only one of any class can be specified. EVAL, EPLAYER, etc. all override
-  each other.
+  If multiple <class> and <restrictions> are given, objects must meet all
+  criteria in order to match successfully. The exception to this is that if
+  multiple 'type' searches (PLAYER, EROOM, etc) are used, only the last
+  type given is used in the search.
 
   @search is only mildly computationally expensive for most of the search
   classes.  computationally expensive searches are the evaluating searches
-  (EVAL, EPLAYER, ETHING/EOBJECT, EROOM, EEXIT) or the attribute pattern
+  (EVAL, EPLAYER, ETHING, EROOM, EEXIT) or the attribute pattern
   searches (COMMAND, LISTEN)
   
   See "help @search5" for some examples.
 & @search5
   Examples:  
-    @search flags=Wc      <-- search for connected wizards.
+    @search all type=player,flags=W      <-- list all Wizard players
     @search type=room     <-- list all rooms owned by me.
     @search zone=#50      <-- list all objects belong to zone #50.
     @search Joe eval=1,100,200   <-- list objects from #100-#200 owned by Joe.
@@ -3776,16 +3784,6 @@
   cv is a variant that forces a non-dark, non-hidden connection.
 
 See also: DARK, @hide
-& DOING
-  DOING
-
-  This command displays the list of players currently connected to the
-  MUSH. For mortals, it is identical to WHO. For wizards, it displays
-  the WHO in the format mortals see. The wizard WHO shows location and
-  host, but does not show @doing messages. DOING shows @doing messages
-  but not location or host.
-
-See also: WHO, @poll, @doing
 & OUTPUTPREFIX
 & OUTPUTSUFFIX
   OUTPUTPREFIX <string>
@@ -3796,7 +3794,7 @@
   respectively. They are primarily useful for bots and the like.
 
 & IDLE
-  IDLE
+  IDLE [<string>]
 
   This command does nothing. It does not reset a connection's
   idle time. It is useful for people who are connecting from behind
@@ -3804,19 +3802,12 @@
   have your client send the IDLE command every minute or so, and the 
   NAT connection won't time out (but you won't appear, to other players,
   to be active).
-
-& SESSION
-  SESSION
-
-  This admin-only form of WHO includes information on how much text
-  has been received and sent to the connections. It has three fields:
-
-  Sent, which is the number of characters sent TO the mush from that
-  connection. Recv, the number of characters sent FROM the mush to that
-  connection, and Pend, the number of characters still waiting to be sent
-  from the mush to the connection.
-
-See also: WHO, DOING
+  
+  Some routers will only consider a connection alive if text is received,
+  as well as sent. If you give a <string> with the IDLE command, that same
+  <string> will be sent back to you for this purpose.
+  
+See also: KEEPALIVE, @idle
 & teach
   teach <command>
 
@@ -3948,14 +3939,20 @@
 & get
 & take
   get <object>
-  take <object>
+  get <box>'s <object>
 
-  You pick up object, if you pass the object's @lock and the
-  container's @lock/take (if set). You can also do get <thing>'s
-  <object>, which will fail if thing is not ENTER_OK, thing has a
-  take-lock that blocks you, or object is locked against you. Some
-  MUSHes choose to disable the ability to take an object in someone
-  else's inventory.
+  The first form of this command lets you pick up <object> from your
+  current location. The second form allows you to take <object> from
+  inside <box>'s inventory.
+  
+  In both cases, you must pass <object>'s Basic @lock, and the
+  @lock/take of it's location.
+  
+  To get an object from someone else's inventory, the possessive_get
+  @config option must be true (and, if <box> is a disconnected player,
+  so must possessive_get_d). <box> must also be set ENTER_OK.
+  
+  'take' is usually an alias for the 'get' command.
 
 See also: @lock, ENTER_OK, give, drop, @success, inventory
 & @abuy
@@ -4214,9 +4211,9 @@
   The /noeval switch prevents the MUSH from evaluating the message.
   The /override switch is admin-only, and overrides pagelocks and
   HAVEN.
-  The /port switch is admin-only, and will page a port descriptor
-  directly, including connections that have not yet logged into a
-  player.
+  The /port switch is admin-only, and will page a single port
+  descriptor directly, including connections that have not yet logged
+  into a player.
   
 See also: @lock, @alias, @pageformat, pose, :, ;, HAVEN, NOSPOOF, FLAGS
 & :
@@ -4346,13 +4343,38 @@
   persons should be space-separated, and names with spaces should be
   enclosed in double-quotes.
 & WHO
-  WHO   
+& DOING
+  WHO [<prefix>]
+  DOING [<prefix>]
+  
+  For mortals, the WHO command displays a list of players currently
+  connected to the MUSH, the amount of time they've been connected,
+  their idle time, and their @doing. Dark/hidden players are not shown.
+  
+  For admin, WHO shows the names of online players, their location,
+  connection/idle times, the number of commands typed through the
+  connection, the descriptor/port number, and the host the player is 
+  connected from. It also includes dark/hidden players, and connections
+  which are at the login screen, but have not yet connected to a player.
+  
+  Admin can use the DOING command to see the same output mortals see with
+  WHO, with the exception that dark/hidden players are included.
+  
+  If a <prefix> is given for either command, only connected players whose
+  names start with <prefix> are shown.
+  
+  Note: The in-game WHO is a normal game command, and is completely separate
+  from the WHO command which can be used at the connect screen.
 
-  Displays a list of players currently connected to the MUSH.  The WHO
-  tells you how long a player has been on and how long they have been
-  inactive. Unlike most commands, it is case sensitive.
+See also: @doing, @poll, SESSION
+& SESSION
+  SESSION [<prefix>]
 
-See also: @doing, @poll, DOING
+  The SESSION command is the same as the admin WHO, but instead of showing
+  the hostname, it shows the number of bytes sent to, received from, and
+  pending for each connection.
+
+See also: WHO
 & with
   with[/room] <obj>=<command>
 
@@ -4367,10 +4389,12 @@
   connection and would be meaningless if run by an object or
   disconnected player.
 
-  DOING	    IDLE      LOGOUT     OUTPUTPREFIX OUTPUTSUFFIX QUIT
-  SESSION   WHO
+  IDLE      LOGOUT     OUTPUTPREFIX OUTPUTSUFFIX QUIT
 
   In addition, the following commands can only be used at the login
   screen:
 
-  cd ch connect create 
+  cd ch connect create
+  
+  The WHO command can also be used at the login screen. Please note that
+  this is different to the in-game WHO command.
Index: game/txt/hlp/pennvOLD.hlp
===================================================================
--- game/txt/hlp/pennvOLD.hlp	(.../183p10)	(revision 142)
+++ game/txt/hlp/pennvOLD.hlp	(.../183p11)	(revision 142)
@@ -4417,7 +4417,7 @@
 For information on a specific patchlevel of one of the versions listed,
 type 'help <version>p<patchlevel>'. For example, 'help 1.7.2p3'
 
-1.8.3: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
+1.8.3: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
 1.8.2: 0, 1, 2, 3, 4, 5, 6, 7, 8
 1.8.1: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
 1.8.0: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
Index: game/aliascnf.dst
===================================================================
--- game/aliascnf.dst	(.../183p10)	(revision 142)
+++ game/aliascnf.dst	(.../183p11)	(revision 142)
@@ -36,6 +36,7 @@
 command_alias goto move
 command_alias @atrlock @attrlock
 command_alias @atrchown @attrchown
+command_alias get take
 
 # As well as commands, functions can be aliased. Same syntax,
 # just function_alias instead of command_alias. Note that many
Index: game/mushcnf.dst
===================================================================
--- game/mushcnf.dst	(.../183p10)	(revision 142)
+++ game/mushcnf.dst	(.../183p11)	(revision 142)
@@ -441,7 +441,9 @@
 # Text files shown on connection, as message of the day,
 # as wizard message of the day, on quit, to newly created players,
 # when logins are disabled, when player creation is disabled,
-# and when a guest logs in.
+# and when a guest logs in. These must either be the path to
+# a text file, or a #dbref/attrname to be evaluated and shown.
+# dbref/attrs are passed the port/descriptor as %0.
 connect_file txt/connect.txt
 motd_file txt/motd.txt
 wizmotd_file txt/wizmotd.txt
Index: CHANGES.183
===================================================================
--- CHANGES.183	(.../183p10)	(revision 142)
+++ CHANGES.183	(.../183p11)	(revision 142)
@@ -16,6 +16,105 @@
 
 ==========================================================================
 
+Version 1.8.3 patchlevel 11                     Jan 01, 2010
+
+Major changes:
+  * The WHO, DOING and SESSION commands are now normal game commands,
+    and can be @hook'd, typed in lower-case, etc. (The WHO at the login
+    screen is separate.) If you have a softcoded 'who' command, you will
+    need to @hook/override WHO for it to continue working. Suggested by
+    Bane. [MG]
+  * The "take" command has been moved from the hardcode into alias.cnf.
+    If you want to keep it as an alias for "get", you should add the line
+    "command_alias get take" into your alias.cnf. [MG]
+
+Configuration:
+  * The *_file options (connect_file, motd_file, etc) can now be a
+    #dbref/attribute instead of a filename, in which case the given
+    attribute is evaluated and the result shown in place of the text file.
+    Based on patches by Nathan Baum and Mercutio@M*U*S*H. [MG]
+
+Commands:
+  * @decompile now takes multiple attribute patterns after the /
+    (@dec obj/attr attr2) [GM]
+  * @channel/decompile now shows the dbref of the channel mogrifier,
+    instead of its name. [SW]
+  * @pemit now takes a /port switch, which sends the message to the
+    specified port. Suggested by Mercutio. [MG]
+  * @hook/list without a <command> now shows all commands which have hooks.
+    Based on a patch by Trinsec. [MG]
+  * @search now takes multiple <class>=<restriction> pairs. [MG]
+  * The IDLE command now takes an optional argument, which it prints back
+    to the descriptor which sent the command. [MG]
+  * IDLE no longer increases the cmds() for a descriptor. [MG]
+
+Functions:
+  * die() now takes up to 700 dice.
+  * remove() will now remove a list of words.
+  * table() now supports <, > and - as alignment parameters to field width.
+  * testlock(<boolexp>, <victim>) tests a lock without setting it.
+    Suggested by Mercutio@M*U*S*H. [GM]
+  * lnum() now takes a fourth argument: A step. [GM]
+  * cwho() now takes an optional second argument, to control whether
+    online, offline or all players are returned. Suggested by Mercutio,
+    based on a patch by Ifrit. [MG]
+  * room(<room>) now returns <room>, instead of #-1. Also, room(<exit>)
+    returns the exit's source room, rather than the destination. Suggested
+    by Null@M*U*S*H. [MG]
+  * Fixed a bug in how align() strips spaces when wrapping text. Reported
+    by Paige@M*U*S*H. [MG]
+  * pemit(<port number>, <message>) sends <message> to the specified
+    port, like @pemit/port. Suggested by Mercutio. [MG]
+  * lports() and lwho() take an optional second argument to include
+    connections at the login screen. Suggested by Mercutio. [MG]
+  * namelist() now takes an optional #dbref/attr, called for each invalid
+    name in the first argument. [MG]
+  * lmath() can now do lt, lte, gt, gte, eq and neq. Also, lt(), lte(),
+    etc, can all take more than 2 arguments. [GM]
+  * Anyone can now use ctime() on any object. [MG]
+  * locks() reported built-in locks as being user: locks. [MG]
+
+Fixes:
+  * Help fixes by various folks.
+  * lsearch() with invalid syntax was failing to report it as such, causing
+    confusion when lsearch(me,exits) returned the same as lsearch(me). [GM]
+  * fun_merge() was eating characters when ansi was present. Reported
+    by Nammyung. Fixed. [GM]
+  * Windows compile fixes.
+  * Math-y crashbug fixed. Reported by Ghost@M*U*S*H. [GM]
+  * page/port didn't evaluate its arguments properly. Reported
+    by adkins@drigon.com. [SW]
+  * randword() with a single element list wasn't dealing correctly
+    with extra spaces. Reported by Minion. [SW]
+  * @listen/^-listens should now be triggered with the object being
+    spoofed as %#, not the object doing the spoofing, when @message/spoof
+    (and @pemit/spoof, etc) are used. Reported by Mercutio@M*U*S*H. [MG]
+  * Fixed some minor type-related warnings when compiling on cygwin. [MG]
+  * @functions which were set "localize" would report being set "Userfn"
+    as well, and functions set "Userfn" weren't reported as such. [MG]
+  * Objects could be set with flags which weren't valid for their object
+    type, if such flags were in the <type>_flags config option. Found by
+    Kitai. [MG]
+  * Crashbug in the command parser fixed. Found by Freon, patch by Javelin.
+  * Added some missing punctuation in channel messages. Reported by Stoko.
+
+   
+ Minor changes:
+  * @listen/^-listens now carry over ANSI. Requested by Mercutio. [MG]
+  * @adisconnect now has %5, which is true if the disconnecting descriptor
+    was @hide. Suggested by Minion@M*U*S*H [GM]
+  * @pemit <name>= would show nospoof info if <name> was set Nospoof. Now,
+    it does nothing at all. Reported by Minion. [MG]
+  * The connect screen can now contain ANSI color. Patch by Mercutio.
+  * Small bug fix in @search. [MG]
+  * Built-in functions can be set FN_LOCALIZE to preserve %q-regs. [MG]
+  * Refactoring of ufun(), ulocal(), u[l]default() and ulambda(). [MG]
+  * The "Not enough money to queue command" message tells you which object
+    was attempting to queue the command. Suggested by Daniel Powell. [MG]
+
+Tools:
+  * New script in utils/ for searching change logs: grep-cl.pl [SW]
+
 Version 1.8.3 patchlevel 10                     Aug 24, 2009
 
 Major changes:
Index: utils/grep-cl.pl
===================================================================
--- utils/grep-cl.pl	(.../183p10)	(revision 0)
+++ utils/grep-cl.pl	(.../183p11)	(revision 142)
@@ -0,0 +1,79 @@
+#!/usr/bin/perl -w
+
+# Tool to grep changelogs and show what versions mention a given string.
+
+use strict;
+use Getopt::Std;
+
+sub HELP_MESSAGE {
+    print STDERR <<EOH;
+Usage: $0 [OPTIONS] REGEXP
+
+Searches Penn help files for occurrences of a regular expression and
+display the results in a smart fashion. Run from the base PennMUSH
+directory.
+
+Options:
+
+    -i: Ignore case.
+    -b: Anchor the search regexp with word-boundries to avoid partial matches.
+    -p: Print each matching line instead of a summary.
+--help: This message.
+
+EOH
+exit 0;
+}
+
+our ($opt_i, $opt_b, $opt_p);
+
+die "Unknown option given.\n" unless getopts("ibp");
+
+my $string = "@ARGV";
+my @files = glob "CHANGES.*";
+my $matches = 0;
+my $pattern = "";
+
+# Massage the search string per options. This approach will quickly
+# grow unmanageable with many more.
+if ($opt_i) {
+    if ($opt_b) {
+	$pattern = qr/\b$string\b/i;
+    } else {
+	$pattern = qr/$string/i;
+    }
+} else {
+    if ($opt_b) {
+	$pattern = qr/\b$string\b/;
+    } else {
+	$pattern = qr/$string/;
+    }
+}
+
+foreach my $file (@files) {
+    open CHANGELOG, "<", $file 
+	or (warn "Unable to open $file: $!\n" && next);
+    my $version = "Unknown";
+    my $vmatches = 0;
+    while (<CHANGELOG>) {
+	if (/^Version (\d[\d.]+ patchlevel \d+)/) {
+	    print "Found $vmatches occurrences in $version\n" if $vmatches > 0 && !$opt_p;
+	    $version = $1;
+	    $vmatches = 0;
+	    next;
+	}
+	if (/$pattern/) {
+	    $matches++;
+	    $vmatches++;
+	    if ($opt_p) {
+		print "In version $version:\n" if $vmatches == 1;
+		print;
+	    }
+	}	
+    }
+    print "Found $vmatches occurrences in $version\n" if $vmatches > 0 && !$opt_p;
+    close CHANGELOG;
+}
+
+
+print "No occurrences of '$string' found.\n" if $matches == 0;
+

Property changes on: utils/grep-cl.pl
___________________________________________________________________
Added: svn:executable
   + *

Index: utils/README.txt
===================================================================
--- utils/README.txt	(.../183p10)	(revision 142)
+++ utils/README.txt	(.../183p11)	(revision 142)
@@ -19,6 +19,8 @@
   
 gentables.c:  Compiles into a program used to make src/tables.c
 
+grep-cl.pl: Perl script to search for strings in changelogs.
+
 ln-dir.sh:    A manual alternative to make customize. Kinda.
 
 make_access_cnf.sh: Script used to update ancient versions of Penn
Index: hdrs/funs.h
===================================================================
--- hdrs/funs.h	(.../183p10)	(revision 142)
+++ hdrs/funs.h	(.../183p11)	(revision 142)
@@ -1,382 +0,0 @@
-/* AUTOGENERATED FILE. DO NOT EDIT! */
-#ifndef FUNS_H
-#define FUNS_H
-FUNCTION_PROTO(fun_abs);
-FUNCTION_PROTO(fun_accent);
-FUNCTION_PROTO(fun_accname);
-FUNCTION_PROTO(fun_acos);
-FUNCTION_PROTO(fun_add);
-FUNCTION_PROTO(fun_after);
-FUNCTION_PROTO(fun_alias);
-FUNCTION_PROTO(fun_align);
-FUNCTION_PROTO(fun_allof);
-FUNCTION_PROTO(fun_alphamax);
-FUNCTION_PROTO(fun_alphamin);
-FUNCTION_PROTO(fun_and);
-FUNCTION_PROTO(fun_andflags);
-FUNCTION_PROTO(fun_andlflags);
-FUNCTION_PROTO(fun_ansi);
-FUNCTION_PROTO(fun_ansiinspect);
-FUNCTION_PROTO(fun_aposs);
-FUNCTION_PROTO(fun_art);
-FUNCTION_PROTO(fun_asin);
-FUNCTION_PROTO(fun_atan);
-FUNCTION_PROTO(fun_atan2);
-FUNCTION_PROTO(fun_atat);
-FUNCTION_PROTO(fun_atrlock);
-FUNCTION_PROTO(fun_attrib_set);
-FUNCTION_PROTO(fun_band);
-FUNCTION_PROTO(fun_baseconv);
-FUNCTION_PROTO(fun_beep);
-FUNCTION_PROTO(fun_before);
-FUNCTION_PROTO(fun_bnand);
-FUNCTION_PROTO(fun_bnot);
-FUNCTION_PROTO(fun_bor);
-FUNCTION_PROTO(fun_bound);
-FUNCTION_PROTO(fun_brackets);
-FUNCTION_PROTO(fun_bxor);
-FUNCTION_PROTO(fun_cand);
-FUNCTION_PROTO(fun_capstr);
-FUNCTION_PROTO(fun_cat);
-FUNCTION_PROTO(fun_cbufferadd);
-FUNCTION_PROTO(fun_ceil);
-FUNCTION_PROTO(fun_cemit);
-FUNCTION_PROTO(fun_center);
-FUNCTION_PROTO(fun_cflags);
-FUNCTION_PROTO(fun_channels);
-FUNCTION_PROTO(fun_checkpass);
-FUNCTION_PROTO(fun_chr);
-FUNCTION_PROTO(fun_cinfo);
-FUNCTION_PROTO(fun_clock);
-FUNCTION_PROTO(fun_clone);
-FUNCTION_PROTO(fun_cmds);
-FUNCTION_PROTO(fun_comp);
-FUNCTION_PROTO(fun_con);
-FUNCTION_PROTO(fun_config);
-FUNCTION_PROTO(fun_conn);
-FUNCTION_PROTO(fun_controls);
-FUNCTION_PROTO(fun_convsecs);
-FUNCTION_PROTO(fun_convtime);
-FUNCTION_PROTO(fun_cor);
-FUNCTION_PROTO(fun_cos);
-FUNCTION_PROTO(fun_cowner);
-FUNCTION_PROTO(fun_create);
-FUNCTION_PROTO(fun_crecall);
-FUNCTION_PROTO(fun_csecs);
-FUNCTION_PROTO(fun_cstatus);
-FUNCTION_PROTO(fun_ctime);
-FUNCTION_PROTO(fun_ctitle);
-FUNCTION_PROTO(fun_ctu);
-FUNCTION_PROTO(fun_cwho);
-FUNCTION_PROTO(fun_dbwalker);
-FUNCTION_PROTO(fun_dec);
-FUNCTION_PROTO(fun_decode64);
-FUNCTION_PROTO(fun_decompose);
-FUNCTION_PROTO(fun_decrypt);
-FUNCTION_PROTO(fun_default);
-FUNCTION_PROTO(fun_delete);
-FUNCTION_PROTO(fun_die);
-FUNCTION_PROTO(fun_dig);
-FUNCTION_PROTO(fun_digest);
-FUNCTION_PROTO(fun_dist2d);
-FUNCTION_PROTO(fun_dist3d);
-FUNCTION_PROTO(fun_div);
-FUNCTION_PROTO(fun_doing);
-FUNCTION_PROTO(fun_e);
-FUNCTION_PROTO(fun_edefault);
-FUNCTION_PROTO(fun_edit);
-FUNCTION_PROTO(fun_element);
-FUNCTION_PROTO(fun_elements);
-FUNCTION_PROTO(fun_elock);
-FUNCTION_PROTO(fun_emit);
-FUNCTION_PROTO(fun_encode64);
-FUNCTION_PROTO(fun_encrypt);
-FUNCTION_PROTO(fun_endtag);
-FUNCTION_PROTO(fun_entrances);
-FUNCTION_PROTO(fun_eq);
-FUNCTION_PROTO(fun_escape);
-FUNCTION_PROTO(fun_etimefmt);
-FUNCTION_PROTO(fun_eval);
-FUNCTION_PROTO(fun_exit);
-FUNCTION_PROTO(fun_exp);
-FUNCTION_PROTO(fun_extract);
-FUNCTION_PROTO(fun_fdiv);
-FUNCTION_PROTO(fun_filter);
-FUNCTION_PROTO(fun_findable);
-FUNCTION_PROTO(fun_first);
-FUNCTION_PROTO(fun_firstof);
-FUNCTION_PROTO(fun_flags);
-FUNCTION_PROTO(fun_flip);
-FUNCTION_PROTO(fun_floor);
-FUNCTION_PROTO(fun_floordiv);
-FUNCTION_PROTO(fun_fmod);
-FUNCTION_PROTO(fun_fn);
-FUNCTION_PROTO(fun_fold);
-FUNCTION_PROTO(fun_folderstats);
-FUNCTION_PROTO(fun_followers);
-FUNCTION_PROTO(fun_following);
-FUNCTION_PROTO(fun_foreach);
-FUNCTION_PROTO(fun_fraction);
-FUNCTION_PROTO(fun_fullalias);
-FUNCTION_PROTO(fun_fullname);
-FUNCTION_PROTO(fun_functions);
-FUNCTION_PROTO(fun_get);
-FUNCTION_PROTO(fun_get_eval);
-FUNCTION_PROTO(fun_grab);
-FUNCTION_PROTO(fun_graball);
-FUNCTION_PROTO(fun_grep);
-FUNCTION_PROTO(fun_gt);
-FUNCTION_PROTO(fun_gte);
-FUNCTION_PROTO(fun_hasattr);
-FUNCTION_PROTO(fun_hasflag);
-FUNCTION_PROTO(fun_haspower);
-FUNCTION_PROTO(fun_hastype);
-FUNCTION_PROTO(fun_height);
-FUNCTION_PROTO(fun_hidden);
-FUNCTION_PROTO(fun_home);
-FUNCTION_PROTO(fun_hostname);
-FUNCTION_PROTO(fun_html);
-FUNCTION_PROTO(fun_idlesecs);
-FUNCTION_PROTO(fun_if);
-FUNCTION_PROTO(fun_ilev);
-FUNCTION_PROTO(fun_iname);
-FUNCTION_PROTO(fun_inc);
-FUNCTION_PROTO(fun_index);
-FUNCTION_PROTO(fun_insert);
-FUNCTION_PROTO(fun_inum);
-FUNCTION_PROTO(fun_ipaddr);
-FUNCTION_PROTO(fun_isdaylight);
-FUNCTION_PROTO(fun_isdbref);
-FUNCTION_PROTO(fun_isint);
-FUNCTION_PROTO(fun_isnum);
-FUNCTION_PROTO(fun_isobjid);
-FUNCTION_PROTO(fun_isword);
-FUNCTION_PROTO(fun_itemize);
-FUNCTION_PROTO(fun_items);
-FUNCTION_PROTO(fun_iter);
-FUNCTION_PROTO(fun_itext);
-FUNCTION_PROTO(fun_last);
-FUNCTION_PROTO(fun_lattr);
-FUNCTION_PROTO(fun_lcstr);
-FUNCTION_PROTO(fun_ldelete);
-FUNCTION_PROTO(fun_left);
-FUNCTION_PROTO(fun_lemit);
-FUNCTION_PROTO(fun_letq);
-FUNCTION_PROTO(fun_lflags);
-FUNCTION_PROTO(fun_link);
-FUNCTION_PROTO(fun_list);
-FUNCTION_PROTO(fun_lit);
-FUNCTION_PROTO(fun_ljust);
-FUNCTION_PROTO(fun_lmath);
-FUNCTION_PROTO(fun_ln);
-FUNCTION_PROTO(fun_lnum);
-FUNCTION_PROTO(fun_loc);
-FUNCTION_PROTO(fun_localize);
-FUNCTION_PROTO(fun_locate);
-FUNCTION_PROTO(fun_lock);
-FUNCTION_PROTO(fun_lockflags);
-FUNCTION_PROTO(fun_lockowner);
-FUNCTION_PROTO(fun_locks);
-FUNCTION_PROTO(fun_log);
-FUNCTION_PROTO(fun_lparent);
-FUNCTION_PROTO(fun_lpids);
-FUNCTION_PROTO(fun_lports);
-FUNCTION_PROTO(fun_lpos);
-FUNCTION_PROTO(fun_lsearch);
-FUNCTION_PROTO(fun_lset);
-FUNCTION_PROTO(fun_lstats);
-FUNCTION_PROTO(fun_lt);
-FUNCTION_PROTO(fun_lte);
-FUNCTION_PROTO(fun_lwho);
-FUNCTION_PROTO(fun_mail);
-FUNCTION_PROTO(fun_mailfrom);
-FUNCTION_PROTO(fun_mailsend);
-FUNCTION_PROTO(fun_mailstats);
-FUNCTION_PROTO(fun_mailstatus);
-FUNCTION_PROTO(fun_mailsubject);
-FUNCTION_PROTO(fun_mailtime);
-FUNCTION_PROTO(fun_malias);
-FUNCTION_PROTO(fun_map);
-FUNCTION_PROTO(fun_mapsql);
-FUNCTION_PROTO(fun_match);
-FUNCTION_PROTO(fun_matchall);
-FUNCTION_PROTO(fun_max);
-FUNCTION_PROTO(fun_mean);
-FUNCTION_PROTO(fun_median);
-FUNCTION_PROTO(fun_member);
-FUNCTION_PROTO(fun_merge);
-FUNCTION_PROTO(fun_message);
-FUNCTION_PROTO(fun_mid);
-FUNCTION_PROTO(fun_min);
-FUNCTION_PROTO(fun_mix);
-FUNCTION_PROTO(fun_modulo);
-FUNCTION_PROTO(fun_money);
-FUNCTION_PROTO(fun_msecs);
-FUNCTION_PROTO(fun_mtime);
-FUNCTION_PROTO(fun_mudname);
-FUNCTION_PROTO(fun_mul);
-FUNCTION_PROTO(fun_munge);
-FUNCTION_PROTO(fun_name);
-FUNCTION_PROTO(fun_namegrab);
-FUNCTION_PROTO(fun_namegraball);
-FUNCTION_PROTO(fun_namelist);
-FUNCTION_PROTO(fun_nand);
-FUNCTION_PROTO(fun_nattr);
-FUNCTION_PROTO(fun_nearby);
-FUNCTION_PROTO(fun_neq);
-FUNCTION_PROTO(fun_next);
-FUNCTION_PROTO(fun_nextdbref);
-FUNCTION_PROTO(fun_nor);
-FUNCTION_PROTO(fun_not);
-FUNCTION_PROTO(fun_null);
-FUNCTION_PROTO(fun_num);
-FUNCTION_PROTO(fun_numversion);
-FUNCTION_PROTO(fun_nwho);
-FUNCTION_PROTO(fun_obj);
-FUNCTION_PROTO(fun_objeval);
-FUNCTION_PROTO(fun_objid);
-FUNCTION_PROTO(fun_objmem);
-FUNCTION_PROTO(fun_oemit);
-FUNCTION_PROTO(fun_open);
-FUNCTION_PROTO(fun_or);
-FUNCTION_PROTO(fun_ord);
-FUNCTION_PROTO(fun_orflags);
-FUNCTION_PROTO(fun_orlflags);
-FUNCTION_PROTO(fun_owner);
-FUNCTION_PROTO(fun_parent);
-FUNCTION_PROTO(fun_pcreate);
-FUNCTION_PROTO(fun_pemit);
-FUNCTION_PROTO(fun_pi);
-FUNCTION_PROTO(fun_pidinfo);
-FUNCTION_PROTO(fun_player);
-FUNCTION_PROTO(fun_playermem);
-FUNCTION_PROTO(fun_pmatch);
-FUNCTION_PROTO(fun_poll);
-FUNCTION_PROTO(fun_ports);
-FUNCTION_PROTO(fun_pos);
-FUNCTION_PROTO(fun_poss);
-FUNCTION_PROTO(fun_power);
-FUNCTION_PROTO(fun_powers);
-FUNCTION_PROTO(fun_prompt);
-FUNCTION_PROTO(fun_pueblo);
-FUNCTION_PROTO(fun_quota);
-FUNCTION_PROTO(fun_r);
-FUNCTION_PROTO(fun_rand);
-FUNCTION_PROTO(fun_randword);
-FUNCTION_PROTO(fun_recv);
-FUNCTION_PROTO(fun_regmatch);
-FUNCTION_PROTO(fun_regrab);
-FUNCTION_PROTO(fun_regrep);
-FUNCTION_PROTO(fun_regreplace);
-FUNCTION_PROTO(fun_remainder);
-FUNCTION_PROTO(fun_remit);
-FUNCTION_PROTO(fun_remove);
-FUNCTION_PROTO(fun_repeat);
-FUNCTION_PROTO(fun_replace);
-FUNCTION_PROTO(fun_rest);
-FUNCTION_PROTO(fun_restarts);
-FUNCTION_PROTO(fun_restarttime);
-FUNCTION_PROTO(fun_reswitch);
-FUNCTION_PROTO(fun_revwords);
-FUNCTION_PROTO(fun_right);
-FUNCTION_PROTO(fun_rjust);
-FUNCTION_PROTO(fun_rloc);
-FUNCTION_PROTO(fun_rnum);
-FUNCTION_PROTO(fun_room);
-FUNCTION_PROTO(fun_root);
-FUNCTION_PROTO(fun_round);
-FUNCTION_PROTO(fun_s);
-FUNCTION_PROTO(fun_scan);
-FUNCTION_PROTO(fun_scramble);
-FUNCTION_PROTO(fun_secs);
-FUNCTION_PROTO(fun_secure);
-FUNCTION_PROTO(fun_sent);
-FUNCTION_PROTO(fun_set);
-FUNCTION_PROTO(fun_setdiff);
-FUNCTION_PROTO(fun_setinter);
-FUNCTION_PROTO(fun_setq);
-FUNCTION_PROTO(fun_setunion);
-FUNCTION_PROTO(fun_sha0);
-FUNCTION_PROTO(fun_shl);
-FUNCTION_PROTO(fun_shr);
-FUNCTION_PROTO(fun_shuffle);
-FUNCTION_PROTO(fun_sign);
-FUNCTION_PROTO(fun_sin);
-FUNCTION_PROTO(fun_sort);
-FUNCTION_PROTO(fun_sortby);
-FUNCTION_PROTO(fun_sortkey);
-FUNCTION_PROTO(fun_soundex);
-FUNCTION_PROTO(fun_soundlike);
-FUNCTION_PROTO(fun_space);
-FUNCTION_PROTO(fun_speak);
-FUNCTION_PROTO(fun_spellnum);
-FUNCTION_PROTO(fun_splice);
-FUNCTION_PROTO(fun_sql);
-FUNCTION_PROTO(fun_sql_escape);
-FUNCTION_PROTO(fun_sqrt);
-FUNCTION_PROTO(fun_squish);
-FUNCTION_PROTO(fun_ssl);
-FUNCTION_PROTO(fun_starttime);
-FUNCTION_PROTO(fun_stddev);
-FUNCTION_PROTO(fun_step);
-FUNCTION_PROTO(fun_strcat);
-FUNCTION_PROTO(fun_stringsecs);
-FUNCTION_PROTO(fun_strinsert);
-FUNCTION_PROTO(fun_stripaccents);
-FUNCTION_PROTO(fun_stripansi);
-FUNCTION_PROTO(fun_strlen);
-FUNCTION_PROTO(fun_strmatch);
-FUNCTION_PROTO(fun_strreplace);
-FUNCTION_PROTO(fun_sub);
-FUNCTION_PROTO(fun_subj);
-FUNCTION_PROTO(fun_switch);
-FUNCTION_PROTO(fun_t);
-FUNCTION_PROTO(fun_table);
-FUNCTION_PROTO(fun_tag);
-FUNCTION_PROTO(fun_tagwrap);
-FUNCTION_PROTO(fun_tan);
-FUNCTION_PROTO(fun_tel);
-FUNCTION_PROTO(fun_terminfo);
-FUNCTION_PROTO(fun_textentries);
-FUNCTION_PROTO(fun_textfile);
-FUNCTION_PROTO(fun_time);
-FUNCTION_PROTO(fun_timefmt);
-FUNCTION_PROTO(fun_timestring);
-FUNCTION_PROTO(fun_tr);
-FUNCTION_PROTO(fun_trim);
-FUNCTION_PROTO(fun_trunc);
-FUNCTION_PROTO(fun_type);
-FUNCTION_PROTO(fun_ucstr);
-FUNCTION_PROTO(fun_ufun);
-FUNCTION_PROTO(fun_ulambda);
-FUNCTION_PROTO(fun_uldefault);
-FUNCTION_PROTO(fun_ulocal);
-FUNCTION_PROTO(fun_unique);
-FUNCTION_PROTO(fun_v);
-FUNCTION_PROTO(fun_vadd);
-FUNCTION_PROTO(fun_valid);
-FUNCTION_PROTO(fun_vcross);
-FUNCTION_PROTO(fun_vdot);
-FUNCTION_PROTO(fun_version);
-FUNCTION_PROTO(fun_visible);
-FUNCTION_PROTO(fun_vmag);
-FUNCTION_PROTO(fun_vmax);
-FUNCTION_PROTO(fun_vmin);
-FUNCTION_PROTO(fun_vmul);
-FUNCTION_PROTO(fun_vsub);
-FUNCTION_PROTO(fun_vunit);
-FUNCTION_PROTO(fun_where);
-FUNCTION_PROTO(fun_width);
-FUNCTION_PROTO(fun_wipe);
-FUNCTION_PROTO(fun_wordpos);
-FUNCTION_PROTO(fun_words);
-FUNCTION_PROTO(fun_wrap);
-FUNCTION_PROTO(fun_xget);
-FUNCTION_PROTO(fun_xor);
-FUNCTION_PROTO(fun_xwho);
-FUNCTION_PROTO(fun_zemit);
-FUNCTION_PROTO(fun_zfun);
-FUNCTION_PROTO(fun_zone);
-FUNCTION_PROTO(fun_zwho);
-FUNCTION_PROTO(local_fun_silly);
-#endif /* FUNS_H */
Index: hdrs/cmds.h
===================================================================
--- hdrs/cmds.h	(.../183p10)	(revision 142)
+++ hdrs/cmds.h	(.../183p11)	(revision 142)
@@ -1,152 +0,0 @@
-/* AUTOGENERATED FILE. DO NOT EDIT! */
-#ifndef CMDS_H
-#define CMDS_H
-COMMAND_PROTO(cmd_allhalt);
-COMMAND_PROTO(cmd_allquota);
-COMMAND_PROTO(cmd_assert);
-COMMAND_PROTO(cmd_atrchown);
-COMMAND_PROTO(cmd_atrlock);
-COMMAND_PROTO(cmd_attribute);
-COMMAND_PROTO(cmd_boot);
-COMMAND_PROTO(cmd_break);
-COMMAND_PROTO(cmd_brief);
-COMMAND_PROTO(cmd_buy);
-COMMAND_PROTO(cmd_cemit);
-COMMAND_PROTO(cmd_channel);
-COMMAND_PROTO(cmd_chat);
-COMMAND_PROTO(cmd_chown);
-COMMAND_PROTO(cmd_chownall);
-COMMAND_PROTO(cmd_chzone);
-COMMAND_PROTO(cmd_chzoneall);
-COMMAND_PROTO(cmd_clock);
-COMMAND_PROTO(cmd_clone);
-COMMAND_PROTO(cmd_command);
-COMMAND_PROTO(cmd_config);
-COMMAND_PROTO(cmd_cpattr);
-COMMAND_PROTO(cmd_create);
-COMMAND_PROTO(cmd_dbck);
-COMMAND_PROTO(cmd_decompile);
-COMMAND_PROTO(cmd_desert);
-COMMAND_PROTO(cmd_destroy);
-COMMAND_PROTO(cmd_dig);
-COMMAND_PROTO(cmd_disable);
-COMMAND_PROTO(cmd_dismiss);
-COMMAND_PROTO(cmd_doing);
-COMMAND_PROTO(cmd_dolist);
-COMMAND_PROTO(cmd_drop);
-COMMAND_PROTO(cmd_dump);
-COMMAND_PROTO(cmd_edit);
-COMMAND_PROTO(cmd_elock);
-COMMAND_PROTO(cmd_emit);
-COMMAND_PROTO(cmd_empty);
-COMMAND_PROTO(cmd_enable);
-COMMAND_PROTO(cmd_enter);
-COMMAND_PROTO(cmd_entrances);
-COMMAND_PROTO(cmd_eunlock);
-COMMAND_PROTO(cmd_examine);
-COMMAND_PROTO(cmd_find);
-COMMAND_PROTO(cmd_firstexit);
-COMMAND_PROTO(cmd_flag);
-COMMAND_PROTO(cmd_follow);
-COMMAND_PROTO(cmd_force);
-COMMAND_PROTO(cmd_function);
-COMMAND_PROTO(cmd_get);
-COMMAND_PROTO(cmd_give);
-COMMAND_PROTO(cmd_goto);
-COMMAND_PROTO(cmd_grep);
-COMMAND_PROTO(cmd_halt);
-COMMAND_PROTO(cmd_helpcmd);
-COMMAND_PROTO(cmd_hide);
-COMMAND_PROTO(cmd_home);
-COMMAND_PROTO(cmd_hook);
-COMMAND_PROTO(cmd_huh_command);
-COMMAND_PROTO(cmd_inventory);
-COMMAND_PROTO(cmd_kick);
-COMMAND_PROTO(cmd_kill);
-COMMAND_PROTO(cmd_leave);
-COMMAND_PROTO(cmd_lemit);
-COMMAND_PROTO(cmd_link);
-COMMAND_PROTO(cmd_list);
-COMMAND_PROTO(cmd_listmotd);
-COMMAND_PROTO(cmd_local_silly);
-COMMAND_PROTO(cmd_lock);
-COMMAND_PROTO(cmd_log);
-COMMAND_PROTO(cmd_logwipe);
-COMMAND_PROTO(cmd_look);
-COMMAND_PROTO(cmd_lset);
-COMMAND_PROTO(cmd_mail);
-COMMAND_PROTO(cmd_malias);
-COMMAND_PROTO(cmd_map);
-COMMAND_PROTO(cmd_message);
-COMMAND_PROTO(cmd_motd);
-COMMAND_PROTO(cmd_mvattr);
-COMMAND_PROTO(cmd_name);
-COMMAND_PROTO(cmd_newpassword);
-COMMAND_PROTO(cmd_notify_drain);
-COMMAND_PROTO(cmd_nuke);
-COMMAND_PROTO(cmd_null);
-COMMAND_PROTO(cmd_oemit);
-COMMAND_PROTO(cmd_open);
-COMMAND_PROTO(cmd_page);
-COMMAND_PROTO(cmd_parent);
-COMMAND_PROTO(cmd_password);
-COMMAND_PROTO(cmd_pcreate);
-COMMAND_PROTO(cmd_pemit);
-COMMAND_PROTO(cmd_poll);
-COMMAND_PROTO(cmd_poor);
-COMMAND_PROTO(cmd_pose);
-COMMAND_PROTO(cmd_power);
-COMMAND_PROTO(cmd_prompt);
-COMMAND_PROTO(cmd_ps);
-COMMAND_PROTO(cmd_purge);
-COMMAND_PROTO(cmd_quota);
-COMMAND_PROTO(cmd_readcache);
-COMMAND_PROTO(cmd_rejectmotd);
-COMMAND_PROTO(cmd_remit);
-COMMAND_PROTO(cmd_restart);
-COMMAND_PROTO(cmd_rwall);
-COMMAND_PROTO(cmd_say);
-COMMAND_PROTO(cmd_scan);
-COMMAND_PROTO(cmd_score);
-COMMAND_PROTO(cmd_search);
-COMMAND_PROTO(cmd_select);
-COMMAND_PROTO(cmd_semipose);
-COMMAND_PROTO(cmd_set);
-COMMAND_PROTO(cmd_shutdown);
-COMMAND_PROTO(cmd_sitelock);
-COMMAND_PROTO(cmd_slay);
-COMMAND_PROTO(cmd_sql);
-COMMAND_PROTO(cmd_squota);
-COMMAND_PROTO(cmd_stats);
-COMMAND_PROTO(cmd_sweep);
-COMMAND_PROTO(cmd_switch);
-COMMAND_PROTO(cmd_take);
-COMMAND_PROTO(cmd_teach);
-COMMAND_PROTO(cmd_teleport);
-COMMAND_PROTO(cmd_think);
-COMMAND_PROTO(cmd_trigger);
-COMMAND_PROTO(cmd_ulock);
-COMMAND_PROTO(cmd_undestroy);
-COMMAND_PROTO(cmd_unfollow);
-COMMAND_PROTO(cmd_unimplemented);
-COMMAND_PROTO(cmd_unlink);
-COMMAND_PROTO(cmd_unlock);
-COMMAND_PROTO(cmd_uptime);
-COMMAND_PROTO(cmd_use);
-COMMAND_PROTO(cmd_uunlock);
-COMMAND_PROTO(cmd_verb);
-COMMAND_PROTO(cmd_version);
-COMMAND_PROTO(cmd_wait);
-COMMAND_PROTO(cmd_wall);
-COMMAND_PROTO(cmd_warn_on_missing);
-COMMAND_PROTO(cmd_warnings);
-COMMAND_PROTO(cmd_wcheck);
-COMMAND_PROTO(cmd_whereis);
-COMMAND_PROTO(cmd_whisper);
-COMMAND_PROTO(cmd_wipe);
-COMMAND_PROTO(cmd_with);
-COMMAND_PROTO(cmd_wizmotd);
-COMMAND_PROTO(cmd_wizwall);
-COMMAND_PROTO(cmd_zemit);
-COMMAND_PROTO(command_atrset);
-#endif                          /* CMDS_H */
Index: hdrs/game.h
===================================================================
--- hdrs/game.h	(.../183p10)	(revision 142)
+++ hdrs/game.h	(.../183p11)	(revision 142)
@@ -26,6 +26,9 @@
 enum motd_type { MOTD_MOTD, MOTD_WIZ, MOTD_DOWN, MOTD_FULL, MOTD_LIST };
 void do_motd(dbref player, enum motd_type key, const char *message);
 void do_poll(dbref player, const char *message, int clear);
+void do_page_port(dbref player, dbref cause, const char *pc, const char *msg,
+                  bool eval_msg);
+void do_pemit_port(dbref player, const char *pc, const char *msg, int flags);
 /* From cque.c */
 void do_wait
   (dbref player, dbref cause, char *arg1, const char *cmd, bool until);
@@ -126,13 +129,11 @@
   (dbref player, const char *arg1, const char *arg2, int noisy);
 extern void do_pose(dbref player, const char *tbuf1, int space);
 enum wall_type { WALL_ALL, WALL_RW, WALL_WIZ };
-extern void do_wall(dbref player, const char *message, enum wall_type target,
-                    int emit);
-extern void do_page(dbref player, const char *arg1, const char *arg2,
-                    dbref cause, int noeval, int multipage, int override,
-                    int has_eq);
-extern void do_page_port(dbref player, const char *arg1, const char *arg2);
-extern void do_think(dbref player, const char *message);
+void do_wall(dbref player, const char *message, enum wall_type target,
+             int emit);
+void do_page(dbref player, const char *arg1, const char *arg2,
+             dbref cause, int noeval, int multipage, int override, int has_eq);
+void do_think(dbref player, const char *message);
 #define PEMIT_SILENT 0x1
 #define PEMIT_LIST   0x2
 #define PEMIT_SPOOF  0x4
Index: hdrs/version.h
===================================================================
--- hdrs/version.h	(.../183p10)	(revision 142)
+++ hdrs/version.h	(.../183p11)	(revision 142)
@@ -1,4 +1,4 @@
 #define VERSION "1.8.3"
-#define PATCHLEVEL "10"
-#define PATCHDATE "[08/24/2009]"
-#define NUMVERSION 1008003010
+#define PATCHLEVEL "11"
+#define PATCHDATE "[01/01/2010]"
+#define NUMVERSION 1008003011
Index: hdrs/dbdefs.h
===================================================================
--- hdrs/dbdefs.h	(.../183p10)	(revision 142)
+++ hdrs/dbdefs.h	(.../183p11)	(revision 142)
@@ -316,7 +316,8 @@
 extern const char *EOD;
 
 #define SPOOF(player, cause, sw) \
-  if (SW_ISSET(sw, SWITCH_SPOOF) && (controls(player, cause) || Can_Nspemit(player))) \
-    player = cause;
+  if (SW_ISSET(sw, SWITCH_SPOOF) && (controls(player, cause) || Can_Nspemit(player))) {\
+    player = cause; orator = cause; \
+  }
 
 #endif                          /* __DBDEFS_H */
Index: hdrs/externs.h
===================================================================
--- hdrs/externs.h	(.../183p10)	(revision 142)
+++ hdrs/externs.h	(.../183p11)	(revision 142)
@@ -115,7 +115,9 @@
 int most_conn_time_priv(dbref player);
 char *least_idle_ip(dbref player);
 char *least_idle_hostname(dbref player);
-
+void do_who_mortal(dbref player, char *name);
+void do_who_admin(dbref player, char *name);
+void do_who_session(dbref player, char *name);
 /* sql.c */
 void sql_shutdown(void);
 
Index: config.h.in
===================================================================
--- config.h.in	(.../183p10)	(revision 142)
+++ config.h.in	(.../183p11)	(revision 142)
@@ -173,11 +173,6 @@
 # define __bool_true_false_are_defined 1
 #endif
 
-/* Someday work to get rid of these. They're left over from the
-pre-void days */ 
-typedef void* Malloc_t; 
-typedef void Free_t;
-
 /* Functions */
 #undef HAS_BINDTEXTDOMAIN
 
Index: win32/vs2005/pennmush.vcproj
===================================================================
--- win32/vs2005/pennmush.vcproj	(.../183p10)	(revision 142)
+++ win32/vs2005/pennmush.vcproj	(.../183p11)	(revision 142)
@@ -16,13 +16,13 @@
 		<Configuration
 			Name="Debug|Win32"
 			OutputDirectory="..\..\game"
-			IntermediateDirectory="..\..\src"
+			IntermediateDirectory="..\..\obj"
 			ConfigurationType="1"
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
 				Description="Copying necessary files..."
-				CommandLine="IF NOT EXIST $(ProjectDir)\..\..\src\cmdlocal.c copy $(ProjectDir)\..\..\src\cmdlocal.dst $(ProjectDir)\..\..\src\cmdlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\flaglocal.c copy $(ProjectDir)\..\..\src\flaglocal.dst $(ProjectDir)\..\..\src\flaglocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\funlocal.c copy $(ProjectDir)\..\..\src\funlocal.dst $(ProjectDir)\..\..\src\funlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\local.c copy $(ProjectDir)\..\..\src\local.dst $(ProjectDir)\..\..\src\local.c&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\options.h $(ProjectDir)\..\..\options.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\config.h $(ProjectDir)\..\..\config.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\confmagic.h $(ProjectDir)\..\..\confmagic.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\cmds.h $(ProjectDir)\..\..\hdrs\cmds.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\funs.h $(ProjectDir)\..\..\hdrs\funs.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\patches.h $(ProjectDir)\..\..\hdrs\patches.h&#x0D;&#x0A;echo If any *local.c files failed to build, run build again.&#x0D;&#x0A;"
+				CommandLine="IF NOT EXIST $(ProjectDir)\..\..\src\cmdlocal.c copy $(ProjectDir)\..\..\src\cmdlocal.dst $(ProjectDir)\..\..\src\cmdlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\hdrs\cmds.h copy $(ProjectDir)\..\..\win32\cmds.h $(ProjectDir)\..\..\hdrs\cmds.h&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\flaglocal.c copy $(ProjectDir)\..\..\src\flaglocal.dst $(ProjectDir)\..\..\src\flaglocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\funlocal.c copy $(ProjectDir)\..\..\src\funlocal.dst $(ProjectDir)\..\..\src\funlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\hdrs\funs.h copy $(ProjectDir)\..\..\win32\funs.h $(ProjectDir)\..\..\hdrs\funs.h&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\local.c copy $(ProjectDir)\..\..\src\local.dst $(ProjectDir)\..\..\src\local.c&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\options.h $(ProjectDir)\..\..\options.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\config.h $(ProjectDir)\..\..\config.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\confmagic.h $(ProjectDir)\..\..\confmagic.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\patches.h $(ProjectDir)\..\..\hdrs\patches.h&#x0D;&#x0A;echo If any *local.c files failed to build, run build again.&#x0D;&#x0A;"
 			/>
 			<Tool
 				Name="VCCustomBuildTool"
@@ -89,14 +89,14 @@
 		</Configuration>
 		<Configuration
 			Name="Release|Win32"
-			OutputDirectory=".\game"
-			IntermediateDirectory=".\src"
+			OutputDirectory="..\..\game"
+			IntermediateDirectory="..\..\obj"
 			ConfigurationType="1"
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
 				Description="Copying necessary files..."
-				CommandLine="IF NOT EXIST $(ProjectDir)\..\..\src\cmdlocal.c copy $(ProjectDir)\..\..\src\cmdlocal.dst $(ProjectDir)\..\..\src\cmdlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\flaglocal.c copy $(ProjectDir)\..\..\src\flaglocal.dst $(ProjectDir)\..\..\src\flaglocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\funlocal.c copy $(ProjectDir)\..\..\src\funlocal.dst $(ProjectDir)\..\..\src\funlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\local.c copy $(ProjectDir)\..\..\src\local.dst $(ProjectDir)\..\..\src\local.c&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\options.h $(ProjectDir)\..\..\options.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\config.h $(ProjectDir)\..\..\config.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\confmagic.h $(ProjectDir)\..\..\confmagic.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\cmds.h $(ProjectDir)\..\..\hdrs\cmds.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\funs.h $(ProjectDir)\..\..\hdrs\funs.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\patches.h $(ProjectDir)\..\..\hdrs\patches.h&#x0D;&#x0A;echo If any *local.c files failed to build, run build again.&#x0D;&#x0A;"
+				CommandLine="IF NOT EXIST $(ProjectDir)\..\..\src\cmdlocal.c copy $(ProjectDir)\..\..\src\cmdlocal.dst $(ProjectDir)\..\..\src\cmdlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\hdrs\cmds.h copy $(ProjectDir)\..\..\win32\cmds.h $(ProjectDir)\..\..\hdrs\cmds.h&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\flaglocal.c copy $(ProjectDir)\..\..\src\flaglocal.dst $(ProjectDir)\..\..\src\flaglocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\funlocal.c copy $(ProjectDir)\..\..\src\funlocal.dst $(ProjectDir)\..\..\src\funlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\hdrs\funs.h copy $(ProjectDir)\..\..\win32\funs.h $(ProjectDir)\..\..\hdrs\funs.h&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\local.c copy $(ProjectDir)\..\..\src\local.dst $(ProjectDir)\..\..\src\local.c&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\options.h $(ProjectDir)\..\..\options.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\config.h $(ProjectDir)\..\..\config.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\confmagic.h $(ProjectDir)\..\..\confmagic.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\patches.h $(ProjectDir)\..\..\hdrs\patches.h&#x0D;&#x0A;echo If any *local.c files failed to build, run build again.&#x0D;&#x0A;"
 			/>
 			<Tool
 				Name="VCCustomBuildTool"
Index: win32/funs.h
===================================================================
--- win32/funs.h	(.../183p10)	(revision 142)
+++ win32/funs.h	(.../183p11)	(revision 142)
@@ -1,4 +1,6 @@
-/* AUTOGENERATED FILE. DO NOT EDIT */
+/* AUTOGENERATED FILE. DO NOT EDIT! */
+#ifndef FUNS_H
+#define FUNS_H
 FUNCTION_PROTO(fun_abs);
 FUNCTION_PROTO(fun_accent);
 FUNCTION_PROTO(fun_accname);
@@ -14,6 +16,7 @@
 FUNCTION_PROTO(fun_andflags);
 FUNCTION_PROTO(fun_andlflags);
 FUNCTION_PROTO(fun_ansi);
+FUNCTION_PROTO(fun_ansiinspect);
 FUNCTION_PROTO(fun_aposs);
 FUNCTION_PROTO(fun_art);
 FUNCTION_PROTO(fun_asin);
@@ -172,6 +175,7 @@
 FUNCTION_PROTO(fun_locate);
 FUNCTION_PROTO(fun_lock);
 FUNCTION_PROTO(fun_lockflags);
+FUNCTION_PROTO(fun_lockowner);
 FUNCTION_PROTO(fun_locks);
 FUNCTION_PROTO(fun_log);
 FUNCTION_PROTO(fun_lparent);
@@ -205,9 +209,9 @@
 FUNCTION_PROTO(fun_mid);
 FUNCTION_PROTO(fun_min);
 FUNCTION_PROTO(fun_mix);
-FUNCTION_PROTO(fun_msecs);
 FUNCTION_PROTO(fun_modulo);
 FUNCTION_PROTO(fun_money);
+FUNCTION_PROTO(fun_msecs);
 FUNCTION_PROTO(fun_mtime);
 FUNCTION_PROTO(fun_mudname);
 FUNCTION_PROTO(fun_mul);
@@ -333,6 +337,7 @@
 FUNCTION_PROTO(fun_tan);
 FUNCTION_PROTO(fun_tel);
 FUNCTION_PROTO(fun_terminfo);
+FUNCTION_PROTO(fun_testlock);
 FUNCTION_PROTO(fun_textentries);
 FUNCTION_PROTO(fun_textfile);
 FUNCTION_PROTO(fun_time);
@@ -343,6 +348,7 @@
 FUNCTION_PROTO(fun_trunc);
 FUNCTION_PROTO(fun_type);
 FUNCTION_PROTO(fun_ucstr);
+FUNCTION_PROTO(fun_udefault);
 FUNCTION_PROTO(fun_ufun);
 FUNCTION_PROTO(fun_ulambda);
 FUNCTION_PROTO(fun_uldefault);
@@ -374,3 +380,4 @@
 FUNCTION_PROTO(fun_zfun);
 FUNCTION_PROTO(fun_zone);
 FUNCTION_PROTO(fun_zwho);
+#endif /* FUNS_H */
Index: win32/vs2008/pennmush.vcproj
===================================================================
--- win32/vs2008/pennmush.vcproj	(.../183p10)	(revision 142)
+++ win32/vs2008/pennmush.vcproj	(.../183p11)	(revision 142)
@@ -17,13 +17,13 @@
 		<Configuration
 			Name="Debug|Win32"
 			OutputDirectory="..\..\game"
-			IntermediateDirectory="..\..\src"
+			IntermediateDirectory="..\..\obj"
 			ConfigurationType="1"
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
 				Description="Copying necessary files..."
-				CommandLine="IF NOT EXIST $(ProjectDir)\..\..\src\cmdlocal.c copy $(ProjectDir)\..\..\src\cmdlocal.dst $(ProjectDir)\..\..\src\cmdlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\flaglocal.c copy $(ProjectDir)\..\..\src\flaglocal.dst $(ProjectDir)\..\..\src\flaglocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\funlocal.c copy $(ProjectDir)\..\..\src\funlocal.dst $(ProjectDir)\..\..\src\funlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\local.c copy $(ProjectDir)\..\..\src\local.dst $(ProjectDir)\..\..\src\local.c&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\options.h $(ProjectDir)\..\..\options.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\config.h $(ProjectDir)\..\..\config.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\confmagic.h $(ProjectDir)\..\..\confmagic.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\cmds.h $(ProjectDir)\..\..\hdrs\cmds.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\funs.h $(ProjectDir)\..\..\hdrs\funs.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\patches.h $(ProjectDir)\..\..\hdrs\patches.h&#x0D;&#x0A;echo If any *local.c files failed to build, run build again.&#x0D;&#x0A;"
+				CommandLine="IF NOT EXIST $(ProjectDir)\..\..\src\cmdlocal.c copy $(ProjectDir)\..\..\src\cmdlocal.dst $(ProjectDir)\..\..\src\cmdlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\hdrs\cmds.h copy $(ProjectDir)\..\..\win32\cmds.h $(ProjectDir)\..\..\hdrs\cmds.h&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\flaglocal.c copy $(ProjectDir)\..\..\src\flaglocal.dst $(ProjectDir)\..\..\src\flaglocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\funlocal.c copy $(ProjectDir)\..\..\src\funlocal.dst $(ProjectDir)\..\..\src\funlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\hdrs\funs.h copy $(ProjectDir)\..\..\win32\funs.h $(ProjectDir)\..\..\hdrs\funs.h&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\local.c copy $(ProjectDir)\..\..\src\local.dst $(ProjectDir)\..\..\src\local.c&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\options.h $(ProjectDir)\..\..\options.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\config.h $(ProjectDir)\..\..\config.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\confmagic.h $(ProjectDir)\..\..\confmagic.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\patches.h $(ProjectDir)\..\..\hdrs\patches.h&#x0D;&#x0A;echo If any *local.c files failed to build, run build again.&#x0D;&#x0A;"
 			/>
 			<Tool
 				Name="VCCustomBuildTool"
@@ -89,14 +89,14 @@
 		</Configuration>
 		<Configuration
 			Name="Release|Win32"
-			OutputDirectory=".\game"
-			IntermediateDirectory=".\src"
+			OutputDirectory="..\..\game"
+			IntermediateDirectory="..\..\obj"
 			ConfigurationType="1"
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
 				Description="Copying necessary files..."
-				CommandLine="IF NOT EXIST $(ProjectDir)\..\..\src\cmdlocal.c copy $(ProjectDir)\..\..\src\cmdlocal.dst $(ProjectDir)\..\..\src\cmdlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\flaglocal.c copy $(ProjectDir)\..\..\src\flaglocal.dst $(ProjectDir)\..\..\src\flaglocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\funlocal.c copy $(ProjectDir)\..\..\src\funlocal.dst $(ProjectDir)\..\..\src\funlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\local.c copy $(ProjectDir)\..\..\src\local.dst $(ProjectDir)\..\..\src\local.c&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\options.h $(ProjectDir)\..\..\options.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\config.h $(ProjectDir)\..\..\config.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\confmagic.h $(ProjectDir)\..\..\confmagic.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\cmds.h $(ProjectDir)\..\..\hdrs\cmds.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\funs.h $(ProjectDir)\..\..\hdrs\funs.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\patches.h $(ProjectDir)\..\..\hdrs\patches.h&#x0D;&#x0A;echo If any *local.c files failed to build, run build again.&#x0D;&#x0A;"
+				CommandLine="IF NOT EXIST $(ProjectDir)\..\..\src\cmdlocal.c copy $(ProjectDir)\..\..\src\cmdlocal.dst $(ProjectDir)\..\..\src\cmdlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\hdrs\cmds.h copy $(ProjectDir)\..\..\win32\cmds.h $(ProjectDir)\..\..\hdrs\cmds.h&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\flaglocal.c copy $(ProjectDir)\..\..\src\flaglocal.dst $(ProjectDir)\..\..\src\flaglocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\funlocal.c copy $(ProjectDir)\..\..\src\funlocal.dst $(ProjectDir)\..\..\src\funlocal.c&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\hdrs\funs.h copy $(ProjectDir)\..\..\win32\funs.h $(ProjectDir)\..\..\hdrs\funs.h&#x0D;&#x0A;IF NOT EXIST $(ProjectDir)\..\..\src\local.c copy $(ProjectDir)\..\..\src\local.dst $(ProjectDir)\..\..\src\local.c&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\options.h $(ProjectDir)\..\..\options.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\config.h $(ProjectDir)\..\..\config.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\confmagic.h $(ProjectDir)\..\..\confmagic.h&#x0D;&#x0A;copy $(ProjectDir)\..\..\win32\patches.h $(ProjectDir)\..\..\hdrs\patches.h&#x0D;&#x0A;echo If any *local.c files failed to build, run build again.&#x0D;&#x0A;"
 			/>
 			<Tool
 				Name="VCCustomBuildTool"
Index: win32/cmds.h
===================================================================
--- win32/cmds.h	(.../183p10)	(revision 142)
+++ win32/cmds.h	(.../183p11)	(revision 142)
@@ -1,4 +1,6 @@
-/* AUTOGENERATED FILE. DO NOT EDIT */
+/* AUTOGENERATED FILE. DO NOT EDIT! */
+#ifndef CMDS_H
+#define CMDS_H
 COMMAND_PROTO(cmd_allhalt);
 COMMAND_PROTO(cmd_allquota);
 COMMAND_PROTO(cmd_assert);
@@ -66,6 +68,7 @@
 COMMAND_PROTO(cmd_link);
 COMMAND_PROTO(cmd_list);
 COMMAND_PROTO(cmd_listmotd);
+COMMAND_PROTO(cmd_local_silly);
 COMMAND_PROTO(cmd_lock);
 COMMAND_PROTO(cmd_log);
 COMMAND_PROTO(cmd_logwipe);
@@ -108,6 +111,7 @@
 COMMAND_PROTO(cmd_search);
 COMMAND_PROTO(cmd_select);
 COMMAND_PROTO(cmd_semipose);
+COMMAND_PROTO(cmd_session);
 COMMAND_PROTO(cmd_set);
 COMMAND_PROTO(cmd_shutdown);
 COMMAND_PROTO(cmd_sitelock);
@@ -135,14 +139,17 @@
 COMMAND_PROTO(cmd_version);
 COMMAND_PROTO(cmd_wait);
 COMMAND_PROTO(cmd_wall);
-COMMAND_PROTO(cmd_warnings);
 COMMAND_PROTO(cmd_warn_on_missing);
+COMMAND_PROTO(cmd_warnings);
 COMMAND_PROTO(cmd_wcheck);
 COMMAND_PROTO(cmd_whereis);
 COMMAND_PROTO(cmd_whisper);
+COMMAND_PROTO(cmd_who);
+COMMAND_PROTO(cmd_who_doing);
 COMMAND_PROTO(cmd_wipe);
 COMMAND_PROTO(cmd_with);
 COMMAND_PROTO(cmd_wizmotd);
 COMMAND_PROTO(cmd_wizwall);
 COMMAND_PROTO(cmd_zemit);
 COMMAND_PROTO(command_atrset);
+#endif /* CMDS_H */
Index: win32/msvc6/pennmush.dsp
===================================================================
--- win32/msvc6/pennmush.dsp	(.../183p10)	(revision 142)
+++ win32/msvc6/pennmush.dsp	(.../183p11)	(revision 142)
@@ -45,7 +45,7 @@
 # PROP Use_MFC 0
 # PROP Use_Debug_Libraries 1
 # PROP Output_Dir "../../game"
-# PROP Intermediate_Dir "../../src"
+# PROP Intermediate_Dir "../../obj"
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /MD /W3 /GX /ZI /I "../../win32" /I "../../hdrs" /I "../../" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
@@ -72,7 +72,7 @@
 # PROP Use_MFC 0
 # PROP Use_Debug_Libraries 0
 # PROP Output_Dir "../../game"
-# PROP Intermediate_Dir "../../src"
+# PROP Intermediate_Dir "../../obj"
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /MD /W3 /GX /O2 /Ob0 /I "../../hdrs" /I "../../" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /I /Win32" " /c
@@ -99,7 +99,7 @@
 # PROP Use_MFC 0
 # PROP Use_Debug_Libraries 1
 # PROP Output_Dir "../../game"
-# PROP Intermediate_Dir "../../src"
+# PROP Intermediate_Dir "../../obj"
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /MD /W3 /GX /ZI /I "../../win32" /I "../../hdrs" /I "../../" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
@@ -126,7 +126,7 @@
 # PROP Use_MFC 0
 # PROP Use_Debug_Libraries 0
 # PROP Output_Dir "../../game"
-# PROP Intermediate_Dir "../../src"
+# PROP Intermediate_Dir "../../obj"
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /MD /W3 /GX /O2 /Ob0 /I "../../hdrs" /I "../../" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /I /Win32" " /c
@@ -151,7 +151,7 @@
 # PROP Use_MFC 0
 # PROP Use_Debug_Libraries 1
 # PROP Output_Dir "../../game"
-# PROP Intermediate_Dir "../../src"
+# PROP Intermediate_Dir "../../obj"
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /MD /W3 /GX /ZI /I "../../win32" /I "../../hdrs" /I "../../" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
@@ -178,7 +178,7 @@
 # PROP Use_MFC 0
 # PROP Use_Debug_Libraries 0
 # PROP Output_Dir "../../game"
-# PROP Intermediate_Dir "../../src"
+# PROP Intermediate_Dir "../../obj"
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /MD /W3 /GX /O2 /Ob0 /I "../../hdrs" /I "../../" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /I /Win32" " /c
@@ -203,7 +203,7 @@
 # PROP Use_MFC 0
 # PROP Use_Debug_Libraries 1
 # PROP Output_Dir "../../game"
-# PROP Intermediate_Dir "../../src"
+# PROP Intermediate_Dir "../../obj"
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
@@ -228,7 +228,7 @@
 # PROP Use_MFC 0
 # PROP Use_Debug_Libraries 0
 # PROP Output_Dir "../../game"
-# PROP Intermediate_Dir "../../src"
+# PROP Intermediate_Dir "../../obj"
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
