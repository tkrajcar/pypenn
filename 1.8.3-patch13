This is patch13 to PennMUSH 1.8.3. After applying this patch, you will
have version 1.8.3p13

To apply this patch, save it to a file in your top-level 1.8.3p12 MUSH directory,
and do the following:
        patch -p0 < 1.8.3-patch13
        ./configure
        make install

If you use GNU patch 2.2, you probably want the above to be 'patch -b -p0',
not just 'patch -p0'.

Users need not worry about failed hunks in src/switchinc.c,
hdrs/switches.h, hdrs/cmds.h, or hdrs/funs.h. These files are automatically
rebuilt on compile. On the off chance they appear not to be, simply
rm them and re-run make.

Then @shutdown/reboot your MUSH.
    - Shawn/Raevnos

In this patch:
Minor Changes:
 * align() columns can now have ansi color definitions. [GM]
 
Fixes:
 * Heisencrashbug in command parser fixed. Reported by Mercutio. [GM]
 * Bug in randword() and extract() fixed. [MG]
 * Fix several memory leaks. [SW]
 * Help fixes by aumiiari and others. [MG]
 * Add more specific log messages when the chatdb fails to load, from
   report by Dan@M*U*S*H. [MG]


Summary:
 CHANGES.183               |   13 +++++++++++++
 Makefile.in               |    2 +-
 Patchlevel                |    2 +-
 game/txt/hlp/penncmd.hlp  |    8 ++++----
 game/txt/hlp/pennfunc.hlp |   31 ++++++++++++++++++++++---------
 game/txt/hlp/penntop.hlp  |    2 +-
 game/txt/hlp/pennv183.hlp |   16 +++++++++++++++-
 game/txt/hlp/pennvOLD.hlp |    2 +-
 hdrs/ansi.h               |    3 ++-
 hdrs/externs.h            |    1 +
 hdrs/game.h               |    3 ++-
 hdrs/parse.h              |    6 ++++--
 hdrs/version.h            |    6 +++---
 src/command.c             |   31 ++++++++++++++++++-------------
 src/extchat.c             |   10 ++++++++--
 src/funlist.c             |   24 +++---------------------
 src/funstr.c              |   30 +++++++++++++++++++++++++++---
 src/look.c                |   14 ++++++++++----
 src/markup.c              |    3 +--
 src/match.c               |    2 ++
 src/pcre.c                |    8 ++++++++
 src/strutil.c             |    9 ++++-----
 22 files changed, 151 insertions(+), 75 deletions(-)

Prereq: 1.8.3p12
===================================================================
--- Patchlevel	(.../183p12)	(revision 324)
+++ Patchlevel	(.../183p13)	(revision 324)
@@ -1,3 +1,3 @@
 Do not edit this file. It is maintained by the official PennMUSH patches.
-This is PennMUSH 1.8.3p12
+This is PennMUSH 1.8.3p13
 Index: Makefile.in
===================================================================
--- Makefile.in	(.../183p12)	(revision 324)
+++ Makefile.in	(.../183p13)	(revision 324)
@@ -3,7 +3,7 @@
 # - System configuration - #
 
 VERSION=1.8.3
-PATCHLEVEL=12
+PATCHLEVEL=13
 
 #
 # This section of the file should be automatically configured by the
Index: src/extchat.c
===================================================================
--- src/extchat.c	(.../183p12)	(revision 324)
+++ src/extchat.c	(.../183p13)	(revision 324)
@@ -294,14 +294,20 @@
 
   /* How many channels? */
   db_read_this_labeled_int(fp, "channels", &num_channels);
-  if (num_channels > MAX_CHANNELS)
+  if (num_channels > MAX_CHANNELS) {
+    do_rawlog(LT_ERR,
+              "CHAT: Too many channels in chatdb (there are %d, max is %d)",
+              num_channels, MAX_CHANNELS);
     return 0;
+  }
 
   /* Load all channels */
   for (i = 0; i < num_channels; i++) {
     ch = new_channel();
-    if (!ch)
+    if (!ch) {
+      do_rawlog(LT_ERR, "CHAT: Unable to allocate memory for channel %d!", i);
       return 0;
+    }
     if (!load_labeled_channel(fp, ch, flags)) {
       do_rawlog(LT_ERR, "Unable to load channel %d.", i);
       free_channel(ch);
Index: src/markup.c
===================================================================
--- src/markup.c	(.../183p12)	(revision 324)
+++ src/markup.c	(.../183p13)	(revision 324)
@@ -53,7 +53,6 @@
 
 /* Now the code */
 
-static int write_ansi_close(char *buff, char **bp);
 static int write_ansi_letters(const ansi_data *cur, char *buff, char **bp);
 static int safe_markup(char const *a_tag, char *buf, char **bp, char type);
 static int
@@ -411,7 +410,7 @@
   return retval;
 }
 
-static int
+int
 write_ansi_close(char *buff, char **bp)
 {
   int retval = 0;
Index: src/funstr.c
===================================================================
--- src/funstr.c	(.../183p12)	(revision 324)
+++ src/funstr.c	(.../183p13)	(revision 324)
@@ -38,7 +38,8 @@
 static int wraplen(char *str, size_t maxlen);
 static int align_one_line(char *buff, char **bp, int ncols,
                           int cols[MAX_COLS], int calign[MAX_COLS],
-                          char *ptrs[MAX_COLS], ansi_string *as[MAX_COLS],
+                          char *ptrs[MAX_COLS],
+                          ansi_string *as[MAX_COLS], ansi_data adata[MAX_COLS],
                           int linenum, char *fieldsep, int fslen, char *linesep,
                           int lslen, char filler);
 static int comp_gencomp(dbref executor, char *left, char *right, char *type);
@@ -1716,7 +1717,7 @@
 static int
 align_one_line(char *buff, char **bp, int ncols,
                int cols[MAX_COLS], int calign[MAX_COLS], char *ptrs[MAX_COLS],
-               ansi_string *as[MAX_COLS],
+               ansi_string *as[MAX_COLS], ansi_data adata[MAX_COLS],
                int linenum, char *fieldsep, int fslen,
                char *linesep, int lslen, char filler)
 {
@@ -1827,6 +1828,9 @@
     }
     *sp = '\0';
 
+    if (HAS_ANSI(adata[i])) {
+      write_ansi_data(&adata[i], line, &lp);
+    }
     switch (calign[i] & 0xF) {
     case AL_FULL:
     case AL_WPFULL:
@@ -1878,6 +1882,9 @@
       lp += (j >> 1) + (j & 1);
       break;
     }
+    if (HAS_ANSI(adata[i])) {
+      write_ansi_close(line, &lp);
+    }
     if ((lp - line) > BUFFER_LEN)
       lp = (line + BUFFER_LEN - 1);
     if (i < (ncols - 1) && fslen)
@@ -1908,7 +1915,9 @@
   static int cols[MAX_COLS];
   static int calign[MAX_COLS];
   static ansi_string *as[MAX_COLS];
+  static ansi_data adata[MAX_COLS];
   static char *ptrs[MAX_COLS];
+  char *ansistr;
   char filler;
   char *fieldsep;
   int fslen;
@@ -1920,6 +1929,8 @@
   fieldsep = (char *) " ";
   linesep = (char *) "\n";
 
+  memset(adata, 0, sizeof(adata));
+
   /* Get column widths */
   ncols = 0;
   for (ptr = args[0]; *ptr; ptr++) {
@@ -1962,6 +1973,18 @@
       calign[ncols] |= AL_COALESCE_RIGHT;
       ptr++;
     }
+    if (*ptr == '(') {
+      ptr++;
+      ansistr = ptr;
+      while (*ptr && *ptr != ')')
+        ptr++;
+      if (*ptr != ')') {
+        safe_str(T("#-1 INVALID ALIGN STRING"), buff, bp);
+        return;
+      }
+      *(ptr++) = '\0';
+      define_ansi_data(&adata[ncols], ansistr);
+    }
     cols[ncols++] = i;
     if (!*ptr)
       break;
@@ -2062,7 +2085,8 @@
   nline = 0;
   while (1) {
     if (!align_one_line(buff, bp, ncols, cols, calign, ptrs,
-                        as, nline++, fieldsep, fslen, linesep, lslen, filler))
+                        as, adata, nline++, fieldsep, fslen,
+                        linesep, lslen, filler))
       break;
   }
   **bp = '\0';
Index: src/funlist.c
===================================================================
--- src/funlist.c	(.../183p12)	(revision 324)
+++ src/funlist.c	(.../183p13)	(revision 324)
@@ -30,7 +30,6 @@
 #include "confmagic.h"
 
 
-static char *next_token(char *str, char sep);
 static int regrep_helper(dbref who, dbref what, dbref parent,
                          char const *name, ATTR *atr, void *args);
 enum itemfun_op { IF_DELETE, IF_REPLACE, IF_INSERT };
@@ -45,23 +44,6 @@
 
 #define RealGoodObject(x) (GoodObject(x) && !IsGarbage(x))
 
-static char *
-next_token(char *str, char sep)
-{
-  /* move pointer to start of the next token */
-
-  while (*str && (*str != sep))
-    str++;
-  if (!*str)
-    return NULL;
-  str++;
-  if (sep == ' ') {
-    while (*str == sep)
-      str++;
-  }
-  return str;
-}
-
 /** Convert list to array.
  * Chops up a list of words into an array of words. The list is
  * destructively modified. The array returned consists of
@@ -428,7 +410,7 @@
    * optional base case. With no base case, the first list element is
    * passed as %0, and the second as %1. The attribute is then evaluated
    * with these args. The result is then used as %0, and the next arg as
-   * %1. Repeat until no elements are left in the list. The base case 
+   * %1. Repeat until no elements are left in the list. The base case
    * can provide a starting point.
    */
 
@@ -587,7 +569,7 @@
 /* ARGSUSED */
 FUNCTION(fun_shuffle)
 {
-  /* given a list of words, randomize the order of words. 
+  /* given a list of words, randomize the order of words.
    * We do this by taking each element, and swapping it with another
    * element with a greater array index (thus, words[0] can be swapped
    * with anything up to words[n], words[5] with anything between
@@ -763,7 +745,7 @@
   /* Split up the list, sort it, reconstruct it. */
   nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, args[1], sep);
   if (nptrs > 1)                /* pointless to sort less than 2 elements */
-    sane_qsort((void **)ptrs, 0, nptrs - 1, u_comp);
+    sane_qsort((void **) ptrs, 0, nptrs - 1, u_comp);
 
   arr2list(ptrs, nptrs, buff, bp, osep);
   freearr(ptrs, nptrs);
Index: src/match.c
===================================================================
--- src/match.c	(.../183p12)	(revision 324)
+++ src/match.c	(.../183p13)	(revision 324)
@@ -479,6 +479,8 @@
     }
   }
 
+  mush_free(sname, "mri.string");
+
   return bestmatch;
 }
 
Index: src/look.c
===================================================================
--- src/look.c	(.../183p12)	(revision 324)
+++ src/look.c	(.../183p13)	(revision 324)
@@ -1509,19 +1509,20 @@
  * \param dec_type flags for what to show in decompile, and how to show it
  */
 void
-do_decompile(dbref player, const char *name, const char *prefix, int dec_type)
+do_decompile(dbref player, const char *xname, const char *prefix, int dec_type)
 {
   dbref thing;
   char object[BUFFER_LEN];
-  char *objp, *attrib, *attrname;
+  char *objp, *attrib, *attrname, *name;
 
   int skipdef = (dec_type & DEC_SKIPDEF);
 
   /* @decompile must always have an argument */
-  if (!name || !*name) {
+  if (!xname || !*xname) {
     notify(player, T("What do you want to @decompile?"));
     return;
   }
+  name = mush_strdup(xname, "decompile.name");
   attrib = strchr(name, '/');
   if (attrib)
     *attrib++ = '\0';
@@ -1529,11 +1530,13 @@
   /* find object */
   if ((thing = noisy_match_result(player, name, NOTYPE, MAT_EVERYTHING)) ==
       NOTHING) {
+    mush_free(name, "decompile.name");
     return;
   }
 
   if (!GoodObject(thing) || IsGarbage(thing)) {
     notify(player, T("Garbage is garbage."));
+    mush_free(name, "decompile.name");
     return;
   }
 
@@ -1570,16 +1573,19 @@
     while ((attrib = split_token(&attrname, ' ')) != NULL) {
       decompile_atrs(player, thing, object, attrib, prefix, skipdef);
     }
+    mush_free(name, "decompile.name");
     return;
   } else if (!(dec_type & DEC_FLAG)) {
     /* Show all attrs, nothing else */
     decompile_atrs(player, thing, object, "**", prefix, skipdef);
+    mush_free(name, "decompile.name");
     return;
   }
 
   /* else we have a full decompile */
   if (!Can_Examine(player, thing)) {
     notify(player, T("Permission denied."));
+    mush_free(name, "decompile.name");
     return;
   }
 
@@ -1620,7 +1626,7 @@
   if (dec_type & DEC_ATTR) {
     decompile_atrs(player, thing, object, "**", prefix, skipdef);
   }
-
+  mush_free(name, "decompile.name");
 }
 
 static char *
Index: src/strutil.c
===================================================================
--- src/strutil.c	(.../183p12)	(revision 324)
+++ src/strutil.c	(.../183p13)	(revision 324)
@@ -28,7 +28,6 @@
 #include "log.h"
 #include "confmagic.h"
 
-char *next_token(char *str, char sep);
 int format_long(intmax_t val, char *buff, char **bp, int maxlen, int base);
 
 char *
@@ -153,7 +152,7 @@
 }
 #endif
 
-/** Does string begin with prefix? 
+/** Does string begin with prefix?
  * This comparison is case-insensitive.
  * \param string to check.
  * \param prefix to check against.
@@ -946,7 +945,7 @@
 /* Replace two tokens in a string at once. All-around better than calling
  * replace_string() twice
  */
-/** Search for all copies of two old strings, and replace each with a 
+/** Search for all copies of two old strings, and replace each with a
  * corresponding newbit.
  * The replaced string is returned, newly allocated.
  * \param old array of two strings to find.
@@ -1209,7 +1208,7 @@
 #endif                          /* !HAVE_IMAXDIV */
 
 /** Safely append an int to a string. Returns a true value on failure.
- * This will someday take extra arguments for use with our version 
+ * This will someday take extra arguments for use with our version
  * of snprintf. Please try not to use it.
  * maxlen = total length of string.
  * buf[maxlen - 1] = place where \0 will go.
@@ -1217,7 +1216,7 @@
  * \param val value to append.
  * \param buff string to append to.
  * \param bp pointer to pointer to insertion point in buff.
- * \param maxlen total length of string. 
+ * \param maxlen total length of string.
  * \param base the base to render the number in.
  */
 int
Index: src/command.c
===================================================================
--- src/command.c	(.../183p12)	(revision 324)
+++ src/command.c	(.../183p13)	(revision 324)
@@ -921,7 +921,12 @@
       if (*f)
         f++;
       i++;
-      t++;
+      /* Because we test on f, not t. This was causing a bug wherein
+       * trying to build a commandraw with multiple rsargs, including
+       * one massive one, was causing a crash.
+       */
+      if ((t - to) < (BUFFER_LEN - 1))
+        t++;
       if (i == MAX_ARG)
         done = 1;
     }
@@ -978,12 +983,13 @@
 }
 
 /** A handy macro to free up the command_parse-allocated variables */
-#define command_parse_free_args \
-    mush_free(command, "string"); \
-    mush_free(swtch, "string"); \
-    mush_free(ls, "string"); \
-    mush_free(rs, "string"); \
-    mush_free(switches, "string")
+#define command_parse_free_args	  \
+    mush_free(command, "string_command"); \
+    mush_free(swtch, "string_swtch"); \
+    mush_free(ls, "string_ls"); \
+    mush_free(rs, "string_rs"); \
+    mush_free(switches, "string_switches"); \
+    if (sw) SW_FREE(sw)
 
 /** Parse commands.
  * Parse the commands. This is the big one!
@@ -1022,11 +1028,11 @@
 
   rhs_present = 0;
 
-  command = mush_malloc(BUFFER_LEN, "string");
-  swtch = mush_malloc(BUFFER_LEN, "string");
-  ls = mush_malloc(BUFFER_LEN, "string");
-  rs = mush_malloc(BUFFER_LEN, "string");
-  switches = mush_malloc(BUFFER_LEN, "string");
+  command = mush_malloc(BUFFER_LEN, "string_command");
+  swtch = mush_malloc(BUFFER_LEN, "string_swtch");
+  ls = mush_malloc(BUFFER_LEN, "string_ls");
+  rs = mush_malloc(BUFFER_LEN, "string_rs");
+  switches = mush_malloc(BUFFER_LEN, "string_switches");
   if (!command || !swtch || !ls || !rs || !switches)
     mush_panic("Couldn't allocate memory in command_parse");
   p = string;
@@ -1373,7 +1379,6 @@
     free_global_regs("hook.regs", saveregs);
   }
 
-  SW_FREE(sw);
   command_parse_free_args;
   return retval;
 }
Index: src/pcre.c
===================================================================
--- src/pcre.c	(.../183p12)	(revision 324)
+++ src/pcre.c	(.../183p13)	(revision 324)
@@ -1261,6 +1261,8 @@
 
 
 
+
+
 pcre_get_substring_list(const char *subject, int *ovector, int stringcount,
                         const char ***listptr);
 
@@ -1354,6 +1356,8 @@
 
 
 
+
+
 pcre_get_substring(const char *subject, int *ovector, int stringcount,
                    int stringnumber, const char **stringptr);
 
@@ -1414,6 +1418,8 @@
 
 
 
+
+
 pcre_get_named_substring(const pcre * code, const char *subject, int *ovector,
                          int stringcount, const char *stringname,
                          const char **stringptr);
@@ -2304,6 +2310,8 @@
 
 
 
+
+
 compile_regex(int, int, int *, uschar **, const uschar **, int *, BOOL, int,
               int *, int *, branch_chain *, compile_data *);
 
Index: game/txt/hlp/index.hlp
===================================================================
Index: game/txt/hlp/pennfunc.hlp
===================================================================
--- game/txt/hlp/pennfunc.hlp	(.../183p12)	(revision 324)
+++ game/txt/hlp/pennfunc.hlp	(.../183p13)	(revision 324)
@@ -380,7 +380,20 @@
 
   <widths> is a space-separated list of column widths. '10 10 10' for
   the widths argument specifies that there are 3 columns, each 10
-  spaces wide. You can alter the behavior of a column in two ways:
+  spaces wide. You can alter the behavior of a column in multiple ways.
+  (Check 'help align2' for more details)
+
+  <filler> is a single character that, if given, is the character used
+  to fill empty columns and remaining spaces. <colsep>, if given, is
+  inserted between every column, on every row. <rowsep>, if given, is
+  inserted between every line. By default, <filler> and <colsep> are a
+  space, and <rowsep> is a newline.
+
+  Continued in 'help align2'
+& ALIGN2
+  You can modify column behavior within align(). The basic format is:
+
+  [justification]Width[runout][(ansi)]
 
   Justification: Placing one of these characters before the width alters
   the spacing for this column. (e.g: <30)
@@ -394,14 +407,11 @@
     ` Merge with the column on the left.
     ' Merge with the column on the right.
 
-  <filler> is a single character that, if given, is the character used
-  to fill empty columns and remaining spaces. <colsep>, if given, is
-  inserted between every column, on every row. <rowsep>, if given, is
-  inserted between every line. By default, <filler> and <colsep> are a
-  space, and <rowsep> is a newline.
+  Ansi: Place ansi characters (as defined in 'help ansi()') within ()s to
+  define a column's ansi markup.
 
-  Continued in 'help align2'
-& ALIGN2
+  Continued in 'help align3'
+& ALIGN3
   Examples:
   
     > &line me=align(<5 10 20,\([left(xget(%0,sex),1)]\),name(%0),name(loc(%0)))
@@ -421,6 +431,7 @@
          +                  Luke                  +
          +----------------------------------------+
 
+  Continued in 'help align4'
 See also: center(), ljust(), rjust(), table()
 & ALLOF()
   allof(<expr>[, ... , <exprN>], <osep>)
@@ -5015,7 +5026,9 @@
   If no <trim style> is specified, characters are trimmed from both the
   left and right sides of the string. If the 'l' trim style is specified, 
   characters are only trimmed from the left side. If the 'r' trim style is 
-  specified, characters are only trimmed from the right side.
+  specified, characters are only trimmed from the right side. If the 'b'
+  trim style is specified, or a style is omitted, characters are trimmed
+  off of both sides of the string.
 
   Normally, the arguments for trim() are in the same order as trimpenn().
   However, if the tiny_trim_fun @config option is on, the <character to trim>
Index: game/txt/hlp/pennv183.hlp
===================================================================
--- game/txt/hlp/pennv183.hlp	(.../183p12)	(revision 324)
+++ game/txt/hlp/pennv183.hlp	(.../183p13)	(revision 324)
@@ -1,4 +1,4 @@
-& 1.8.3p12
+& 1.8.3p13
 & changes
 This is a list of changes in this patchlevel which are probably of
 interest to players. More information about new commands and functions
@@ -11,6 +11,20 @@
 A list of the patchlevels associated with each release can
 be read in 'help patchlevels'.
 
+Version 1.8.3 patchlevel 13                     Feb 13, 2010
+
+Minor Changes:
+ * align() columns can now have ansi color definitions. [GM]
+ 
+Fixes:
+ * Heisencrashbug in command parser fixed. Reported by Mercutio. [GM]
+ * Bug in randword() and extract() fixed. [MG]
+ * Fix several memory leaks. [SW]
+ * Help fixes by aumiiari and others. [MG]
+ * Add more specific log messages when the chatdb fails to load, from
+   report by Dan@M*U*S*H. [MG]
+
+& 1.8.3p12
 Version 1.8.3 patchlevel 12                     Feb 07, 2010
 
 Major Changes:
Index: game/txt/hlp/penntop.hlp
===================================================================
--- game/txt/hlp/penntop.hlp	(.../183p12)	(revision 324)
+++ game/txt/hlp/penntop.hlp	(.../183p13)	(revision 324)
@@ -581,7 +581,7 @@
     
 See also: ENACTOR, EXECUTOR
 & EVALUATION ORDER
-  Whenever some text is entered by an objec, the MUSH attempts to match it 
+  Whenever some text is entered by an object, the MUSH attempts to match it
   against a valid game command in the following order of possible commands:
 
     Socket commands (*): QUIT, SCREENWIDTH, etc
Index: game/txt/hlp/penncmd.hlp
===================================================================
--- game/txt/hlp/penncmd.hlp	(.../183p12)	(revision 324)
+++ game/txt/hlp/penncmd.hlp	(.../183p13)	(revision 324)
@@ -499,7 +499,7 @@
   @attribute/rename <attrib>=<new name>
 
   The @attribute command displays and modifies the MUSH's standard
-  attributes (see "@list/attributes" for a list of them).
+  attributes (see "@list/attribs" for a list of them).
   
   *** Unlike TinyMUSH, changes to the PennMUSH attribute table are not saved 
   *** across shutdowns. Use these commands from God's @startup to ensure
@@ -4246,10 +4246,10 @@
   WHO command, such as:
   
     > &HOOK.WHO <object>=not(comp(left(%c,3),WHO))
-	  > @hook/ignore WHO=<object>,HOOK.WHO
+    > @hook/ignore WHO=<object>,HOOK.WHO
 	  
-	@hooks are not maintained across reboots, and should be placed into an
-	@startup on a low-dbref object.
+  @hooks are not maintained across reboots, and should be placed into an
+  @startup on a low-dbref object.
   
   Note: The WHO command available at the login screen is totally separate
   from the in-game WHO command, and is not affected by any changes to the 
Index: game/txt/hlp/pennvOLD.hlp
===================================================================
--- game/txt/hlp/pennvOLD.hlp	(.../183p12)	(revision 324)
+++ game/txt/hlp/pennvOLD.hlp	(.../183p13)	(revision 324)
@@ -4417,7 +4417,7 @@
 For information on a specific patchlevel of one of the versions listed,
 type 'help <version>p<patchlevel>'. For example, 'help 1.7.2p3'
 
-1.8.3: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
+1.8.3: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
 1.8.2: 0, 1, 2, 3, 4, 5, 6, 7, 8
 1.8.1: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
 1.8.0: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
Index: CHANGES.183
===================================================================
--- CHANGES.183	(.../183p12)	(revision 324)
+++ CHANGES.183	(.../183p13)	(revision 324)
@@ -16,6 +16,19 @@
 
 ==========================================================================
 
+Version 1.8.3 patchlevel 13                     Feb 13, 2010
+
+Minor Changes:
+ * align() columns can now have ansi color definitions. [GM]
+ 
+Fixes:
+ * Heisencrashbug in command parser fixed. Reported by Mercutio. [GM]
+ * Bug in randword() and extract() fixed. [MG]
+ * Fix several memory leaks. [SW]
+ * Help fixes by aumiiari and others. [MG]
+ * Add more specific log messages when the chatdb fails to load, from
+   report by Dan@M*U*S*H. [MG]
+
 Version 1.8.3 patchlevel 12                     Feb 07, 2010
 
 Major Changes:
Index: hdrs/ansi.h
===================================================================
--- hdrs/ansi.h	(.../183p12)	(revision 324)
+++ hdrs/ansi.h	(.../183p13)	(revision 324)
@@ -89,12 +89,13 @@
   char back;
 } ansi_data;
 
+#define HAS_ANSI(adata) (adata.bits || adata.offbits || adata.fore || adata.back)
 int read_raw_ansi_data(ansi_data *store, const char *codes);
 int write_raw_ansi_data(ansi_data *old, ansi_data *cur, char *buff, char **bp);
 
 void define_ansi_data(ansi_data *store, const char *str);
 int write_ansi_data(ansi_data *cur, char *buff, char **bp);
-
+int write_ansi_close(char *buff, char **bp);
 
 void nest_ansi_data(ansi_data *old, ansi_data *cur);
 
Index: hdrs/game.h
===================================================================
--- hdrs/game.h	(.../183p12)	(revision 324)
+++ hdrs/game.h	(.../183p13)	(revision 324)
@@ -75,7 +75,8 @@
 extern void do_entrances(dbref player, const char *where, char **argv,
                          int types);
 enum dec_type { DEC_NORMAL, DEC_DB = 1, DEC_FLAG = 2, DEC_ATTR =
-    4, DEC_SKIPDEF = 8 };
+    4, DEC_SKIPDEF = 8
+};
 extern void do_decompile(dbref player, const char *name, const char *prefix,
                          int dec_type);
 
Index: hdrs/parse.h
===================================================================
--- hdrs/parse.h	(.../183p12)	(revision 324)
+++ hdrs/parse.h	(.../183p13)	(revision 324)
@@ -34,7 +34,7 @@
 extern char e_range[];          /* #-1 OUT OF RANGE */
 
 /* The following routines all take strings as arguments, and return
- * data of the appropriate types.  
+ * data of the appropriate types.
  */
 
 bool parse_boolean(char const *str);
@@ -131,7 +131,7 @@
  * The argument strings are stored in BUFFER_LEN buffers, but reliance
  * on that size is also considered bad form.  The argument strings may
  * be modified, but modifying the pointers to the argument strings will
- * cause crashes. 
+ * cause crashes.
  *
  * executor corresponds to %!, the object invoking the function.
  * caller   corresponds to %@, the last object to do a U() or similar.
@@ -221,6 +221,8 @@
  * PE_DEFAULT is the most commonly used set of flags, normally sufficient
  * for calls to process_expression().
  *
+ * PE_DOLLAR does $0-$9 subs, for regedit()
+ *
  * PE_UDEFAULT is PE_DEFAULT without PE_DOLLAR, intended for use in
  * calling attributes (via u(), mix, step, etc)
  *
Index: hdrs/version.h
===================================================================
--- hdrs/version.h	(.../183p12)	(revision 324)
+++ hdrs/version.h	(.../183p13)	(revision 324)
@@ -1,4 +1,4 @@
 #define VERSION "1.8.3"
-#define PATCHLEVEL "12"
-#define PATCHDATE "[02/07/2010]"
-#define NUMVERSION 1008003012
+#define PATCHLEVEL "13"
+#define PATCHDATE "[02/13/2010]"
+#define NUMVERSION 1008003013
Index: hdrs/externs.h
===================================================================
--- hdrs/externs.h	(.../183p12)	(revision 324)
+++ hdrs/externs.h	(.../183p13)	(revision 324)
@@ -429,6 +429,7 @@
 int filter_found(dbref thing, const char *msg, int flag);
 
 /* From strutil.c */
+char *next_token(char *str, char sep);
 char *split_token(char **sp, char sep);
 char *chopstr(const char *str, size_t lim);
 int string_prefix(const char *restrict string, const char *restrict prefix);
