This is patch03 to PennMUSH 1.8.4. After applying this patch, you will
have version 1.8.4p03

To apply this patch, save it to a file in your top-level 1.8.4p1 MUSH directory,
and do the following:
        patch -p0 < 1.8.4-patch03
        make install

If you use GNU patch 2.2, you probably want the above to be 'patch -b -p0',
not just 'patch -p0'.

Users need not worry about failed hunks in src/switchinc.c,
hdrs/switches.h, hdrs/cmds.h, or hdrs/funs.h. These files are automatically
rebuilt on compile. On the off chance they appear not to be, simply
rm them and re-run make.

* If you have not made any changes to src/local.c:
  cp src/local.dst src/local.c
* If you have made changes:
  Update the definition of local_timer() according to the instructions in
  the new HACKING.184 file.

Then @shutdown/reboot your MUSH.
    - Shawn/Raevnos


In this patch:

Events:
 * Event system added. Certain things can now trigger events using @config
   event_handler. See "help events" and "help event <type>". [GM]
 * dump events: dump`5min, dump`1min, dump`complete.
 * object events: object`create, object`destroy, object`move,
   object`rename, object`kill.
 * sql events: sql`connect, sql`disconnect.
 * signal events: signal`usr1, signal`usr2.
 * player events: player`create, player`fail, player`connect,
   player`disconnect, player`inactivity.
 * socket events: socket`connect, socket`disconnect
 * database events: db`dbck, db`purge, db`wcheck
 * Periodic system events like warnings checks and db consistency
   checks are now handled by a timed queue and integrated with
   softcode events. Local hackers: This involves changes to
   local.c. If you have no changes in local.c, just delete the file.
   Otherwise, see HACKING.184 for more info. [SW]

Commands:
 * @hook/override/inplace - You can now run softcode with the same priority
   as hardcode! [GM]
 * @lock (and all lock keys) now accepts NAME^<pattern> for matching against
   an object's name. [GM]
 * @mapsql passes row results to attributes. Suggested by Mercutio. [GM]
 * @dig now takes an optional garbage dbref argument to specify the new
   dbref. Suggested by Paige. [GM]
 * The help command now does some auto-expansion of topics. For example,
   'help @chan ad2' will be expanded to match 'help @channel admin2'. [MG]
 * @force/inplace, @switch/inplace and @select/inplace now run their commands
   without queueing new events. These are limited by the @include limit. [GM]
 * @hide without a switch now toggles hide status, rather than defaulting to
   @hide/on. [MG]
 * @log now takes a /recall switch for showing wizards the most recent activity
   in a log file. [SW]
 * @lemit and @zemit both have /noisy and /silent switches to suppress/show
   confirmation messages. With no switch, silent_pemit determines whether
   the message is shown. Suggested by Paige for consistancy. [MG]
   
Attributes:
 * New no_debug flag, which prevents debug info being shown for an attribute
   when the object is set DEBUG. [MG]
   
Config:
 * New @config option chan_title_len controls the length of @channel/title's.
   Suggested by Paige. [MG]

Locks:
 * New @lock/pay, controls who can "give" an object pennies or "buy" items
   from an object. Based on patch by Covenent. [MG]

Functions:
 * lockfilter() lets you filter a list of dbrefs using a lock key. [GM]
 * align() now has '$' (nofill) as an option. Ideal for rightmost columns.
   Suggested by Minion. [GM]
 * dig() now takes an optional garbage dbref argument to specify the new
   dbref. Suggested by Paige. [GM]
 * convutctime() and convtime(<time>, utc) to convert a timestring to
   # of seconds since UTC. Patch by Minion.
 * powers() with no arguments now returns a list of powers, similar to
   lflags() with no args. [MG]
 * trim() can now trim multiple characters. [MG] [GM]
 * In some cases, privs are no longer needed to use locate(). [MG]
 * cmogrifier(), returns the mogrifier object for a channel. Suggested by
   Trinsec, patch by Minion.

Minor Changes:
 * The Can_Nspemit @power has been renamed to Can_Spoof, to better reflect
   its uses. Can_Nspemit is still an alias. [MG]
 * Considerable improvement in the speed of functions that sort
   case-insensitively, particularly using 'm' sort (Now default). [GM]
 * Combined fun_setinter, fun_setdiff and fun_setunion into fun_setmanip. [GM]
 * For hardcoders: list2arr and list2arr_ansi now take a third argument
   on whether to include empty items. [GM]
 * page and @mail will report to you if your recipient(s) cannot reply
   to you. Suggested by Paige. [GM]
 * The debug attribute flag now shows more debug info. [MG]
 * @oemit now does better object matching, can match names with spaces when
   enclosed in double quotes, and, when given a <room> but no matching
   objects, shows the message to everyone in the room, instead of noone.
   From a bug reported by Paige. [MG]
 * Paranoid objects now see nospoof messages for their emits. [MG]
 * ANSI is now ignored when checking the length of channel titles. Suggested
   by Paige. [MG]
 * @decompile with a <prefix> now shows cmds for setting attribute flags.
   @decompile/tf still omits cmds for attr flags. [MG]
 * @mail <msg-lists> which don't specify a folder now act on your current
   folder, instead of Folder 0. Suggested by Paige, patch by Minion.
 * @dig, @open and @name now set exit aliases into the @alias attribute,
   instead of including them in the exit name. Also, @name can now set/clear
   the @alias of players/exits while changing the name. See help @name for
   details. Suggested by Minion. [MG]
 * The logging code has been rewritten to make extending it with further
   log files easier. [SW]
 * When used by a non-player, @search and related functions now search from
   the perspective of the object's owner. Suggested by Covenent. [MG]
 * The LASTPAGED attribute now stores objids instead of names, allowing you
   to repage even when the target changes their name. [MG]
 * When zwho() or @chzone fail because you don't pass the @lock/zone, zone
   failure verbs are triggered (as per 'help failure'). Based on a patch by
   Covenent. [MG]
 * sub() can now take more than two arguments. Suggested by Paige. [MG]
 * In the hardcode, disconnected players in the DESC struct are shown as -1
   instead of 0, to avoid conflicts with #0. Based on patch by Paige. [MG]
 * It was sometimes possible to "buy" items from yourself. [MG]

Fixes:
 * Fixing list type autodetect. [GM]
 * Help fixes by Daniel Powell, AnneLions, Minion and others. [MG]
 * Connect/disconnect messages for combined channels incorrectly showed
   NOSPOOF data. Reported by Sketch. [MG]
 * The delimiter between combined channel names in @chatformat is now '|'
   instead of ' | ', as documented. Reported by Trinsec. [MG]
 * ansi(h,) now returns absolutely nothing, instead of an ansi-highlighted
   nothing. Fixes a few minor/obscure bugs. [MG]
 * @edit sometimes displayed a success message even when it failed. [MG]
 * @cpattr/@mvattr would sometimes copy attribute flags, even when the
   attribute value couldn't be copied. [MG]
 * Bug in attribute comparisons added in p2 could cause attributes to
   not be found at times. [MG]
 * sortby()s results would sometimes be reversed by mistake. [GM]
 * Minor bugfix in @include. [MG]
 * round() sometimes returned numbers with more decimal digits than
   desired. 
 * The '*' option in locate() didn't actually include all match types. [MG]
 * @include incorrectly refunded the queue_cost, giving people free pennies.
   Reported by Covenent. [MG]
 * lnum() didn't handle negative <step>s well. Reported by Minion. [MG]
 * comp()s results was sometimes negated. Reported by Covenent. [MG]


Summary of changed files:
 CHANGES.184                 |  131 ++
 HACKING.184                 |   59 +
 Makefile.in                 |    2 
 Patchlevel                  |    2 
 game/aliascnf.dst           |    8 
 game/mushcnf.dst            |    8 
 game/restrictcnf.dst        |   16 
 game/txt/hlp/index.hlp      |  736 ++++++------
 game/txt/hlp/pennattr.hlp   |    5 
 game/txt/hlp/pennchat.hlp   |   86 -
 game/txt/hlp/penncmd.hlp    |  442 ++++---
 game/txt/hlp/pennconf.hlp   |    3 
 game/txt/hlp/pennevents.hlp |  214 +++
 game/txt/hlp/pennflag.hlp   |   43 
 game/txt/hlp/pennfunc.hlp   |  164 +-
 game/txt/hlp/pennpueb.hlp   |   51 
 game/txt/hlp/penntop.hlp    |  446 ++++---
 game/txt/hlp/pennv184.hlp   |  134 ++
 game/txt/hlp/pennvOLD.hlp   |    2 
 hdrs/ansi.h                 |   12 
 hdrs/attrib.h               |    7 
 hdrs/bufferq.h              |    4 
 hdrs/command.h              |   15 
 hdrs/conf.h                 |    3 
 hdrs/dbdefs.h               |    1 
 hdrs/extchat.h              |    4 
 hdrs/externs.h              |   53 
 hdrs/game.h                 |   24 
 hdrs/lock.h                 |    1 
 hdrs/log.h                  |   57 
 hdrs/match.h                |   58 
 hdrs/mushdb.h               |    2 
 hdrs/mushtype.h             |    5 
 hdrs/parse.h                |    7 
 hdrs/sort.h                 |   49 
 hdrs/svninfo.h              |    2 
 hdrs/switches.h             |  294 ++---
 hdrs/version.h              |    6 
 po/Makefile                 |    2 
 po/bg_BG.pox                |    9 
 po/da_DK.pox                |    4 
 po/de_DE.pox                |    4 
 po/fr_FR.pox                |    8 
 po/hr_HR.pox                |   89 +
 po/hu_HU.pox                |    8 
 po/nl_NL.pox                |  254 ++++
 po/no_NO.pox                |   17 
 po/pennmush.pot             | 2580 ++++++++++++++++++++++----------------------
 po/pl_PL.pox                |   13 
 po/pt_BR.pox                |    4 
 po/sv_SE.pox                |    4 
 src/Makefile.in             |   45 
 src/SWITCHES                |    4 
 src/atr_tab.c               |    2 
 src/attrib.c                |   74 -
 src/boolexp.c               |   15 
 src/bsd.c                   |  208 ++-
 src/chunk.c                 |   18 
 src/cmds.c                  |  134 +-
 src/command.c               |   85 -
 src/conf.c                  |   28 
 src/cque.c                  |  406 +++++-
 src/create.c                |   62 -
 src/destroy.c               |   39 
 src/extchat.c               |  149 +-
 src/extmail.c               |   38 
 src/flags.c                 |    7 
 src/function.c              |   20 
 src/fundb.c                 |   68 +
 src/funlist.c               |  518 ++------
 src/funmath.c               |   60 -
 src/funmisc.c               |   10 
 src/funstr.c                |  131 +-
 src/funtime.c               |   20 
 src/funufun.c               |    9 
 src/game.c                  |   28 
 src/help.c                  |   81 +
 src/local.dst               |   27 
 src/lock.c                  |   20 
 src/log.c                   |  259 ++--
 src/look.c                  |   22 
 src/markup.c                |    3 
 src/match.c                 |  120 +-
 src/move.c                  |   91 -
 src/notify.c                |    9 
 src/parse.c                 |   62 -
 src/pcre.c                  |    4 
 src/player.c                |  142 +-
 src/plyrlist.c              |   11 
 src/predicat.c              |  205 +++
 src/rob.c                   |   98 +
 src/set.c                   |  159 +-
 src/sort.c                  |  387 ++++--
 src/speech.c                |  109 +
 src/sql.c                   |  245 +++-
 src/switchinc.c             |    4 
 src/timer.c                 |  323 ++++-
 src/utils.c                 |    5 
 src/wild.c                  |   44 
 src/wiz.c                   |  117 +
 100 files changed, 6856 insertions(+), 4021 deletions(-)

Prereq: 1.8.4p2
===================================================================
--- Patchlevel	(.../184p2)	(revision 828)
+++ Patchlevel	(.../184p3)	(revision 828)
@@ -1,3 +1,3 @@
 Do not edit this file. It is maintained by the official PennMUSH patches.
-This is PennMUSH 1.8.4p2
+This is PennMUSH 1.8.4p3
 
Index: HACKING.184
===================================================================
--- HACKING.184	(.../184p2)	(revision 0)
+++ HACKING.184	(.../184p3)	(revision 828)
@@ -0,0 +1,59 @@
+This is the most current changes file for PennMUSH Hardcode.
+
+If you are maintaining an add-on for PennMUSH, this details any changes
+to extant functions that are likely to be used by the embracers and
+extenders out there.
+
+Changes are in reverse chronological order. You can probably find the reason
+for most of these changes in the equivalent CHANGES file, but only those
+that have altered hardcode will appear here.
+
+[SW] is Shawn Wagner, a PennMUSH developer (aka Raevnos), also
+ responsible for most unattributed changes.
+[EEH] is Ervin Hearn III, a PennMUSH developer (aka Noltar)
+[GM] is Greg Millam, a PennMUSH developer (aka Walker)
+[MG] is Mike Griffiths, a PennMUSH developer (aka Talvo)
+[TAP] is T. Alexander Popiel, a former PennMUSH developer (aka Talek)
+[3] refers to code by (or inspired by) TinyMUSH 3.0
+[MUX] refers to code by (or inspired by) TinyMUX 2.x
+[Rhost] refers to code by (or inspired by) RhostMUSH
+
+==========================================================================
+
+Version 1.8.4 patchlevel 3                                 Mar 18,  2011
+
+ queue_event(<enactor or SYSEVENT>, <attribute name>, "argfmt", ...)
+     lets you queue events on the event handler, if set.
+
+ Using a bunch of gencomp() calls, such as for setunion, is now deprecated,
+     you should use get_list_type_info, slist_build, slist_qsort, slist_free
+     and free_list_type_info. Look at fun_setmanip and do_gensort for how
+     to do it.
+
+ list2arr_ansi() now calls list2arr() when there is no markup.
+
+
+ list2arr_ansi and list2arr now take a third argument, 'nullok'. If nullok
+     is 0, then it will ignore null items. For old behaviour, pass 1.
+
+ All timed events have been moved to a new system queue:
+     timed callbacks are of the type "bool (*sq_func)(void *data);".
+     To set up a callback, use:
+       sq_register_in(<wait time>, <sq_func>, <data>, <event name>)
+     To repeat it infinitely:
+       sq_register_loop(<wait time>, <sq_func>, <data>, <event name>)
+     sq_func() is called with <data> as its argument.
+     If <event name> is non-NULL and sq_func returns a boolean true, then
+     the queue will trigger the event <event name> with no arguments when it
+     is completed calling sq_func.
+ 
+ Because of the change to system queue for timed events, local_timer in local.c
+     has been changed. If you haven't changed local.c, just copy local.dst over
+     it. If you have, and you want local_timer to run every second, then
+     add sq_register_loop(1, local_timer, NULL, NULL); to local_startup(),
+     and change local_timer's signature to:
+         bool local_timer(void *data __attribute__((__unused__)))
+     and return false.
+
+
+ In the DESC struct, descriptors which have not connected to a player now have
+ d->player set to NOTHING (-1) instead of 0.
Index: Makefile.in
===================================================================
--- Makefile.in	(.../184p2)	(revision 828)
+++ Makefile.in	(.../184p3)	(revision 828)
@@ -3,7 +3,7 @@
 # - System configuration - #
 
 VERSION=1.8.4
-PATCHLEVEL=2
+PATCHLEVEL=3
 
 #
 # This section of the file should be automatically configured by the
Index: src/fundb.c
===================================================================
--- src/fundb.c	(.../184p2)	(revision 828)
+++ src/fundb.c	(.../184p3)	(revision 828)
@@ -565,6 +565,11 @@
 {
   dbref it;
 
+  if (nargs == 0) {
+    safe_str(list_all_flags("POWER", NULL, executor, 0x2), buff, bp);
+    return;
+  }
+
   if (nargs == 2) {
     if (!command_check_byname(executor, "@power") || fun->flags & FN_NOSIDEFX) {
       safe_str(T(e_perm), buff, bp);
@@ -1442,6 +1447,51 @@
 }
 
 /* ARGSUSED */
+FUNCTION(fun_lockfilter)
+{
+  dbref victim;
+  char *r, *s;
+  char delim = ' ';
+  int first = 1;
+  boolexp elock = TRUE_BOOLEXP;
+
+  elock = parse_boolexp(executor, args[0], "Search");
+
+  if (elock == TRUE_BOOLEXP) {
+    safe_str(T("#-1 INVALID BOOLEXP"), buff, bp);
+    return;
+  }
+
+  if (nargs > 2) {
+    if (strlen(args[2]) > 2) {
+      safe_str(T("#-1 SEPARATOR MUST BE ONE CHARACTER"), buff, bp);
+      return;
+    }
+    delim = args[2][0];
+    if (!delim) {
+      delim = ' ';
+    }
+  }
+
+  s = trim_space_sep(args[1], delim);
+  while ((r = split_token(&s, delim)) != NULL) {
+    victim = noisy_match_result(executor, r, NOTYPE, MAT_ABSOLUTE);
+    if (victim != NOTHING && Can_Locate(executor, victim)) {
+      if (eval_boolexp(victim, elock, executor)) {
+        if (first) {
+          first = 0;
+        } else {
+          safe_chr(delim, buff, bp);
+        }
+        safe_dbref(victim, buff, bp);
+      }
+    }
+  }
+  free_boolexp(elock);
+  return;
+}
+
+/* ARGSUSED */
 FUNCTION(fun_testlock)
 {
   dbref victim = match_thing(executor, args[1]);
@@ -1961,10 +2011,6 @@
     safe_str("#-1", buff, bp);
     return;
   }
-  if (!See_All(executor) && !controls(executor, looker)) {
-    safe_str("#-1", buff, bp);
-    return;
-  }
 
   /* find out our preferred match type and flags */
   pref_type = 0;
@@ -1992,7 +2038,7 @@
       match_flags |= MAT_TYPE;
       break;
     case '*':
-      match_flags |= MAT_EVERYTHING;
+      match_flags |= (MAT_EVERYTHING | MAT_CONTAINER | MAT_CARRIED_EXIT);
       break;
     case 'a':
       match_flags |= MAT_ABSOLUTE;
@@ -2044,7 +2090,17 @@
     pref_type = NOTYPE;
 
   if (!(match_flags & ~(MAT_CHECK_KEYS | MAT_TYPE | MAT_EXACT)))
-    match_flags |= MAT_EVERYTHING;
+    match_flags |= (MAT_EVERYTHING | MAT_CONTAINER | MAT_CARRIED_EXIT);
+
+  if ((match_flags &
+       (MAT_NEIGHBOR | MAT_CONTAINER | MAT_POSSESSION | MAT_HERE | MAT_EXIT |
+        MAT_CARRIED_EXIT))) {
+    if (!nearby(executor, looker) && !See_All(executor)
+        && !controls(executor, looker)) {
+      safe_str("#-1", buff, bp);
+      return;
+    }
+  }
 
   /* report the results */
   if (!ambig_ok)
Index: src/sql.c
===================================================================
--- src/sql.c	(.../184p2)	(revision 828)
+++ src/sql.c	(.../184p3)	(revision 828)
@@ -59,6 +59,7 @@
 #include "mushdb.h"
 #include "confmagic.h"
 #include "ansi.h"
+#include "match.h"
 
 extern signed char qreg_indexes[UCHAR_MAX + 1];
 
@@ -325,6 +326,178 @@
     safe_str(T("#-1 TOO LONG"), buff, bp);
 }
 
+COMMAND(cmd_mapsql)
+{
+#ifdef HAVE_MYSQL
+  MYSQL_FIELD *fields = NULL;
+#endif
+  void *qres;
+  int affected_rows = -1;
+  int rownum;
+  int numfields;
+  int numrows;
+  char *names[10];
+  char *cells[10];
+  char tbuf[BUFFER_LEN];
+  char strrownum[20];
+  char *s;
+  int i, a;
+  dbref thing;
+  int dofieldnames = SW_ISSET(sw, SWITCH_COLNAMES);
+  int donotify = SW_ISSET(sw, SWITCH_NOTIFY);
+
+  /* Find and fetch the attribute, first. */
+  strncpy(tbuf, arg_left, BUFFER_LEN);
+
+  s = strchr(tbuf, '/');
+  if (!s) {
+    notify(player, T("I need to know what attribute to trigger."));
+    return;
+  }
+  *(s++) = '\0';
+  upcasestr(s);
+
+  thing = noisy_match_result(player, tbuf, NOTYPE, MAT_EVERYTHING);
+
+  if (thing == NOTHING) {
+    return;
+  }
+
+  if (!controls(player, thing) && !(Owns(player, thing) && LinkOk(thing))) {
+    notify(player, T("Permission denied."));
+    return;
+  }
+
+  if (God(thing) && !God(player)) {
+    notify(player, T("You can't trigger God!"));
+    return;
+  }
+
+  for (a = 0; a < 10; a++) {
+    cells[a] = NULL;
+    names[a] = NULL;
+  }
+
+  /* Do the query. */
+  qres = sql_query(arg_right, &affected_rows);
+
+  if (!qres) {
+    if (affected_rows >= 0) {
+      notify_format(player, T("SQL: %d rows affected."), affected_rows);
+    } else if (!sql_connected()) {
+      notify(player, T("No SQL database connection."));
+    } else {
+      notify_format(player, T("SQL: Error: %s"), sql_error());
+    }
+    return;
+  }
+
+  /* Get results. A silent query (INSERT, UPDATE, etc.) will return NULL */
+  switch (sql_platform()) {
+#ifdef HAVE_MYSQL
+  case SQL_PLATFORM_MYSQL:
+    affected_rows = mysql_affected_rows(mysql_connp);
+    numfields = mysql_num_fields(qres);
+    numrows = INT_MAX;          /* Using mysql_use_result() doesn't know the number
+                                   of rows ahead of time. */
+    fields = mysql_fetch_fields(qres);
+    break;
+#endif
+#ifdef HAVE_POSTGRESQL
+  case SQL_PLATFORM_POSTGRESQL:
+    numfields = PQnfields(qres);
+    numrows = PQntuples(qres);
+    break;
+#endif
+#ifdef HAVE_SQLITE3
+  case SQL_PLATFORM_SQLITE3:
+    numfields = sqlite3_column_count(qres);
+    numrows = INT_MAX;
+    break;
+#endif
+  default:
+    goto finished;
+  }
+
+  for (rownum = 0; rownum < numrows; rownum++) {
+#ifdef HAVE_MYSQL
+    MYSQL_ROW row_p = NULL;
+    if (sql_platform() == SQL_PLATFORM_MYSQL) {
+      row_p = mysql_fetch_row(qres);
+      if (!row_p)
+        break;
+    }
+#endif
+#ifdef HAVE_SQLITE3
+    if (sql_platform() == SQL_PLATFORM_SQLITE3) {
+      int retcode = sqlite3_step(qres);
+      if (retcode == SQLITE_DONE)
+        break;
+      else if (retcode != SQLITE_ROW) {
+        notify_format(player, T("SQL: Error: %s"), sql_error());
+        break;
+      }
+    }
+#endif
+
+    if (numfields > 0) {
+      for (i = 0; i < numfields && i < 9; i++) {
+        switch (sql_platform()) {
+#ifdef HAVE_MYSQL
+        case SQL_PLATFORM_MYSQL:
+          cells[i + 1] = row_p[i];
+          names[i + 1] = fields[i].name;
+          break;
+#endif
+#ifdef HAVE_POSTGRESQL
+        case SQL_PLATFORM_POSTGRESQL:
+          cells[i + 1] = PQgetvalue(qres, rownum, i);
+          names[i + 1] = PQfname(qres, i);
+          break;
+#endif
+#ifdef HAVE_SQLITE3
+        case SQL_PLATFORM_SQLITE3:
+          cells[i + 1] = (char *) sqlite3_column_text(qres, i);
+          names[i + 1] = (char *) sqlite3_column_name(qres, i);
+          break;
+#endif
+        default:
+          /* Not reached, shuts up compiler */
+          break;
+        }
+      }
+
+      if ((rownum == 0) && dofieldnames) {
+        /* Queue 0: <names> */
+        snprintf(strrownum, 20, "%d", 0);
+        names[0] = strrownum;
+        for (a = 0; a < 10; a++) {
+          global_eval_context.wnxt[a] = names[a];
+        }
+        queue_attribute(thing, s, player);
+      }
+
+      /* Queue the rest. */
+      snprintf(strrownum, 20, "%d", rownum + 1);
+      cells[0] = strrownum;
+      for (a = 0; a < 10; a++) {
+        global_eval_context.wnxt[a] = cells[a];
+      }
+      queue_attribute(thing, s, player);
+      /* Queue rownum: <names> */
+    } else {
+      /* What to do if there are no fields? This should be an error?. */
+      /* notify_format(player, T("Row %d: NULL"), rownum + 1); */
+    }
+  }
+  if (donotify) {
+    parse_que(player, "@notify me", cause, NULL);
+  }
+
+finished:
+  free_sql_query(qres);
+}
+
 
 COMMAND(cmd_sql)
 {
@@ -795,8 +968,9 @@
   /* If we are already connected, drop and retry the connection, in
    * case for some reason the server went away.
    */
-  if (sql_connected())
-    sql_shutdown();
+  if (penn_mysql_sql_connected()) {
+    penn_mysql_sql_shutdown();
+  }
 
   /* Parse SQL_HOST into sql_host and sql_port */
   mush_strncpy(sql_host, SQL_HOST, BUFFER_LEN);
@@ -817,13 +991,20 @@
         (mysql_connp, sql_host, SQL_USER, SQL_PASS, SQL_DB, sql_port, 0, 0)) {
       do_rawlog(LT_ERR, "Failed mysql connection: %s\n",
                 mysql_error(mysql_connp));
-      sql_shutdown();
+      queue_event(SYSEVENT, "SQL`CONNECTFAIL", "%s,%s",
+                  "mysql", mysql_error(mysql_connp));
+      penn_mysql_sql_shutdown();
       sleep(1);
     }
     retries--;
   }
 
-  return sql_connected();
+  if (penn_mysql_sql_connected()) {
+    queue_event(SYSEVENT, "SQL`CONNECT", "%s", "mysql");
+    last_retry = 0;
+  }
+
+  return penn_mysql_sql_connected();
 }
 
 static MYSQL_RES *
@@ -842,9 +1023,9 @@
   /* If we have no connection, and we don't have auto-reconnect on
    * (or we try to auto-reconnect and we fail), return NULL.
    */
-  if (!sql_connected()) {
-    sql_init();
-    if (!sql_connected()) {
+  if (!penn_mysql_sql_connected()) {
+    penn_mysql_sql_init();
+    if (!penn_mysql_sql_connected()) {
       return NULL;
     }
   }
@@ -852,11 +1033,16 @@
   /* Send the query. If it returns non-zero, we have an error. */
   fail = mysql_real_query(mysql_connp, q_string, strlen(q_string));
   if (fail && (mysql_errno(mysql_connp) == CR_SERVER_GONE_ERROR)) {
+    if (mysql_connp) {
+      queue_event(SYSEVENT, "SQL`DISCONNECT", "%s,%s",
+                  "mysql", mysql_error(mysql_connp));
+    }
     /* If it's CR_SERVER_GONE_ERROR, the server went away.
      * Try reconnecting. */
-    sql_init();
-    if (mysql_connp)
+    penn_mysql_sql_init();
+    if (mysql_connp) {
       fail = mysql_real_query(mysql_connp, q_string, strlen(q_string));
+    }
   }
   /* If we still fail, it's an error. */
   if (fail) {
@@ -892,7 +1078,7 @@
 static void
 penn_pg_sql_shutdown(void)
 {
-  if (!sql_connected())
+  if (!penn_pg_sql_connected())
     return;
   PQfinish(postgres_connp);
   postgres_connp = NULL;
@@ -923,8 +1109,9 @@
   /* If we are already connected, drop and retry the connection, in
    * case for some reason the server went away.
    */
-  if (sql_connected())
-    sql_shutdown();
+  if (penn_pg_sql_connected()) {
+    penn_pg_sql_shutdown();
+  }
 
   /* Parse SQL_HOST into sql_host and sql_port */
   mush_strncpy(sql_host, SQL_HOST, BUFFER_LEN);
@@ -945,13 +1132,20 @@
     if (PQstatus(postgres_connp) != CONNECTION_OK) {
       do_rawlog(LT_ERR, "Failed postgresql connection to %s: %s\n",
                 PQdb(postgres_connp), PQerrorMessage(postgres_connp));
-      sql_shutdown();
+      queue_event(SYSEVENT, "SQL`CONNECTFAIL", "%s,%s",
+                  "postgresql", PQerrorMessage(postgres_connp));
+      penn_pg_sql_shutdown();
       sleep(1);
     }
     retries--;
   }
 
-  return sql_connected();
+  if (penn_pg_sql_connected()) {
+    queue_event(SYSEVENT, "SQL`CONNECT", "%s", "postgresql");
+    last_retry = 0;
+  }
+
+  return penn_pg_sql_connected();
 }
 
 static PGresult *
@@ -970,8 +1164,8 @@
   /* If we have no connection, and we don't have auto-reconnect on
    * (or we try to auto-reconnect and we fail), return NULL.
    */
-  if (!sql_connected()) {
-    sql_init();
+  if (!penn_pg_sql_connected()) {
+    penn_pg_sql_init();
     if (!sql_connected()) {
       return NULL;
     }
@@ -982,8 +1176,12 @@
   if (!qres || (PQresultStatus(qres) != PGRES_COMMAND_OK &&
                 PQresultStatus(qres) != PGRES_TUPLES_OK)) {
     /* Serious error, try one more time */
-    sql_init();
-    if (sql_connected())
+    if (postgres_connp) {
+      queue_event(SYSEVENT, "SQL`DISCONNECT", "%s,%s",
+                  "postgresql", PQerrorMessage(postgres_connp));
+    }
+    penn_pg_sql_init();
+    if (penn_pg_sql_connected())
       qres = PQexec(postgres_connp, q_string);
     if (!qres || (PQresultStatus(qres) != PGRES_COMMAND_OK &&
                   PQresultStatus(qres) != PGRES_TUPLES_OK)) {
@@ -1015,13 +1213,16 @@
   sqlite3_connp = NULL;
   if (sqlite3_open(SQL_DB, &sqlite3_connp) != SQLITE_OK) {
     do_rawlog(LT_ERR, "sqlite3: Failed to open %s: %s", SQL_DB, sql_error());
+    queue_event(SYSEVENT, "SQL`CONNECTFAIL", "%s,%s", "sqlite3", sql_error());
     if (sqlite3_connp) {
       sqlite3_close(sqlite3_connp);
       sqlite3_connp = NULL;
     }
     return 0;
-  } else
+  } else {
+    queue_event(SYSEVENT, "SQL`CONNECT", "%s", "sqlite3");
     return 1;
+  }
 }
 
 static void
@@ -1044,9 +1245,9 @@
   const char *eoq = NULL;
   sqlite3_stmt *statement = NULL;
 
-  if (!sql_connected()) {
-    sql_init();
-    if (!sql_connected())
+  if (!penn_sqlite3_sql_connected()) {
+    penn_sqlite3_sql_init();
+    if (!penn_sqlite3_sql_connected())
       return NULL;
   }
 
Index: src/utils.c
===================================================================
--- src/utils.c	(.../184p2)	(revision 828)
+++ src/utils.c	(.../184p3)	(revision 828)
@@ -216,9 +216,10 @@
   }
 
   /* DEBUG attributes */
-  if (AF_Debug(attrib)) {
+  if (AF_NoDebug(attrib))
+    ufun->pe_flags |= PE_NODEBUG;       /* No_Debug overrides Debug */
+  else if (AF_Debug(attrib))
     ufun->pe_flags |= PE_DEBUG;
-  }
 
   /* Populate the ufun object */
   mush_strncpy(ufun->contents, atr_value(attrib), BUFFER_LEN);
Index: src/extchat.c
===================================================================
--- src/extchat.c	(.../184p2)	(revision 828)
+++ src/extchat.c	(.../184p3)	(revision 828)
@@ -370,7 +370,7 @@
     mush_panic("Couldn't allocate memory in new_user in extchat.c");
   CUdbref(u) = who;
   CUtype(u) = CU_DEFAULT_FLAGS;
-  u->title[0] = '\0';
+  CUtitle(u) = NULL;
   CUnext(u) = NULL;
   return u;
 }
@@ -492,13 +492,18 @@
   int i, num = 0;
   CHANUSER *user;
   dbref player;
+  char title[BUFFER_LEN];
   for (i = 0; i < ChanNumUsers(ch); i++) {
     player = getref(fp);
     /* Don't bother if the player isn't a valid dbref or the wrong type */
     if (GoodObject(player) && Chan_Ok_Type(ch, player)) {
       user = new_user(player, ChanUsers(ch));
       CUtype(user) = getref(fp);
-      strcpy(CUtitle(user), getstring_noalloc(fp));
+      strncpy(title, getstring_noalloc(fp), BUFFER_LEN - 1);
+      if (*title)
+        CUtitle(user) = mush_strdup(title, "chan_user.title");
+      else
+        CUtitle(user) = NULL;
       CUnext(user) = NULL;
       if (insert_user(user, ch))
         num++;
@@ -529,7 +534,10 @@
       db_read_this_labeled_int(fp, "flags", &n);
       CUtype(user) = n;
       db_read_this_labeled_string(fp, "title", &tmp);
-      mush_strncpy(CUtitle(user), tmp, CU_TITLE_LEN);
+      if (tmp && *tmp)
+        CUtitle(user) = mush_strdup(tmp, "chan_user.title");
+      else
+        CUtitle(user) = NULL;
       CUnext(user) = NULL;
       if (insert_user(user, ch))
         num++;
@@ -859,7 +867,10 @@
 {
   db_write_labeled_dbref(fp, "   dbref", CUdbref(user));
   db_write_labeled_int(fp, "    flags", CUtype(user));
-  db_write_labeled_string(fp, "    title", CUtitle(user));
+  if (CUtitle(user))
+    db_write_labeled_string(fp, "    title", CUtitle(user));
+  else
+    db_write_labeled_string(fp, "    title", "");
   return 1;
 }
 
@@ -1280,7 +1291,6 @@
     }
     return;
   } else if (!strcasecmp("off", com) || !strcasecmp("leave", com)) {
-    char title[CU_TITLE_LEN];
     /* You must control either the victim or the channel */
     if (!controls(player, victim) && !Chan_Can_Modify(chan, player)) {
       notify(player, T("Invalid target."));
@@ -1291,7 +1301,6 @@
       return;
     }
     u = onchannel(victim, chan);
-    strcpy(title, (u && CUtitle(u)) ? CUtitle(u) : "");
     if (remove_user(u, chan)) {
       if (!Channel_Quiet(chan) && !DarkLegal(victim)) {
         channel_send(chan, victim,
@@ -1383,7 +1392,6 @@
 {
   CHAN *chan = NULL;
   CHANUSER *u;
-  char title[CU_TITLE_LEN];
 
   if (Guest(player)) {
     notify(player, T("Guests are not allowed to leave channels."));
@@ -1406,7 +1414,6 @@
     break;
   }
   u = onchannel(player, chan);
-  strcpy(title, (u && CUtitle(u)) ? CUtitle(u) : "");
   if (remove_user(u, chan)) {
     if (!Channel_Quiet(chan) && !DarkLegal(player))
       channel_send(chan, player,
@@ -1902,7 +1909,7 @@
 
   if (!IsPlayer(player) && flag == CU_COMBINE) {
     notify(player, T("Only players can use that option."));
-	   return;
+    return;
   }
 
   if (!name || !*name) {
@@ -2026,7 +2033,8 @@
         CUtype(u) &= ~CU_COMBINE;
         if (!silent)
           notify_format(player,
-                        T("Connect messages on channel <%s> will no longer be combined with others."),
+                        T
+                        ("Connect messages on channel <%s> will no longer be combined with others."),
                         ChanName(c));
       }
       break;
@@ -2064,7 +2072,7 @@
   }
 
   if (!rhs_present) {
-    if (strlen(CUtitle(u)) == 0)
+    if (!CUtitle(u) || !*CUtitle(u))
       notify_format(player, T("You have no title set on <%s>."), ChanName(c));
     else
       notify_format(player, T("Your title on <%s> is '%s'."), ChanName(c),
@@ -2072,15 +2080,23 @@
     return;
   }
 
-  if (!title)
-    title = (const char *) "";
+  if (!title) {
+    if (CUtitle(u)) {
+      mush_free(CUtitle(u), "chan_user.title");
+      CUtitle(u) = NULL;
+    }
+    if (!Quiet(player))
+      notify_format(player, T("Title cleared for %schannel <%s>."),
+                    Channel_NoTitles(c) ? "(NoTitles) " : "", ChanName(c));
+    return;
+  }
 
-  if (strlen(title) >= CU_TITLE_LEN) {
+  if (ansi_strlen(title) > CU_TITLE_LEN) {
     notify(player, T("Title too long."));
     return;
   }
-  /* Stomp newlines and other weird whitespace */
-  for (scan = title; *scan; scan++) {
+  WALK_ANSI_STRING(scan, title) {
+    /* Stomp newlines and other weird whitespace */
     if ((isspace((unsigned char) *scan) && (*scan != ' '))
         || (*scan == BEEP_CHAR)) {
       notify(player, T("Invalid character in title."));
@@ -2088,10 +2104,12 @@
     }
   }
 
-  strcpy(CUtitle(u), title);
+  if (CUtitle(u))
+    mush_free(CUtitle(u), "chan_user.title");
+  CUtitle(u) = mush_strdup(title, "chan_user.title");
+
   if (!Quiet(player))
-    notify_format(player, T("Title %s for %schannel <%s>."),
-                  *title ? T("set") : T("cleared"),
+    notify_format(player, T("Title set for %schannel <%s>."),
                   Channel_NoTitles(c) ? "(NoTitles) " : "", ChanName(c));
   return;
 }
@@ -2481,6 +2499,29 @@
 
 }
 
+FUNCTION(fun_cmogrifier)
+{
+  /* Return the dbref of the mogrifier of a channel. */
+  CHAN *c;
+
+  if (!args[0] || !*args[0]) {
+    safe_str(T("#-1 NO CHANNEL GIVEN"), buff, bp);
+    return;
+  }
+  switch (find_channel(args[0], &c, executor)) {
+  case CMATCH_NONE:
+    safe_str(T("#-1 NO SUCH CHANNEL"), buff, bp);
+    break;
+  case CMATCH_AMBIG:
+    safe_str(T("#-1 AMBIGUOUS CHANNEL NAME"), buff, bp);
+    break;
+  default:
+    safe_dbref(ChanMogrifier(c), buff, bp);
+  }
+
+}
+
+
 /* Remove all players from a channel, notifying them. This is the
  * utility routine for handling it. The command @channel/wipe
  * calls do_chan_wipe, below
@@ -3079,8 +3120,10 @@
   CHAN *c;
   CHANUSER *up, *uv;
   char buff[BUFFER_LEN], *bp;
+  char buff2[BUFFER_LEN], *bp2;
   dbref viewer;
   bool shared = false;
+  int na_flags = NA_INTER_LOCK | NA_SPOOF | NA_INTER_PRESENCE;
 
   msglen = strlen(msg);
 
@@ -3089,10 +3132,9 @@
     up = onchannel(player, c);
     if (up) {
       if (!Channel_Quiet(c) && (Channel_Admin(c) || Channel_Wizard(c)
-            || (!Chanuser_Hide(up) && !Dark(player)))) {
+                                || (!Chanuser_Hide(up) && !Dark(player)))) {
         channel_send(c, player,
-                     CB_NOCOMBINE | CB_CHECKQUIET | CB_PRESENCE | CB_POSE,
-                     msg);
+                     CB_NOCOMBINE | CB_CHECKQUIET | CB_PRESENCE | CB_POSE, msg);
       }
       if (ungag) {
         CUtype(up) &= ~CU_GAG;
@@ -3104,6 +3146,7 @@
     if (d->connected) {
       shared = false;
       bp = buff;
+      bp2 = buff2;
 
       for (c = channels; c; c = c->next) {
         up = onchannel(player, c);
@@ -3116,37 +3159,42 @@
               shared = true;
               safe_str(ChanName(c), buff, &bp);
               safe_strl(" | ", 3, buff, &bp);
+              safe_str(ChanName(c), buff2, &bp2);
+              safe_chr('|', buff2, &bp2);
             }
           }
         }
         if (up && ungag)
           CUtype(up) &= ~CU_GAG;
       }
-      
+
       bp -= 3;
-      *bp = '\0';   
+      *bp = '\0';
+      bp2--;
+      *bp2 = '\0';
 
       if (shared) {
-	char defmsg[BUFFER_LEN], *dmp;
-	char shrtmsg[BUFFER_LEN], *smp;
-	char *accname;
+        char defmsg[BUFFER_LEN], *dmp;
+        char shrtmsg[BUFFER_LEN], *smp;
+        char *accname;
 
-	dmp = defmsg;
-	smp = shrtmsg;
-	
-	accname = mush_strdup(accented_name(player), "chat_announce.name");
+        dmp = defmsg;
+        smp = shrtmsg;
+
+        accname = mush_strdup(accented_name(player), "chat_announce.name");
+
+        safe_format(shrtmsg, &smp, "%s %s", accname, msg);
+        *smp = '\0';
 
-	safe_format(shrtmsg, &smp, "%s %s", accname, msg);
-	*smp = '\0';
-          
         safe_format(defmsg, &dmp, "<%s> %s %s", buff, accname, msg);
         *dmp = '\0';
 
-	if (!vmessageformat(viewer, "CHATFORMAT", player, NA_INTER_PRESENCE, 6,
-			    "@", buff, shrtmsg, accname, "", defmsg)) 
-	  notify_anything(player, na_one, &viewer, ns_esnotify, NA_INTER_PRESENCE, defmsg);
-	
-	mush_free(accname, "chat_announce.name");
+        if (!vmessageformat(viewer, "CHATFORMAT", player, na_flags, 6,
+                            "@", buff2, shrtmsg, accname, "", defmsg))
+          notify_anything(player, na_one, &viewer, ns_esnotify, na_flags,
+                          defmsg);
+
+        mush_free(accname, "chat_announce.name");
       }
     }
   }
@@ -3450,21 +3498,18 @@
 
 COMMAND(cmd_cemit)
 {
-  int spflags = (!strcmp(cmd->name, "@NSCEMIT")
-                 && Can_Nspemit(player) ? PEMIT_SPOOF : 0);
+  int flags = SILENT_OR_NOISY(sw, !options.noisy_cemit);
+  if (!strcmp(cmd->name, "@NSCEMIT") && Can_Nspemit(player))
+    flags |= PEMIT_SPOOF;
+
   SPOOF(player, cause, sw);
-  if (SW_ISSET(sw, SWITCH_SILENT))
-    spflags |= PEMIT_SILENT;
-  else if (!SW_ISSET(sw, SWITCH_NOISY) && options.noisy_cemit == 0)
-    spflags |= PEMIT_SILENT;
-  do_cemit(player, arg_left, arg_right, spflags);
+
+  do_cemit(player, arg_left, arg_right, flags);
 }
 
 COMMAND(cmd_channel)
 {
-  if (switches)
-    do_channel(player, arg_left, args_right[1], switches);
-  else if (SW_ISSET(sw, SWITCH_LIST))
+  if (SW_ISSET(sw, SWITCH_LIST))
     do_channel_list(player, arg_left);
   else if (SW_ISSET(sw, SWITCH_ADD))
     do_chan_admin(player, arg_left, args_right[1], 0);
@@ -3510,6 +3555,12 @@
     do_chan_what(player, arg_left);
   else if (SW_ISSET(sw, SWITCH_BUFFER))
     do_chan_buffer(player, arg_left, args_right[1]);
+  else if (SW_ISSET(sw, SWITCH_ON) || SW_ISSET(sw, SWITCH_JOIN))
+    do_channel(player, arg_left, args_right[1], "ON");
+  else if (SW_ISSET(sw, SWITCH_OFF) || SW_ISSET(sw, SWITCH_LEAVE))
+    do_channel(player, arg_left, args_right[1], "OFF");
+  else if (SW_ISSET(sw, SWITCH_WHO))
+    do_channel(player, arg_left, args_right[1], "WHO");
   else
     do_channel(player, arg_left, NULL, args_right[1]);
 }
Index: src/Makefile.in
===================================================================
--- src/Makefile.in	(.../184p2)	(revision 828)
+++ src/Makefile.in	(.../184p3)	(revision 828)
@@ -221,6 +221,7 @@
 access.o: ../hdrs/match.h
 access.o: ../hdrs/parse.h
 access.o: ../hdrs/log.h
+access.o: ../hdrs/bufferq.h
 atr_tab.o: ../config.h
 atr_tab.o: ../hdrs/conf.h
 atr_tab.o: ../hdrs/copyrite.h
@@ -242,6 +243,7 @@
 atr_tab.o: ../hdrs/privtab.h
 atr_tab.o: ../hdrs/mymalloc.h
 atr_tab.o: ../hdrs/log.h
+atr_tab.o: ../hdrs/bufferq.h
 atr_tab.o: ../hdrs/parse.h
 atr_tab.o: ../hdrs/ansi.h
 attrib.o: ../hdrs/copyrite.h
@@ -269,6 +271,7 @@
 attrib.o: ../hdrs/lock.h
 attrib.o: ../hdrs/boolexp.h
 attrib.o: ../hdrs/log.h
+attrib.o: ../hdrs/bufferq.h
 attrib.o: ../hdrs/sort.h
 boolexp.o: ../hdrs/copyrite.h
 boolexp.o: ../config.h
@@ -292,8 +295,8 @@
 boolexp.o: ../hdrs/parse.h
 boolexp.o: ../hdrs/attrib.h
 boolexp.o: ../hdrs/log.h
-boolexp.o: ../hdrs/extchat.h
 boolexp.o: ../hdrs/bufferq.h
+boolexp.o: ../hdrs/extchat.h
 boolexp.o: ../hdrs/strtree.h
 boolexp.o: ../hdrs/mymalloc.h
 bsd.o: ../hdrs/copyrite.h
@@ -328,6 +331,7 @@
 bsd.o: ../hdrs/lookup.h
 bsd.o: ../hdrs/strtree.h
 bsd.o: ../hdrs/log.h
+bsd.o: ../hdrs/bufferq.h
 bsd.o: ../hdrs/myssl.h
 bsd.o: ../hdrs/mymalloc.h
 bsd.o: ../hdrs/extmail.h
@@ -374,6 +378,7 @@
 chunk.o: ../hdrs/switches.h
 chunk.o: ../hdrs/intrface.h
 chunk.o: ../hdrs/log.h
+chunk.o: ../hdrs/bufferq.h
 chunk.o: ../hdrs/mymalloc.h
 cmdlocal.o: ../hdrs/copyrite.h
 cmdlocal.o: ../config.h
@@ -426,6 +431,7 @@
 cmds.o: ../hdrs/command.h
 cmds.o: ../hdrs/switches.h
 cmds.o: ../hdrs/log.h
+cmds.o: ../hdrs/bufferq.h
 command.o: ../hdrs/copyrite.h
 command.o: ../config.h
 command.o: ../hdrs/conf.h
@@ -456,6 +462,7 @@
 command.o: ../hdrs/switches.h
 command.o: ../hdrs/mymalloc.h
 command.o: ../hdrs/log.h
+command.o: ../hdrs/bufferq.h
 command.o: ../hdrs/sort.h
 command.o: ../hdrs/cmds.h
 command.o: switchinc.c
@@ -464,6 +471,7 @@
 compress.o: ../hdrs/mushtype.h
 compress.o: ../hdrs/copyrite.h
 compress.o: ../hdrs/log.h
+compress.o: ../hdrs/bufferq.h
 compress.o: comp_h.c
 compress.o: ../hdrs/conf.h
 compress.o: ../hdrs/htab.h
@@ -501,6 +509,7 @@
 conf.o: ../hdrs/boolexp.h
 conf.o: ../hdrs/switches.h
 conf.o: ../hdrs/log.h
+conf.o: ../hdrs/bufferq.h
 conf.o: ../hdrs/game.h
 conf.o: ../hdrs/attrib.h
 conf.o: ../hdrs/help.h
@@ -533,6 +542,7 @@
 cque.o: ../hdrs/function.h
 cque.o: ../hdrs/case.h
 cque.o: ../hdrs/log.h
+cque.o: ../hdrs/bufferq.h
 cque.o: ../hdrs/intmap.h
 create.o: ../hdrs/copyrite.h
 create.o: ../config.h
@@ -583,11 +593,11 @@
 db.o: ../hdrs/lock.h
 db.o: ../hdrs/boolexp.h
 db.o: ../hdrs/log.h
+db.o: ../hdrs/bufferq.h
 db.o: ../hdrs/strtree.h
 db.o: ../hdrs/parse.h
 db.o: ../hdrs/privtab.h
 db.o: ../hdrs/extchat.h
-db.o: ../hdrs/bufferq.h
 db.o: ../hdrs/extmail.h
 db.o: ../hdrs/ansi.h
 destroy.o: ../config.h
@@ -608,6 +618,7 @@
 destroy.o: ../confmagic.h
 destroy.o: ../hdrs/mypcre.h
 destroy.o: ../hdrs/log.h
+destroy.o: ../hdrs/bufferq.h
 destroy.o: ../hdrs/game.h
 destroy.o: ../hdrs/extmail.h
 destroy.o: ../hdrs/malias.h
@@ -673,6 +684,7 @@
 extmail.o: ../hdrs/ansi.h
 extmail.o: ../hdrs/pueblo.h
 extmail.o: ../hdrs/log.h
+extmail.o: ../hdrs/bufferq.h
 extmail.o: ../hdrs/lock.h
 extmail.o: ../hdrs/boolexp.h
 extmail.o: ../hdrs/command.h
@@ -696,6 +708,7 @@
 filecopy.o: ../hdrs/mypcre.h
 filecopy.o: ../hdrs/mymalloc.h
 filecopy.o: ../hdrs/log.h
+filecopy.o: ../hdrs/bufferq.h
 flaglocal.o: ../hdrs/copyrite.h
 flaglocal.o: ../config.h
 flaglocal.o: ../hdrs/conf.h
@@ -738,6 +751,7 @@
 flags.o: ../hdrs/game.h
 flags.o: ../hdrs/lock.h
 flags.o: ../hdrs/log.h
+flags.o: ../hdrs/bufferq.h
 flags.o: ../hdrs/sort.h
 flags.o: ../hdrs/mymalloc.h
 flags.o: ../hdrs/oldflags.h
@@ -822,6 +836,7 @@
 fundb.o: ../hdrs/privtab.h
 fundb.o: ../hdrs/lock.h
 fundb.o: ../hdrs/log.h
+fundb.o: ../hdrs/bufferq.h
 fundb.o: ../hdrs/attrib.h
 fundb.o: ../hdrs/function.h
 funlist.o: ../hdrs/copyrite.h
@@ -960,6 +975,7 @@
 funtime.o: ../hdrs/mypcre.h
 funtime.o: ../hdrs/parse.h
 funtime.o: ../hdrs/log.h
+funtime.o: ../hdrs/bufferq.h
 funtime.o: ../hdrs/match.h
 funtime.o: ../hdrs/attrib.h
 funufun.o: ../hdrs/copyrite.h
@@ -1044,6 +1060,7 @@
 help.o: ../hdrs/switches.h
 help.o: ../hdrs/help.h
 help.o: ../hdrs/log.h
+help.o: ../hdrs/bufferq.h
 help.o: ../hdrs/ansi.h
 help.o: ../hdrs/parse.h
 help.o: ../hdrs/pueblo.h
@@ -1065,6 +1082,7 @@
 htab.o: ../confmagic.h
 htab.o: ../hdrs/mypcre.h
 htab.o: ../hdrs/log.h
+htab.o: ../hdrs/bufferq.h
 htab.o: ../hdrs/mymalloc.h
 ident.o: ../config.h
 ident.o: ../hdrs/conf.h
@@ -1125,6 +1143,7 @@
 local.o: ../hdrs/boolexp.h
 local.o: ../hdrs/switches.h
 local.o: ../hdrs/lock.h
+local.o: ../hdrs/game.h
 lock.o: ../hdrs/copyrite.h
 lock.o: ../config.h
 lock.o: ../hdrs/conf.h
@@ -1146,6 +1165,7 @@
 lock.o: ../hdrs/lock.h
 lock.o: ../hdrs/match.h
 lock.o: ../hdrs/log.h
+lock.o: ../hdrs/bufferq.h
 lock.o: ../hdrs/mymalloc.h
 lock.o: ../hdrs/strtree.h
 lock.o: ../hdrs/privtab.h
@@ -1221,6 +1241,7 @@
 malias.o: ../hdrs/mymalloc.h
 malias.o: ../hdrs/pueblo.h
 malias.o: ../hdrs/log.h
+malias.o: ../hdrs/bufferq.h
 markup.o: ../config.h
 markup.o: ../hdrs/copyrite.h
 markup.o: ../hdrs/conf.h
@@ -1243,6 +1264,7 @@
 markup.o: ../hdrs/ansi.h
 markup.o: ../hdrs/mymalloc.h
 markup.o: ../hdrs/log.h
+markup.o: ../hdrs/bufferq.h
 markup.o: ../hdrs/game.h
 markup.o: htmltab.c
 match.o: ../hdrs/copyrite.h
@@ -1283,6 +1305,7 @@
 memcheck.o: ../hdrs/mypcre.h
 memcheck.o: ../hdrs/mymalloc.h
 memcheck.o: ../hdrs/log.h
+memcheck.o: ../hdrs/bufferq.h
 move.o: ../hdrs/copyrite.h
 move.o: ../config.h
 move.o: ../hdrs/conf.h
@@ -1305,6 +1328,7 @@
 move.o: ../hdrs/boolexp.h
 move.o: ../hdrs/parse.h
 move.o: ../hdrs/log.h
+move.o: ../hdrs/bufferq.h
 move.o: ../hdrs/command.h
 move.o: ../hdrs/switches.h
 move.o: ../hdrs/cmds.h
@@ -1329,6 +1353,7 @@
 mymalloc.o: ../hdrs/dbio.h
 mymalloc.o: ../hdrs/chunk.h
 mymalloc.o: ../hdrs/log.h
+mymalloc.o: ../hdrs/bufferq.h
 mymalloc.o: ../hdrs/externs.h
 mymalloc.o: ../hdrs/compile.h
 mymalloc.o: ../confmagic.h
@@ -1390,6 +1415,7 @@
 myssl.o: ../hdrs/mypcre.h
 myssl.o: ../hdrs/myssl.h
 myssl.o: ../hdrs/log.h
+myssl.o: ../hdrs/bufferq.h
 myssl.o: ../hdrs/parse.h
 myssl.o: ../hdrs/SFMT.h
 notify.o: ../hdrs/copyrite.h
@@ -1421,9 +1447,9 @@
 notify.o: ../hdrs/ident.h
 notify.o: ../hdrs/strtree.h
 notify.o: ../hdrs/log.h
+notify.o: ../hdrs/bufferq.h
 notify.o: ../hdrs/mymalloc.h
 notify.o: ../hdrs/extchat.h
-notify.o: ../hdrs/bufferq.h
 notify.o: ../hdrs/extmail.h
 notify.o: ../hdrs/attrib.h
 notify.o: ../hdrs/game.h
@@ -1450,6 +1476,7 @@
 parse.o: ../hdrs/parse.h
 parse.o: ../hdrs/attrib.h
 parse.o: ../hdrs/log.h
+parse.o: ../hdrs/bufferq.h
 parse.o: ../hdrs/mymalloc.h
 pcre.o: ../config.h
 pcre.o: ../hdrs/mypcre.h
@@ -1473,6 +1500,7 @@
 player.o: ../hdrs/access.h
 player.o: ../hdrs/mymalloc.h
 player.o: ../hdrs/log.h
+player.o: ../hdrs/bufferq.h
 player.o: ../hdrs/lock.h
 player.o: ../hdrs/boolexp.h
 player.o: ../hdrs/parse.h
@@ -1495,6 +1523,7 @@
 plyrlist.o: ../hdrs/mypcre.h
 plyrlist.o: ../hdrs/attrib.h
 plyrlist.o: ../hdrs/mymalloc.h
+plyrlist.o: ../hdrs/parse.h
 predicat.o: ../hdrs/copyrite.h
 predicat.o: ../config.h
 predicat.o: ../hdrs/conf.h
@@ -1557,6 +1586,7 @@
 info_master.o: ../hdrs/ident.h
 info_master.o: ../hdrs/lookup.h
 info_master.o: ../hdrs/log.h
+info_master.o: ../hdrs/bufferq.h
 ptab.o: ../config.h
 ptab.o: ../hdrs/copyrite.h
 ptab.o: ../hdrs/conf.h
@@ -1593,6 +1623,7 @@
 rob.o: ../hdrs/match.h
 rob.o: ../hdrs/parse.h
 rob.o: ../hdrs/log.h
+rob.o: ../hdrs/bufferq.h
 rob.o: ../hdrs/lock.h
 rob.o: ../hdrs/boolexp.h
 rob.o: ../hdrs/game.h
@@ -1624,6 +1655,7 @@
 set.o: ../hdrs/mymalloc.h
 set.o: ../hdrs/lock.h
 set.o: ../hdrs/log.h
+set.o: ../hdrs/bufferq.h
 set.o: ../hdrs/game.h
 SFMT.o: ../config.h
 SFMT.o: ../hdrs/SFMT.h
@@ -1690,6 +1722,7 @@
 speech.o: ../hdrs/lock.h
 speech.o: ../hdrs/boolexp.h
 speech.o: ../hdrs/log.h
+speech.o: ../hdrs/bufferq.h
 speech.o: ../hdrs/match.h
 speech.o: ../hdrs/attrib.h
 speech.o: ../hdrs/parse.h
@@ -1712,12 +1745,14 @@
 sql.o: ../confmagic.h
 sql.o: ../hdrs/mypcre.h
 sql.o: ../hdrs/log.h
+sql.o: ../hdrs/bufferq.h
 sql.o: ../hdrs/parse.h
 sql.o: ../hdrs/command.h
 sql.o: ../hdrs/boolexp.h
 sql.o: ../hdrs/switches.h
 sql.o: ../hdrs/function.h
 sql.o: ../hdrs/ansi.h
+sql.o: ../hdrs/match.h
 strdup.o: ../config.h
 strdup.o: ../hdrs/conf.h
 strdup.o: ../hdrs/copyrite.h
@@ -1765,6 +1800,7 @@
 strutil.o: ../hdrs/ansi.h
 strutil.o: ../hdrs/mymalloc.h
 strutil.o: ../hdrs/log.h
+strutil.o: ../hdrs/bufferq.h
 timer.o: ../hdrs/copyrite.h
 timer.o: ../config.h
 timer.o: ../hdrs/conf.h
@@ -1787,6 +1823,7 @@
 timer.o: ../hdrs/match.h
 timer.o: ../hdrs/access.h
 timer.o: ../hdrs/log.h
+timer.o: ../hdrs/bufferq.h
 timer.o: ../hdrs/game.h
 timer.o: ../hdrs/help.h
 timer.o: ../hdrs/parse.h
@@ -1833,6 +1870,7 @@
 utils.o: ../hdrs/ansi.h
 utils.o: ../hdrs/mymalloc.h
 utils.o: ../hdrs/log.h
+utils.o: ../hdrs/bufferq.h
 utils.o: ../hdrs/attrib.h
 utils.o: ../hdrs/parse.h
 utils.o: ../hdrs/lock.h
@@ -1922,6 +1960,7 @@
 wiz.o: ../hdrs/lock.h
 wiz.o: ../hdrs/boolexp.h
 wiz.o: ../hdrs/log.h
+wiz.o: ../hdrs/bufferq.h
 wiz.o: ../hdrs/game.h
 wiz.o: ../hdrs/command.h
 wiz.o: ../hdrs/switches.h
Index: src/wiz.c
===================================================================
--- src/wiz.c	(.../184p2)	(revision 828)
+++ src/wiz.c	(.../184p3)	(revision 828)
@@ -91,6 +91,11 @@
                       const char **args, dbref **result, PE_Info *pe_info);
 static int fill_search_spec(dbref player, const char *owner, int nargs,
                             const char **args, struct search_spec *spec);
+static void
+
+sitelock_player(dbref player, const char *name, dbref who, uint32_t can,
+                uint32_t cant);
+
 
 #ifdef INFO_SLAVE
 void kill_info_slave(void);
@@ -126,7 +131,7 @@
     return NOTHING;
   }
 
-  player = create_player(player_name, player_password, "None", "None");
+  player = create_player(NULL, player_name, player_password, "None", "None");
   if (player == NOTHING) {
     notify_format(creator, T("Failure creating '%s' (bad name)"), player_name);
     return NOTHING;
@@ -139,6 +144,8 @@
   notify_format(creator, T("New player '%s' (#%d) created with password '%s'"),
                 player_name, player, player_password);
   do_log(LT_WIZ, creator, player, "Player creation");
+  queue_event(creator, "PLAYER`CREATE", "%s,%s,%s",
+              unparse_objid(player), Name(player), "pcreate");
   return player;
 }
 
@@ -388,10 +395,11 @@
      */
     if (player == victim) {
       if (command_check_byname(victim, "HOME"))
-        safe_tel(victim, HOME, silent);
+        safe_tel(victim, HOME, silent, player, "teleport");
       return;
-    } else
+    } else {
       destination = Home(victim);
+    }
   } else {
     destination = match_result(player, to, TYPE_PLAYER, MAT_EVERYTHING);
   }
@@ -463,7 +471,7 @@
       if (!silent && loc != Location(destination))
         did_it_with(victim, victim, NULL, NULL, "OXTPORT", NULL, NULL, loc,
                     player, NOTHING, NA_INTER_HEAR);
-      safe_tel(victim, Location(destination), silent);
+      safe_tel(victim, Location(destination), silent, player, "teleport");
       if (!silent && loc != Location(destination))
         did_it_with(victim, victim, "TPORT", NULL, "OTPORT", NULL, "ATPORT",
                     Location(destination), player, loc, NA_INTER_HEAR);
@@ -552,7 +560,7 @@
         if (!silent && loc != destination)
           did_it_with(victim, victim, NULL, NULL, "OXTPORT", NULL, NULL, loc,
                       player, NOTHING, NA_INTER_HEAR);
-        safe_tel(victim, destination, silent);
+        safe_tel(victim, destination, silent, player, "teleport");
         if (!silent && loc != destination)
           did_it_with(victim, victim, "TPORT", NULL, "OTPORT", NULL, "ATPORT",
                       destination, player, loc, NA_INTER_HEAR);
@@ -590,11 +598,13 @@
  * This implements @force.
  * \endverbatim
  * \param player the enactor.
+ * \param caller the caller.
  * \param what name of the object to force.
  * \param command command to force the object to run.
+ * \param inplace If true, use inplace_queue instead of parse_que
  */
 void
-do_force(dbref player, const char *what, char *command)
+do_force(dbref player, dbref caller, const char *what, char *command, int inplace)
 {
   dbref victim;
   int j;
@@ -619,12 +629,18 @@
     notify(player, T("You can't force God!"));
     return;
   }
-  /* force victim to do command */
+
+  /* Set up the stack */
   for (j = 0; j < 10; j++)
     global_eval_context.wnxt[j] = global_eval_context.wenv[j];
   for (j = 0; j < NUMQ; j++)
     global_eval_context.rnxt[j] = global_eval_context.renv[j];
-  parse_que(victim, command, player, NULL);
+
+  /* force victim to do command */
+  if (inplace)
+    inplace_queue_actionlist(victim, caller, player, command, NULL, QUEUE_RECURSE);
+  else
+    parse_que(victim, command, player, NULL);
 }
 
 /** Parse a force token command, but don't force with it.
@@ -833,7 +849,7 @@
       return;
     }
     d = port_desc(parse_integer(name));
-    if (!d || (!priv && d->player != player)) {
+    if (!d || (!priv && (!d->connected || d->player != player))) {
       if (priv)
         notify(player, T("There is noone connected on that descriptor."));
       else
@@ -870,7 +886,7 @@
       notify_format(player, T("You booted unconnected port %s!"), name);
     }
     do_log(LT_WIZ, player, victim, "*** BOOT ***");
-    boot_desc(d);
+    boot_desc(d, "boot");
     return;
   }
 
@@ -1449,6 +1465,41 @@
   return;
 }
 
+static void
+sitelock_player(dbref player, const char *name, dbref who, uint32_t can,
+                uint32_t cant)
+{
+  dbref target;
+  ATTR *a;
+  int attrcount = 0;
+
+
+  if ((target = noisy_match_result(player, name, TYPE_PLAYER,
+                                   MAT_ABSOLUTE | MAT_PMATCH | MAT_TYPE)) ==
+      NOTHING)
+    return;
+
+  a = atr_get(target, "LASTIP");
+  if (a && add_access_sitelock(player, atr_value(a), who, can, cant)) {
+    attrcount++;
+    do_log(LT_WIZ, player, NOTHING, "*** SITELOCK *** %s", atr_value(a));
+  }
+  a = atr_get(target, "LASTSITE");
+  if (a && add_access_sitelock(player, atr_value(a), who, can, cant)) {
+    attrcount++;
+    do_log(LT_WIZ, player, NOTHING, "*** SITELOCK *** %s", atr_value(a));
+  }
+  if (attrcount) {
+    write_access_file();
+    notify_format(player, T("Sitelocked %d known addresses for %s"), attrcount,
+                  Name(target));
+  } else {
+    notify_format(player, T("Unable to sitelock %s: No known ip/host to ban."),
+                  Name(target));
+  }
+
+}
+
 /** Modify access rules for a site.
  * \verbatim
  * This implements @sitelock.
@@ -1458,10 +1509,11 @@
  * \param opts access rules to apply.
  * \param who string containing dbref of player to whom rule applies.
  * \param type sitelock operation to do.
+ * \param psw was the /player switch given?
  */
 void
 do_sitelock(dbref player, const char *site, const char *opts, const char *who,
-            enum sitelock_type type)
+            enum sitelock_type type, int psw)
 {
   if (!Wizard(player)) {
     notify(player, T("Your delusions of grandeur have been noted."));
@@ -1487,7 +1539,10 @@
         return;
       }
     }
-
+    if (psw) {
+      sitelock_player(player, site, whod, can, cant);
+      return;
+    }
     if (add_access_sitelock(player, site, whod, can, cant)) {
       write_access_file();
       if (whod != AMBIGUOUS) {
@@ -1515,6 +1570,10 @@
       do_list_access(player);
       return;
     case SITELOCK_REGISTER:
+      if (psw) {
+        sitelock_player(player, site, AMBIGUOUS, ACS_REGISTER, ACS_CREATE);
+        return;
+      }
       if (add_access_sitelock
           (player, site, AMBIGUOUS, ACS_REGISTER, ACS_CREATE)) {
         write_access_file();
@@ -1523,6 +1582,10 @@
       }
       break;
     case SITELOCK_ADD:
+      if (psw) {
+        sitelock_player(player, site, AMBIGUOUS, 0, ACS_CREATE);
+        return;
+      }
       if (add_access_sitelock(player, site, AMBIGUOUS, 0, ACS_CREATE)) {
         write_access_file();
         notify_format(player, T("Site %s locked"), site);
@@ -1530,6 +1593,10 @@
       }
       break;
     case SITELOCK_BAN:
+      if (psw) {
+        sitelock_player(player, site, AMBIGUOUS, 0, ACS_DEFAULT);
+        return;
+      }
       if (add_access_sitelock(player, site, AMBIGUOUS, 0, ACS_DEFAULT)) {
         write_access_file();
         notify_format(player, T("Site %s banned"), site);
@@ -1552,8 +1619,21 @@
         break;
       }
     case SITELOCK_REMOVE:{
-        int n;
-        n = remove_access_sitelock(site);
+        int n = 0;
+        if (psw) {
+          ATTR *a;
+          dbref target;
+          if ((target = noisy_match_result(player, site, TYPE_PLAYER,
+                                           MAT_ABSOLUTE | MAT_PMATCH |
+                                           MAT_TYPE)) == NOTHING)
+            return;
+          if ((a = atr_get(target, "LASTIP")))
+            n += remove_access_sitelock(atr_value(a));
+          if ((a = atr_get(target, "LASTSITE")))
+            n += remove_access_sitelock(atr_value(a));
+        } else {
+          n = remove_access_sitelock(site);
+        }
         if (n > 0)
           write_access_file();
         notify_format(player, T("%d sitelocks removed."), n);
@@ -1787,11 +1867,12 @@
 
   /* set limits on who we search */
   if (!owner || !*owner)
-    spec->owner = (See_All(player) || Search_All(player)) ? ANY_OWNER : player;
+    spec->owner = (See_All(player)
+                   || Search_All(player)) ? ANY_OWNER : Owner(player);
   else if (strcasecmp(owner, "all") == 0)
     spec->owner = ANY_OWNER;    /* Will only show visual objects for mortals */
   else if (strcasecmp(owner, "me") == 0)
-    spec->owner = player;
+    spec->owner = Owner(player);
   else
     spec->owner = lookup_player(owner);
   if (spec->owner == NOTHING) {
@@ -2072,7 +2153,7 @@
       continue;
     if (spec.cmdstring[0] &&
         !atr_comm_match(n, player, '$', ':', spec.cmdstring, 1, 0,
-                        NULL, NULL, NULL))
+                        NULL, NULL, NULL, 0))
       continue;
     if (spec.listenstring[0]) {
       ret = 0;
@@ -2088,7 +2169,7 @@
       }
       if (!ret &&
           !atr_comm_match(n, player, '^', ':', spec.listenstring, 1, 0,
-                          NULL, NULL, NULL))
+                          NULL, NULL, NULL, 0))
         continue;
     }
     if (*spec.eval) {
Index: src/conf.c
===================================================================
--- src/conf.c	(.../184p2)	(revision 828)
+++ src/conf.c	(.../184p3)	(revision 828)
@@ -24,6 +24,7 @@
 #include <stdlib.h>
 #include <ctype.h>
 #include <errno.h>
+#include <float.h>
 
 #include "conf.h"
 #include "externs.h"
@@ -172,6 +173,8 @@
   ,
   {"ancestor_player", cf_dbref, &options.ancestor_player, 100000, 0, "db"}
   ,
+  {"event_handler", cf_dbref, &options.event_handler, 100000, 0, "db"}
+  ,
   {"mud_name", cf_str, options.mud_name, 128, 0, "net"}
   ,
   {"mud_url", cf_str, options.mud_url, 256, 0, "net"}
@@ -258,7 +261,8 @@
   ,
   {"only_ascii_in_names", cf_bool, &options.ascii_names, 2, 0, "cosmetic"}
   ,
-  {"float_precision", cf_int, &options.float_precision, 10000, 0, "cosmetic"}
+  {"float_precision", cf_int, &options.float_precision, DBL_DIG - 1, 0,
+   "cosmetic"}
   ,
   {"comma_exit_list", cf_bool, &options.comma_exit_list, 2, 0, "cosmetic"}
   ,
@@ -363,6 +367,8 @@
   ,
   {"noisy_cemit", cf_bool, &options.noisy_cemit, 2, 0, "chat"}
   ,
+  {"chan_title_len", cf_int, &options.chan_title_len, 250, 0, "chat"}
+  ,
   {"log_commands", cf_bool, &options.log_commands, 2, 0, "log"}
   ,
   {"log_forces", cf_bool, &options.log_forces, 2, 0, "log"}
@@ -1085,6 +1091,8 @@
     for (p = val; *p && !isspace((unsigned char) *p); p++) ;
     if (*p) {
       *p++ = '\0';
+      do_rawlog(LT_ERR, "CONFIG: Trying to hook command %s with options %s",
+                val, p);
       if (!cnf_hook_command(val, p)) {
         do_rawlog(LT_ERR, "CONFIG: Couldn't hook command %s with options %s",
                   val, p);
@@ -1273,6 +1281,7 @@
   options.noisy_cemit = 0;
   options.max_player_chans = 3;
   options.max_channels = 200;
+  options.chan_title_len = 80;
   strcpy(options.mail_db, "data/maildb");
   options.player_start = 0;
   options.master_room = 2;
@@ -1282,6 +1291,7 @@
   options.ancestor_exit = -1;
   options.ancestor_thing = -1;
   options.ancestor_player = -1;
+  options.event_handler = -1;
   options.connect_fail_limit = 10;
   options.idle_timeout = 0;
   options.unconnected_idle_timeout = 300;
@@ -1513,16 +1523,12 @@
       *q++ = '\0';              /* split off command */
     for (; *q && isspace((unsigned char) *q); q++)      /* skip spaces */
       ;
-    /* If the first character of the value is a #, and that is
-       followed by a number, treat it as a dbref instead of a
-       comment. */
-    if (*q == '#' && isdigit((unsigned char) *(q + 1))) {
-      for (s = q + 1; *s && (*s != '#'); s++)   /* look for a real comment */
-        ;
-    } else {
-      for (s = q; *s && (*s != '#'); s++)       /* look for comment */
-        ;
-    }
+    /* We define a comment as a # followed by something other than a
+     * digit, so as no to be confused with dbrefs.
+     * followed by a number, treat it as a dbref instead of a
+     * comment. */
+    for (s = q; *s && ((*s != '#') || isdigit((unsigned char) *(s + 1))); s++) ;
+
     if (*s)                     /* if found nuke it */
       *s = '\0';
     for (s = s - 1; (s >= q) && isspace((unsigned char) *s); s--)       /* smash trailing stuff */
Index: src/attrib.c
===================================================================
--- src/attrib.c	(.../184p2)	(revision 828)
+++ src/attrib.c	(.../184p3)	(revision 828)
@@ -1419,11 +1419,14 @@
 int
 atr_comm_match(dbref thing, dbref player, int type, int end, char const *str,
                int just_match, int check_locks,
-               char *atrname, char **abp, dbref *errobj)
+               char *atrname, char **abp, dbref *errobj, int inplace)
 {
   uint32_t flag_mask;
   ATTR *ptr;
   int parent_depth;
+  char *args[10];
+  char *rnull[NUMQ];
+  int i;
   char tbuf1[BUFFER_LEN];
   char tbuf2[BUFFER_LEN];
   char *s;
@@ -1443,6 +1446,10 @@
                       || (type == '$' && NoCommand(thing))))
     return 0;
 
+  for (i = 0; i < NUMQ; i++) {
+    rnull[i] = NULL;
+  }
+
   if (type == '$') {
     flag_mask = AF_COMMAND;
     parent_depth = GoodObject(Parent(thing));
@@ -1511,8 +1518,7 @@
 
     match_found = 0;
     if (AF_Regexp(ptr)) {
-      if (regexp_match_case_r(tbuf2 + 1, str, AF_Case(ptr),
-                              global_eval_context.wnxt, 10,
+      if (regexp_match_case_r(tbuf2 + 1, str, AF_Case(ptr), args, 10,
                               match_space, match_space_len)) {
         match_found = 1;
         match++;
@@ -1522,8 +1528,7 @@
         match_found = 1;
         match++;
         if (!just_match)
-          wild_match_case_r(tbuf2 + 1, str, AF_Case(ptr),
-                            global_eval_context.wnxt, 10,
+          wild_match_case_r(tbuf2 + 1, str, AF_Case(ptr), args, 10,
                             match_space, match_space_len);
       }
     }
@@ -1551,8 +1556,16 @@
         safe_chr('/', atrname, abp);
         safe_str(AL_NAME(ptr), atrname, abp);
       }
-      if (!just_match)
-        parse_que(thing, s, player, NULL);
+      if (!just_match) {
+        if (inplace) {
+          insert_que(thing, s, player, player, NULL, args, rnull, QUEUE_RECURSE);
+        } else {
+          for (i = 0; i < 10; i++) {
+            global_eval_context.wnxt[i] = args[i];
+          }
+          parse_que(thing, s, player, NULL);
+        }
+      }
     }
   }
 
@@ -1633,8 +1646,7 @@
 
       match_found = 0;
       if (AF_Regexp(ptr)) {
-        if (regexp_match_case_r(tbuf2 + 1, str, AF_Case(ptr),
-                                global_eval_context.wnxt, 10,
+        if (regexp_match_case_r(tbuf2 + 1, str, AF_Case(ptr), args, 10,
                                 match_space, match_space_len)) {
           match_found = 1;
           match++;
@@ -1644,9 +1656,8 @@
           match_found = 1;
           match++;
           if (!just_match)
-            wild_match_case_r(tbuf2 + 1, str, AF_Case(ptr),
-                              global_eval_context.wnxt, 10, match_space,
-                              match_space_len);
+            wild_match_case_r(tbuf2 + 1, str, AF_Case(ptr), args, 10,
+                              match_space, match_space_len);
         }
       }
       if (match_found) {
@@ -1677,8 +1688,14 @@
           safe_str(AL_NAME(ptr), atrname, abp);
         }
         if (!just_match) {
-          /* do_rawlog(LT_TRACE, "MATCHED %s:", AL_NAME(ptr)); */
-          parse_que(thing, s, player, NULL);
+          if (inplace) {
+            insert_que(thing, s, player, player, NULL, args, rnull, QUEUE_RECURSE);
+          } else {
+            for (i = 0; i < 10; i++) {
+              global_eval_context.wnxt[i] = args[i];
+            }
+            parse_que(thing, s, player, NULL);
+          }
         }
       }
     }
@@ -1705,13 +1722,17 @@
  * \retval 0 attribute failed to match.
  */
 int
-one_comm_match(dbref thing, dbref player, const char *atr, const char *str)
+one_comm_match(dbref thing, dbref player, const char *atr, const char *str,
+               int inplace)
 {
   ATTR *ptr;
   char tbuf1[BUFFER_LEN];
   char tbuf2[BUFFER_LEN];
   char *s;
   char match_space[BUFFER_LEN * 2];
+  char *args[10];
+  char *rnull[NUMQ];
+  int i;
   ssize_t match_space_len = BUFFER_LEN * 2;
 
   /* check for lots of easy ways out */
@@ -1746,15 +1767,24 @@
     strcpy(tbuf2, tbuf1);
 
   if (AF_Regexp(ptr) ?
-      regexp_match_case_r(tbuf2 + 1, str, AF_Case(ptr),
-                          global_eval_context.wnxt, 10,
+      regexp_match_case_r(tbuf2 + 1, str, AF_Case(ptr), args, 10,
                           match_space, match_space_len) :
-      wild_match_case_r(tbuf2 + 1, str, AF_Case(ptr), global_eval_context.wnxt,
+      wild_match_case_r(tbuf2 + 1, str, AF_Case(ptr), args,
                         10, match_space, match_space_len)) {
     if (!eval_lock(player, thing, Command_Lock)
         || !eval_lock(player, thing, Use_Lock))
       return 0;
-    parse_que(thing, s, player, NULL);
+    if (inplace) {
+      for (i = 0; i < NUMQ; i++) {
+        rnull[i] = NULL;
+      }
+      insert_que(thing, s, player, player, NULL, args, rnull, QUEUE_RECURSE);
+    } else {
+      for (i = 0; i < 10; i++) {
+        global_eval_context.wnxt[i] = args[i];
+      }
+      parse_que(thing, s, player, NULL);
+    }
     return 1;
   }
   return 0;
@@ -1774,8 +1804,8 @@
  * \param s value to set the attribute to (or NULL to clear).
  * \param player enactor, for permission checks.
  * \param flags attribute flags.
- * \retval -1 failure of one sort.
- * \retval 0 failure of another sort.
+ * \retval -1 failure - invalid value for attribute.
+ * \retval 0 failure for other reason
  * \retval 1 success.
  */
 int
@@ -1852,7 +1882,7 @@
       strcpy(tbuf1, s);
       aliases = tbuf1;
       while ((alias = split_token(&aliases, ';')) != NULL) {
-        if (!ok_name(alias)) {
+        if (!ok_name(alias, 1)) {
           notify_format(player, T("'%s' is not a valid exit name."), alias);
           return -1;
         }
Index: src/function.c
===================================================================
--- src/function.c	(.../184p2)	(revision 828)
+++ src/function.c	(.../184p3)	(revision 828)
@@ -375,6 +375,7 @@
   {"CHANNELS", fun_channels, 0, 2, FN_REG | FN_STRIPANSI},
   {"CLFLAGS", fun_cflags, 1, 2, FN_REG | FN_STRIPANSI},
   {"CLOCK", fun_clock, 1, 2, FN_REG | FN_STRIPANSI},
+  {"CMOGRIFIER", fun_cmogrifier, 1, 1, FN_REG | FN_STRIPANSI},
   {"CMSGS", fun_cinfo, 1, 1, FN_REG | FN_STRIPANSI},
   {"COWNER", fun_cowner, 1, 1, FN_REG | FN_STRIPANSI},
   {"CRECALL", fun_crecall, 1, 5, FN_REG | FN_STRIPANSI},
@@ -397,7 +398,8 @@
   {"CONTROLS", fun_controls, 2, 2, FN_REG | FN_STRIPANSI},
   {"CONVSECS", fun_convsecs, 1, 2, FN_REG | FN_STRIPANSI},
   {"CONVUTCSECS", fun_convsecs, 1, 1, FN_REG | FN_STRIPANSI},
-  {"CONVTIME", fun_convtime, 1, 1, FN_REG | FN_STRIPANSI},
+  {"CONVTIME", fun_convtime, 1, 2, FN_REG | FN_STRIPANSI},
+  {"CONVUTCTIME", fun_convtime, 1, 1, FN_REG | FN_STRIPANSI},
   {"COR", fun_cor, 2, INT_MAX, FN_NOPARSE | FN_STRIPANSI},
   {"NCOR", fun_cor, 1, INT_MAX, FN_NOPARSE | FN_STRIPANSI},
   {"CREATE", fun_create, 1, 3, FN_REG},
@@ -410,7 +412,7 @@
   {"DEFAULT", fun_default, 2, INT_MAX, FN_NOPARSE},
   {"DELETE", fun_delete, 3, 3, FN_REG},
   {"DIE", fun_die, 2, 3, FN_REG | FN_STRIPANSI},
-  {"DIG", fun_dig, 1, 3, FN_REG},
+  {"DIG", fun_dig, 1, 4, FN_REG},
   {"DIGEST", fun_digest, 2, -2, FN_REG},
   {"DIST2D", fun_dist2d, 4, 4, FN_REG | FN_STRIPANSI},
   {"DIST3D", fun_dist3d, 6, 6, FN_REG | FN_STRIPANSI},
@@ -514,6 +516,7 @@
   {"LOCALIZE", fun_localize, 1, 1, FN_NOPARSE},
   {"LOCATE", fun_locate, 3, 3, FN_REG | FN_STRIPANSI},
   {"LOCK", fun_lock, 1, 2, FN_REG | FN_STRIPANSI},
+  {"LOCKFILTER", fun_lockfilter, 2, 3, FN_REG | FN_STRIPANSI},
   {"LOCKFLAGS", fun_lockflags, 0, 1, FN_REG | FN_STRIPANSI},
   {"LOCKOWNER", fun_lockowner, 1, 1, FN_REG | FN_STRIPANSI},
   {"LOCKS", fun_locks, 1, 1, FN_REG | FN_STRIPANSI},
@@ -632,7 +635,7 @@
   {"PORTS", fun_ports, 1, 1, FN_REG | FN_STRIPANSI},
   {"POS", fun_pos, 2, 2, FN_REG | FN_STRIPANSI},
   {"POSS", fun_poss, 1, 1, FN_REG | FN_STRIPANSI},
-  {"POWERS", fun_powers, 1, 2, FN_REG | FN_STRIPANSI},
+  {"POWERS", fun_powers, 0, 2, FN_REG | FN_STRIPANSI},
   {"PROMPT", fun_prompt, 2, -2, FN_REG},
   {"PUEBLO", fun_pueblo, 1, 1, FN_REG | FN_STRIPANSI},
   {"QUOTA", fun_quota, 1, 1, FN_REG | FN_STRIPANSI},
@@ -687,9 +690,9 @@
   {"SET", fun_set, 2, 2, FN_REG},
   {"SETQ", fun_setq, 2, INT_MAX, FN_REG},
   {"SETR", fun_setq, 2, INT_MAX, FN_REG},
-  {"SETDIFF", fun_setdiff, 2, 5, FN_REG},
-  {"SETINTER", fun_setinter, 2, 5, FN_REG},
-  {"SETUNION", fun_setunion, 2, 5, FN_REG},
+  {"SETDIFF", fun_setmanip, 2, 5, FN_REG},
+  {"SETINTER", fun_setmanip, 2, 5, FN_REG},
+  {"SETUNION", fun_setmanip, 2, 5, FN_REG},
   {"SHA0", fun_sha0, 1, 1, FN_REG},
   {"SHL", fun_shl, 2, 2, FN_REG | FN_STRIPANSI},
   {"SHR", fun_shr, 2, 2, FN_REG | FN_STRIPANSI},
@@ -721,7 +724,7 @@
   {"STRLEN", fun_strlen, 1, -1, FN_REG},
   {"STRMATCH", fun_strmatch, 2, 3, FN_REG},
   {"STRREPLACE", fun_strreplace, 4, 4, FN_REG},
-  {"SUB", fun_sub, 2, 2, FN_REG | FN_STRIPANSI},
+  {"SUB", fun_sub, 2, INT_MAX, FN_REG | FN_STRIPANSI},
   {"SUBJ", fun_subj, 1, 1, FN_REG | FN_STRIPANSI},
   {"SWITCH", fun_switch, 3, INT_MAX, FN_NOPARSE},
   {"SWITCHALL", fun_switch, 3, INT_MAX, FN_NOPARSE},
@@ -1367,6 +1370,9 @@
     return 0;
   *attrname++ = '\0';
   upcasestr(attrname);
+  /* Account for #dbref/foo */
+  if (*one == '#')
+    one++;
   /* Don't care if the attr exists, only if it /could/ exist */
   if (!is_integer(one) || !good_atr_name(attrname))
     return 0;
Index: src/cmds.c
===================================================================
--- src/cmds.c	(.../184p2)	(revision 828)
+++ src/cmds.c	(.../184p3)	(revision 828)
@@ -262,6 +262,7 @@
     } else {
       strcpy(prefix, "FugueEdit > ");
     }
+    flags |= DEC_TF;            /* Don't decompile attr flags */
   } else {
     strcpy(prefix, arg_right);
   }
@@ -416,7 +417,7 @@
 
 COMMAND(cmd_force)
 {
-  do_force(player, arg_left, arg_right);
+  do_force(player, caller, arg_left, arg_right, SW_ISSET(sw, SWITCH_INPLACE));
 }
 
 COMMAND(cmd_function)
@@ -496,13 +497,18 @@
 
 COMMAND(cmd_hide)
 {
-  hide_player(player, !(SW_ISSET(sw, SWITCH_NO) || SW_ISSET(sw, SWITCH_OFF)),
-              arg_left);
+  int status = 2;
+  if (SW_ISSET(sw, SWITCH_NO) || SW_ISSET(sw, SWITCH_OFF))
+    status = 0;
+  else if (SW_ISSET(sw, SWITCH_YES) || SW_ISSET(sw, SWITCH_ON))
+    status = 1;
+  hide_player(player, status, arg_left);
 }
 
 COMMAND(cmd_hook)
 {
   enum hook_type flags;
+  int inplace = 0;
 
   if (SW_ISSET(sw, SWITCH_AFTER))
     flags = HOOK_AFTER;
@@ -516,10 +522,17 @@
     do_hook_list(player, arg_left);
     return;
   } else {
-    notify(player, T("You must give a switch for @hook"));
+    notify(player, T("You must give a switch for @hook."));
     return;
   }
-  do_hook(player, arg_left, args_right[1], args_right[2], flags);
+  if (SW_ISSET(sw, SWITCH_INPLACE)) {
+    if (flags != HOOK_OVERRIDE) {
+      notify(player, T("You can only use /inplace with /override."));
+      return;
+    }
+    inplace = 1;
+  }
+  do_hook(player, arg_left, args_right[1], args_right[2], flags, inplace);
 }
 
 COMMAND(cmd_huh_command)
@@ -541,11 +554,12 @@
 
 COMMAND(cmd_lemit)
 {
-  int spflags = (!strcmp(cmd->name, "@NSLEMIT")
-                 && Can_Nspemit(player) ? PEMIT_SPOOF : 0);
+  int flags = SILENT_OR_NOISY(sw, SILENT_PEMIT);
+  if (!strcmp(cmd->name, "@NSLEMIT") && Can_Nspemit(player))
+    flags |= PEMIT_SPOOF;
+
   SPOOF(player, cause, sw);
-  do_lemit(player, arg_left,
-           (SW_ISSET(sw, SWITCH_SILENT) ? PEMIT_SILENT : 0) | spflags);
+  do_lemit(player, arg_left, flags);
 }
 
 COMMAND(cmd_link)
@@ -599,38 +613,44 @@
     do_lock(player, arg_left, arg_right, Basic_Lock);
 }
 
-COMMAND(cmd_log)
+static enum log_type
+logtype_from_switch(switch_mask sw, enum log_type def)
 {
+  enum log_type type;
+
   if (SW_ISSET(sw, SWITCH_CHECK))
-    do_writelog(player, arg_left, LT_CHECK);
+    type = LT_CHECK;
   else if (SW_ISSET(sw, SWITCH_CMD))
-    do_writelog(player, arg_left, LT_CMD);
+    type = LT_CMD;
   else if (SW_ISSET(sw, SWITCH_CONN))
-    do_writelog(player, arg_left, LT_CONN);
+    type = LT_CONN;
   else if (SW_ISSET(sw, SWITCH_ERR))
-    do_writelog(player, arg_left, LT_ERR);
+    type = LT_ERR;
   else if (SW_ISSET(sw, SWITCH_TRACE))
-    do_writelog(player, arg_left, LT_TRACE);
+    type = LT_TRACE;
   else if (SW_ISSET(sw, SWITCH_WIZ))
-    do_writelog(player, arg_left, LT_WIZ);
+    type = LT_WIZ;
   else
-    do_writelog(player, arg_left, LT_CMD);
+    type = def;
+
+  return type;
+}
+
+COMMAND(cmd_log)
+{
+  enum log_type type = logtype_from_switch(sw, LT_CMD);
+
+  if (SW_ISSET(sw, SWITCH_RECALL)) {
+    int lines = parse_integer(arg_left);
+    do_log_recall(player, type, lines);
+  } else
+    do_writelog(player, arg_left, type);
 }
 
 COMMAND(cmd_logwipe)
 {
-  if (SW_ISSET(sw, SWITCH_CHECK))
-    do_logwipe(player, LT_CHECK, arg_left);
-  else if (SW_ISSET(sw, SWITCH_CMD))
-    do_logwipe(player, LT_CMD, arg_left);
-  else if (SW_ISSET(sw, SWITCH_CONN))
-    do_logwipe(player, LT_CONN, arg_left);
-  else if (SW_ISSET(sw, SWITCH_TRACE))
-    do_logwipe(player, LT_TRACE, arg_left);
-  else if (SW_ISSET(sw, SWITCH_WIZ))
-    do_logwipe(player, LT_WIZ, arg_left);
-  else
-    do_logwipe(player, LT_ERR, arg_left);
+  enum log_type type = logtype_from_switch(sw, LT_ERR);
+  do_logwipe(player, type, arg_left);
 }
 
 COMMAND(cmd_lset)
@@ -846,14 +866,7 @@
 
 COMMAND(cmd_pemit)
 {
-  int flags;
-
-  if (SW_ISSET(sw, SWITCH_SILENT))
-    flags = PEMIT_SILENT;
-  else if (SW_ISSET(sw, SWITCH_NOISY))
-    flags = 0;
-  else
-    flags = SILENT_PEMIT ? PEMIT_SILENT : 0;
+  int flags = SILENT_OR_NOISY(sw, SILENT_PEMIT);
 
   if (SW_ISSET(sw, SWITCH_PORT)) {
     do_pemit_port(player, arg_left, arg_right, flags);
@@ -874,17 +887,12 @@
 
 COMMAND(cmd_prompt)
 {
-  int flags;
+  int flags = SILENT_OR_NOISY(sw, SILENT_PEMIT) | PEMIT_PROMPT;
   SPOOF(player, cause, sw);
-  if (SW_ISSET(sw, SWITCH_SILENT))
-    flags = PEMIT_SILENT;
-  else if (SW_ISSET(sw, SWITCH_NOISY))
-    flags = 0;
-  else
-    flags = SILENT_PEMIT ? PEMIT_SILENT : 0;
+
   if (!strcmp(cmd->name, "@NSPEMIT") && Can_Nspemit(player))
     flags |= PEMIT_SPOOF;
-  do_pemit_list(player, arg_left, arg_right, flags | PEMIT_PROMPT);
+  do_pemit_list(player, arg_left, arg_right, flags);
 }
 
 COMMAND(cmd_poll)
@@ -957,14 +965,9 @@
 
 COMMAND(cmd_remit)
 {
-  int flags;
+  int flags = SILENT_OR_NOISY(sw, SILENT_PEMIT);
   SPOOF(player, cause, sw);
-  if (SW_ISSET(sw, SWITCH_SILENT))
-    flags = PEMIT_SILENT;
-  else if (SW_ISSET(sw, SWITCH_NOISY))
-    flags = 0;
-  else
-    flags = SILENT_PEMIT ? PEMIT_SILENT : 0;
+
   if (SW_ISSET(sw, SWITCH_LIST))
     flags |= PEMIT_LIST;
   if (!strcmp(cmd->name, "@NSREMIT") && Can_Nspemit(player))
@@ -1017,7 +1020,8 @@
 COMMAND(cmd_select)
 {
   do_switch(player, arg_left, args_right, cause, 1,
-            SW_ISSET(sw, SWITCH_NOTIFY), SW_ISSET(sw, SWITCH_REGEXP));
+            SW_ISSET(sw, SWITCH_NOTIFY), SW_ISSET(sw, SWITCH_REGEXP),
+            SW_ISSET(sw, SWITCH_INPLACE));
 }
 
 COMMAND(cmd_set)
@@ -1039,20 +1043,22 @@
 
 COMMAND(cmd_sitelock)
 {
+  int psw = SW_ISSET(sw, SWITCH_PLAYER);
   if (SW_ISSET(sw, SWITCH_BAN))
-    do_sitelock(player, arg_left, NULL, NULL, SITELOCK_BAN);
+    do_sitelock(player, arg_left, NULL, NULL, SITELOCK_BAN, psw);
   else if (SW_ISSET(sw, SWITCH_REGISTER))
-    do_sitelock(player, arg_left, NULL, NULL, SITELOCK_REGISTER);
+    do_sitelock(player, arg_left, NULL, NULL, SITELOCK_REGISTER, psw);
   else if (SW_ISSET(sw, SWITCH_NAME))
     do_sitelock_name(player, arg_left);
   else if (SW_ISSET(sw, SWITCH_REMOVE))
-    do_sitelock(player, arg_left, NULL, NULL, SITELOCK_REMOVE);
+    do_sitelock(player, arg_left, NULL, NULL, SITELOCK_REMOVE, psw);
   else if (SW_ISSET(sw, SWITCH_CHECK))
-    do_sitelock(player, arg_left, NULL, NULL, SITELOCK_CHECK);
+    do_sitelock(player, arg_left, NULL, NULL, SITELOCK_CHECK, psw);
   else if (!arg_left || !*arg_left)
-    do_sitelock(player, NULL, NULL, NULL, SITELOCK_LIST);
+    do_sitelock(player, NULL, NULL, NULL, SITELOCK_LIST, psw);
   else
-    do_sitelock(player, arg_left, args_right[1], args_right[2], SITELOCK_ADD);
+    do_sitelock(player, arg_left, args_right[1], args_right[2], SITELOCK_ADD,
+                psw);
 }
 
 COMMAND(cmd_stats)
@@ -1091,7 +1097,8 @@
 COMMAND(cmd_switch)
 {
   do_switch(player, arg_left, args_right, cause, SW_ISSET(sw, SWITCH_FIRST),
-            SW_ISSET(sw, SWITCH_NOTIFY), SW_ISSET(sw, SWITCH_REGEXP));
+            SW_ISSET(sw, SWITCH_NOTIFY), SW_ISSET(sw, SWITCH_REGEXP),
+            SW_ISSET(sw, SWITCH_INPLACE));
 }
 
 COMMAND(cmd_squota)
@@ -1111,7 +1118,7 @@
 
 COMMAND(cmd_include)
 {
-  do_include(player, arg_left, args_right);
+  do_include(player, cause, arg_left, args_right);
 }
 
 COMMAND(cmd_trigger)
@@ -1212,8 +1219,9 @@
 
 COMMAND(cmd_zemit)
 {
-  int flags = (!strcmp(cmd->name, "@NSZEMIT")
-               && Can_Nspemit(player) ? PEMIT_SPOOF : 0);
+  int flags = SILENT_OR_NOISY(sw, SILENT_PEMIT);
+  if (!strcmp(cmd->name, "@NSZEMIT") && Can_Nspemit(player))
+    flags |= PEMIT_SPOOF;
   do_zemit(player, arg_left, arg_right, flags);
 }
 
Index: src/markup.c
===================================================================
--- src/markup.c	(.../184p2)	(revision 828)
+++ src/markup.c	(.../184p3)	(revision 828)
@@ -121,6 +121,9 @@
   char *p;
   int i;
 
+  if (!*args[1])
+    return;
+
   /* Populate the colors struct */
   define_ansi_data(&colors, args[0]);
 
Index: src/local.dst
===================================================================
--- src/local.dst	(.../184p2)	(revision 828)
+++ src/local.dst	(.../184p3)	(revision 828)
@@ -1,4 +1,4 @@
-/*-----------------------------------------------------------------
+/*----------------------------------------------- -*- c -*-
  * Local stuff
  *
  * This file contains custom stuff, and some of the items here are
@@ -16,8 +16,10 @@
 #include "parse.h"
 #include "htab.h"
 #include "command.h"
-#include "confmagic.h"
 #include "lock.h"
+#include "game.h"
+#include "confmagic.h"
+
 
 extern HASHTAB htab_reserved_aliases;
 
@@ -26,6 +28,20 @@
 void
 local_startup(void)
 {
+
+/* Register local_timer to be called once a second. You can also
+* register other callbacks to run at other intervals. See local_timer()
+* below for an example of what the callback function needs to do if it
+* should be run more than once. 
+*
+* Arguments are: Number of seconds from now to run, the callback function,
+* a data argument to pass to it, and a softcoded event name to run at the same
+* time. The latter two can be null pointers. The callback function returns true
+* if the softcode event should be triggered, false if it shouldn't.
+*/
+#if 0                           /* Change to 1 if you need local_timer functionality. */
+  sq_register_loop(1, local_timer, NULL, NULL);
+#endif
 }
 
 /* Add you own runtime configuration options here, and you can set
@@ -103,9 +119,12 @@
 /* This is called exactly once a second
  * After the MUSH has done all it's stuff
  */
-void
-local_timer(void)
+bool
+local_timer(void *data __attribute__ ((__unused__)))
 {
+
+  /* The callback has to be set back up or it'll only run once. */
+  return false;
 }
 
 /* Called when a player connects. If this is a new creation,
Index: src/funmisc.c
===================================================================
--- src/funmisc.c	(.../184p2)	(revision 828)
+++ src/funmisc.c	(.../184p3)	(revision 828)
@@ -52,7 +52,7 @@
   if (!args[0] || !*args[0])
     safe_str("#-1", buff, bp);
   else if (!strcasecmp(args[0], "name"))
-    safe_boolean(ok_name(args[1]), buff, bp);
+    safe_boolean(ok_name(args[1], 0), buff, bp);
   else if (!strcasecmp(args[0], "attrname"))
     safe_boolean(good_atr_name(upcasestr(args[1])), buff, bp);
   else if (!strcasecmp(args[0], "playername"))
@@ -475,7 +475,7 @@
 #define CLEAR_SWITCH_VALUE(pe) \
   pe->switch_text[pe->switch_nesting] = NULL; \
   pe->switch_nesting--; \
-  pe_info->local_switch_nesting--;
+  pe->local_switch_nesting--;
 /* ARGSUSED */
 FUNCTION(fun_switch)
 {
@@ -1090,9 +1090,9 @@
       safe_dbref(thing, buff, bp);
       return;
     }
-    if (!okay_pemit(executor, thing)) {
-      notify_format(executor, T("I don't think #%d wants to hear from you."),
-                    thing);
+    if (!okay_pemit(executor, thing, 1,
+                    tprintf(T("I don't think #%d wants to hear from you."),
+                            thing))) {
       safe_str("#-1", buff, bp);
       return;
     }
Index: src/move.c
===================================================================
--- src/move.c	(.../184p2)	(revision 828)
+++ src/move.c	(.../184p3)	(revision 828)
@@ -28,7 +28,8 @@
 #include "game.h"
 #include "confmagic.h"
 
-void moveit(dbref what, dbref where, int nomovemsgs);
+void moveit(dbref what, dbref where, int nomovemsgs,
+            dbref enactor, const char *cause);
 static void send_contents(dbref loc, dbref dest);
 static void maybe_dropto(dbref loc, dbref dropto);
 static dbref find_var_dest(dbref player, dbref exit_obj);
@@ -48,9 +49,9 @@
  * \param where location to move it to.
  */
 void
-moveto(dbref what, dbref where)
+moveto(dbref what, dbref where, dbref enactor, const char *cause)
 {
-  enter_room(what, where, 0);
+  enter_room(what, where, 0, enactor, cause);
 }
 
 
@@ -60,7 +61,8 @@
  * \param nomovemsgs if 1, don't show movement messages.
  */
 void
-moveit(dbref what, dbref where, int nomovemsgs)
+moveit(dbref what, dbref where, int nomovemsgs,
+       dbref enactor, const char *cause)
 {
   dbref loc, old;
   dbref absloc, absold;
@@ -81,7 +83,7 @@
     return;                     /* NOTHING doesn't have contents */
   case HOME:
     where = Home(what);         /* home */
-    safe_tel(what, where, nomovemsgs);
+    safe_tel(what, where, nomovemsgs, enactor, cause);
     return;
     /*NOTREACHED */
     break;
@@ -137,6 +139,10 @@
   if (!nomovemsgs)
     did_it_interact(what, what, "MOVE", NULL, "OMOVE", NULL,
                     "AMOVE", where, NA_INTER_SEE);
+  queue_event(enactor, "OBJECT`MOVE", "%s,%s,%s,%d,%s",
+              unparse_objid(what),
+              unparse_objid(where),
+              unparse_objid(old), nomovemsgs ? 1 : 0, cause);
 }
 
 /** A dropper is an object that can hear and has a connected owner */
@@ -148,24 +154,28 @@
   dbref first;
   dbref rest;
   first = Contents(loc);
-  Contents(loc) = NOTHING;
 
-  /* blast locations of everything in list */
-  DOLIST(rest, first) {
-    Location(rest) = NOTHING;
-  }
+  /* blast locations of everything in list.
+   *
+   * Not now, as object`move depends on it. */
+  /*
+     Contents(loc) = NOTHING;
+     DOLIST(rest, first) {
+     Location(rest) = NOTHING;
+     }
+   */
 
   while (first != NOTHING) {
     rest = Next(first);
-    if (Dropper(first) || !eval_lock(first, loc, Dropto_Lock)) {
-      Location(first) = loc;
-      PUSH(first, Contents(loc));
-    } else
-      enter_room(first, Sticky(first) ? HOME : dest, 0);
+    if (!(Dropper(first) || !eval_lock(first, loc, Dropto_Lock))) {
+      enter_room(first, Sticky(first) ? HOME : dest, 0, SYSEVENT, "dropto");
+    }
     first = rest;
   }
 
-  Contents(loc) = reverse(Contents(loc));
+  /*
+     Contents(loc) = reverse(Contents(loc));
+   */
 }
 
 static void
@@ -190,9 +200,12 @@
  * \param player object entering the container.
  * \param loc container to enter.
  * \param nomovemsgs if 1, don't give movement messages.
+ * \param enactor object that caused this moving
+ * \param cause what command or event caused this move
  */
 void
-enter_room(dbref player, dbref loc, int nomovemsgs)
+enter_room(dbref player, dbref loc, int nomovemsgs,
+           dbref enactor, const char *cause)
 {
   dbref old;
   dbref dropto;
@@ -235,7 +248,7 @@
   old = Location(player);
 
   /* go there */
-  moveit(player, loc, nomovemsgs);
+  moveit(player, loc, nomovemsgs, enactor, cause);
 
   /* if old location has STICKY dropto, send stuff through it */
 
@@ -257,14 +270,15 @@
  * \param nomovemsgs if 1, don't show movement messages
  */
 void
-safe_tel(dbref player, dbref dest, int nomovemsgs)
+safe_tel(dbref player, dbref dest, int nomovemsgs,
+         dbref enactor, const char *cause)
 {
   dbref first;
   dbref rest;
   if (dest == HOME)
     dest = Home(player);
   if (Owner(Location(player)) == Owner(dest)) {
-    enter_room(player, dest, nomovemsgs);
+    enter_room(player, dest, nomovemsgs, enactor, cause);
     return;
   }
   first = Contents(player);
@@ -284,7 +298,7 @@
     if (!controls(player, first)
         && (Sticky(first)
             && (Home(first) != player)))
-      enter_room(first, HOME, nomovemsgs);
+      enter_room(first, HOME, nomovemsgs, enactor, cause);
     else {
       PUSH(first, Contents(player));
       Location(first) = player;
@@ -292,7 +306,7 @@
     first = rest;
   }
   Contents(player) = reverse(Contents(player));
-  enter_room(player, dest, nomovemsgs);
+  enter_room(player, dest, nomovemsgs, enactor, cause);
 }
 
 /** Can a player go in a given direction?
@@ -383,7 +397,7 @@
     notify(player, T("There's no place like home..."));
     notify(player, T("There's no place like home..."));
     notify(player, T("There's no place like home..."));
-    safe_tel(player, HOME, 0);
+    safe_tel(player, HOME, 0, player, "home");
   } else {
     /* find the exit */
     if (type == MOVE_GLOBAL)
@@ -457,7 +471,7 @@
           /* Remember the current room */
           loc = Location(player);
           /* Move the leader */
-          enter_room(player, var_dest, 0);
+          enter_room(player, var_dest, 0, player, "move");
           /* Move the followers if the leader is elsewhere */
           if (Location(player) != loc)
             follower_command(player, loc, tprintf("%s #%d", "goto", exit_m));
@@ -473,7 +487,7 @@
           /* Remember the current room */
           loc = Location(player);
           /* Move the leader */
-          safe_tel(player, var_dest, 0);
+          safe_tel(player, var_dest, 0, player, "move");
           /* Move the followers if the leader is elsewhere */
           if (Location(player) != loc)
             follower_command(player, loc, tprintf("%s #%d", "goto", exit_m));
@@ -558,7 +572,8 @@
         notify_format(player, T("I can't tell which %s."), boxname);
         return;
       }
-      thing = match_result(box, objname, NOTYPE, MAT_POSSESSION | MAT_ENGLISH);
+      thing =
+        match_result_relative(player, box, objname, NOTYPE, MAT_OBJ_CONTENTS);
       if (thing == NOTHING) {
         notify(player, T("I don't see that here."));
         return;
@@ -587,7 +602,7 @@
         safe_format(tbuf2, &tp, T("takes %s from %s."), Name(thing),
                     Name(Location(thing)));
         *tp = '\0';
-        moveto(thing, player);
+        moveto(thing, player, player, "get");
         did_it(player, thing, "SUCCESS", tbuf1, "OSUCCESS", tbuf2, "ASUCCESS",
                NOTHING);
         did_it_with(player, player, "RECEIVE", NULL, "ORECEIVE", NULL,
@@ -627,7 +642,7 @@
           return;
         }
         if (could_doit(player, thing)) {
-          moveto(thing, player);
+          moveto(thing, player, player, "get");
           notify_format(thing, T("%s took you."), Name(player));
           tp = tbuf1;
           safe_format(tbuf1, &tp, T("You take %s."), Name(thing));
@@ -694,15 +709,15 @@
       return;
     } else if (Sticky(thing) && !Fixed(thing)) {
       notify(thing, T("Dropped."));
-      safe_tel(thing, HOME, 0);
+      safe_tel(thing, HOME, 0, player, "drop");
     } else if ((Location(loc) != NOTHING) && IsRoom(loc) && !Sticky(loc)
                && eval_lock(thing, loc, Dropto_Lock)) {
       /* location has immediate dropto */
       notify_format(thing, T("%s drops you."), Name(player));
-      moveto(thing, Location(loc));
+      moveto(thing, Location(loc), player, "drop");
     } else {
       notify_format(thing, T("%s drops you."), Name(player));
-      moveto(thing, loc);
+      moveto(thing, loc, player, "drop");
     }
     break;
   }
@@ -808,7 +823,7 @@
         safe_format(tbuf2, &tp, T("takes %s from %s."), Name(item),
                     Name(thing));
         *tp = '\0';
-        moveto(item, player);
+        moveto(item, player, player, "empty");
         did_it(player, item, "SUCCESS", tbuf1, "OSUCCESS", tbuf2, "ASUCCESS",
                NOTHING);
         did_it_with(player, player, "RECEIVE", NULL, "ORECEIVE", NULL,
@@ -817,16 +832,16 @@
       /* Drop messages */
       if (thing_loc != player) {
         if (Sticky(item) && !Fixed(item)) {
-          safe_tel(thing, HOME, 0);
+          safe_tel(thing, HOME, 0, player, "empty");
         } else if ((Location(thing_loc) != NOTHING) && IsRoom(thing_loc)
                    && !Sticky(thing_loc)
                    && eval_lock(item, thing_loc, Dropto_Lock)) {
           /* location has immediate dropto */
           notify_format(item, T("%s drops you."), Name(player));
-          moveto(item, Location(thing_loc));
+          moveto(item, Location(thing_loc), player, "empty");
         } else {
           notify_format(item, T("%s drops you."), Name(player));
-          moveto(item, thing_loc);
+          moveto(item, thing_loc, player, "empty");
         }
         tp = tbuf1;
         safe_format(tbuf1, &tp, T("You drop %s."), Name(item));
@@ -890,7 +905,7 @@
       return;
     }
     /* Move the leader */
-    safe_tel(player, thing, 0);
+    safe_tel(player, thing, 0, player, "enter");
     /* Move the followers if the leader is elsewhere */
     if (Location(player) != loc)
       follower_command(player, loc, tprintf("%s #%d", "enter", thing));
@@ -913,7 +928,7 @@
     fail_lock(player, loc, Leave_Lock, T("You can't leave."), NOTHING);
     return;
   }
-  enter_room(player, Location(loc), 0);
+  enter_room(player, Location(loc), 0, player, "leave");
   if (Location(player) != loc)
     follower_command(player, loc, "leave");
 }
@@ -1402,7 +1417,7 @@
             || See_All(follower))) {
       /* This is a follower who was in the room with the leader. Follow. */
       notify_format(follower, T("You follow %s."), Name(leader));
-      process_command(follower, combuf, follower, 0);
+      process_command(follower, combuf, follower, leader, 0);
     }
   }
 }
Index: src/speech.c
===================================================================
--- src/speech.c	(.../184p2)	(revision 828)
+++ src/speech.c	(.../184p3)	(revision 828)
@@ -60,18 +60,26 @@
  * pagelock and target isn't HAVEN.
  * \param player dbref attempting to pemit.
  * \param target target dbref to pemit to.
+ * \param dofails If nonzero, send failure message 'def' or run fail_lock()
+ * \param def default message if there is no appropriate failure message
  * \retval 1 player may pemit to target.
  * \retval 0 player may not pemit to target.
  */
 int
-okay_pemit(dbref player, dbref target)
+okay_pemit(dbref player, dbref target, int dofails, const char *def)
 {
   if (Pemit_All(player))
     return 1;
-  if (IsPlayer(target) && Haven(target))
+
+  if (IsPlayer(target) && Haven(target)) {
+    if (dofails && def && *def)
+      notify(player, def);
     return 0;
+  }
   if (!eval_lock(player, target, Page_Lock)) {
-    fail_lock(player, target, Page_Lock, NULL, NOTHING);
+    if (dofails) {
+      fail_lock(player, target, Page_Lock, def, NOTHING);
+    }
     return 0;
   }
   return 1;
@@ -133,7 +141,7 @@
                 tprintf(T("%s types --> %s%s%s"), spname(player),
                         ANSI_HILITE, tbuf1, ANSI_END), NA_INTER_HEAR);
   command = mush_strdup(tbuf1, "string");       /* process_command is destructive */
-  process_command(player, command, cause, 1);
+  process_command(player, command, cause, cause, 1);
   mush_free(command, "string");
   recurse = 0;                  /* Ok, we can be called again safely */
 }
@@ -189,7 +197,8 @@
 void
 do_oemit_list(dbref player, char *list, const char *message, int flags)
 {
-  char *temp, *p, *s;
+  char *temp, *p;
+  const char *s;
   dbref who;
   dbref pass[12], locs[10];
   int i, oneloc = 0;
@@ -236,12 +245,12 @@
     temp = list;
   }
 
-  s = trim_space_sep(temp, ' ');
-  while (s) {
-    p = split_token(&s, ' ');
+  s = temp;
+  while (s && *s) {
+    p = next_in_list(&s);
     /* If a room was given, we match relative to the room */
     if (oneloc)
-      who = match_result(pass[1], p, NOTYPE, MAT_POSSESSION | MAT_ABSOLUTE);
+      who = match_result_relative(player, pass[1], p, NOTYPE, MAT_OBJ_CONTENTS);
     else
       who = noisy_match_result(player, p, NOTYPE, MAT_OBJECTS);
     /* pass[0] tracks the number of valid players we've found.
@@ -250,7 +259,8 @@
      * locs[0..10] are corresponding dbrefs of locations
      */
     if (GoodObject(who) && GoodObject(Location(who))
-        && (Loud(player) || eval_lock(player, Location(who), Speech_Lock))
+        && (Loud(player) || (oneloc && Location(who) == pass[1]) ||
+            eval_lock(player, Location(who), Speech_Lock))
       ) {
       if (pass[0] < 10) {
         locs[pass[0]] = Location(who);
@@ -263,12 +273,23 @@
     }
   }
 
+  if (flags & PEMIT_SPOOF)
+    na_flags |= NA_SPOOF;
+
+  if (oneloc && pass[0] == 0) {
+    /* A specific location was given, but there were no matching objects to
+     * omit, so just remit */
+    notify_anything_loc(player, na_loc, &pass[1], ns_esnotify, na_flags,
+                        message, pass[1]);
+    do_audible_stuff(pass[1], NULL, 0, message);
+    return;
+  }
+
+
   /* Sort the list of rooms to oemit to so we don't oemit to the same
    * room twice */
   qsort((void *) locs, pass[0], sizeof(locs[0]), dbref_comp);
 
-  if (flags & PEMIT_SPOOF)
-    na_flags |= NA_SPOOF;
   for (i = 0; i < pass[0]; i++) {
     if (i != 0 && locs[i] == locs[i - 1])
       continue;
@@ -496,7 +517,7 @@
 
   while (l && *l && (p = next_in_list(&l))) {
     who = noisy_match_result(player, p, NOTYPE, MAT_EVERYTHING);
-    if (GoodObject(who) && okay_pemit(player, who)) {
+    if (GoodObject(who) && okay_pemit(player, who, 1, NULL)) {
       if (nospoof && Nospoof(who)) {
         if (Paranoid(who)) {
           if (!nspbuf) {
@@ -567,12 +588,10 @@
     notify(player, T("I don't know who you mean!"));
     break;
   default:
-    if (!okay_pemit(player, who)) {
-      notify_format(player,
-                    T("I'm sorry, but %s wishes to be left alone now."),
-                    Name(who));
+    if (!okay_pemit(player, who, 1,
+                    tprintf(T("I'm sorry, but %s wishes to be left alone now."),
+                            Name(who))))
       return;
-    }
     if (!silent)
       notify_format(player, T("You pemit \"%s\" to %s."), arg2, Name(who));
     if (nospoof && Nospoof(who)) {
@@ -837,7 +856,29 @@
       return;
     }
     if (!message || !*message) {
-      notify_format(player, T("You last paged %s."), head);
+      start = (const char **) &head;
+      while (head && *head) {
+        current = next_in_list(start);
+        if (is_objid(current))
+          target = parse_objid(current);
+        else
+          target = lookup_player(current);
+        if (RealGoodObject(target)) {
+          good[gcount] = target;
+          gcount++;
+        }
+      }
+      if (!gcount) {
+        notify(player, T("I can't find who you last paged."));
+      } else {
+        for (repage = 1; repage <= gcount; repage++) {
+          safe_itemizer(repage, (repage == gcount), ",", T("and"), " ", tbuf2,
+                        &tp2);
+          safe_str(Name(good[repage - 1]), tbuf2, &tp2);
+        }
+        *tp2 = '\0';
+        notify_format(player, T("You last paged %s."), tbuf2);
+      }
       mush_free(tbuf2, "page_buff");
       mush_free(namebuf, "page_buff");
       if (hp)
@@ -883,7 +924,7 @@
         if (fails_lock)
           fail_lock(player, target, Page_Lock, NULL, NOTHING);
         safe_chr(' ', tbuf, &tp);
-        safe_str_space(current, tbuf, &tp);
+        safe_str_space(Name(target), tbuf, &tp);
       } else if (is_haven) {
         page_return(player, target, "Haven", "HAVEN",
                     tprintf(T("%s is not accepting any pages."), Name(target)));
@@ -982,13 +1023,15 @@
 
   /* namebuf is used to hold a fancy formatted list of names,
    * with commas and the word 'and' , if needed. */
-  /* tbuf holds a space-separated list of names for repaging */
+  /* tbuf holds a space-separated list of objids for repaging */
 
   /* Set up a pretty formatted list. */
   for (i = 0; i < gcount; i++) {
     if (i)
       safe_chr(' ', tbuf, &tp);
-    safe_str_space(Name(good[i]), tbuf, &tp);
+    safe_dbref(good[i], tbuf, &tp);
+    safe_chr(':', tbuf, &tp);
+    safe_integer(CreTime(good[i]), tbuf, &tp);
     safe_itemizer(i + 1, (i == gcount - 1), ",", T("and"), " ", namebuf, &nbp);
     safe_str(Name(good[i]), namebuf, &nbp);
   }
@@ -1073,6 +1116,11 @@
     }
 
     page_return(player, good[i], "Idle", "IDLE", NULL);
+    if (!okay_pemit(good[i], player, 0, NULL)) {
+      notify_format(player,
+                    T("You paged %s, but they are unable to page you."),
+                    Name(good[i]));
+    }
   }
 
   mush_free(tbuf, "page_buff");
@@ -1378,10 +1426,11 @@
   } else {
     if (IsExit(room)) {
       notify(player, T("There can't be anything in that!"));
-    } else if (!okay_pemit(player, room)) {
-      notify_format(player,
-                    T("I'm sorry, but %s wishes to be left alone now."),
-                    Name(room));
+    } else if (!okay_pemit(player, room, 1,
+                           tprintf(T
+                                   ("I'm sorry, but %s wishes to be left alone now."),
+                                   Name(room)))) {
+      /* Do nothing, but do it well */
     } else if (!Loud(player) && !eval_lock(player, room, Speech_Lock)) {
       fail_lock(player, room, Speech_Lock, T("You may not speak there!"),
                 NOTHING);
@@ -1498,7 +1547,7 @@
  * \param player the enactor.
  * \param arg1 string containing dbref of ZMO.
  * \param arg2 message to emit.
- * \param flags bitmask of notificati flags.
+ * \param flags bitmask of notification flags.
  */
 void
 do_zemit(dbref player, const char *arg1, const char *arg2, int flags)
@@ -1518,8 +1567,10 @@
     return;
   }
 
-  where = unparse_object(player, zone);
-  notify_format(player, T("You zemit, \"%s\" in zone %s"), arg2, where);
+  if (!(flags & PEMIT_SILENT)) {
+    where = unparse_object(player, zone);
+    notify_format(player, T("You zemit, \"%s\" in zone %s"), arg2, where);
+  }
 
   pass[0] = NOTHING;
   pass[1] = 0;
Index: src/chunk.c
===================================================================
--- src/chunk.c	(.../184p2)	(revision 828)
+++ src/chunk.c	(.../184p3)	(revision 828)
@@ -757,10 +757,8 @@
   va_end(args);
 
   rolling_log[rolling_pos][ROLLING_LOG_ENTRY_LEN - 1] = '\0';
-  if (noisy_log) {
-    fprintf(tracelog_fp, "%s\n", rolling_log[rolling_pos]);
-    fflush(tracelog_fp);
-  }
+  if (noisy_log)
+    do_rawlog(LT_TRACE, "%s\n", rolling_log[rolling_pos]);
   rolling_pos = (rolling_pos + 1) % ROLLING_LOG_SIZE;
 #else
   if (format)
@@ -1040,7 +1038,7 @@
     result = 0;
   }
   if (dump) {
-    debug_dump_region(region, tracelog_fp);
+    debug_dump_region(region, lookup_log(LT_TRACE)->fp);
   }
   return result;
 }
@@ -2107,12 +2105,14 @@
 
 #ifdef CHUNK_PARANOID
   if (!region_is_valid(region)) {
+    struct log_stream *trace;
     do_rawlog(LT_TRACE, "Invalid region after migrate_slide!");
     do_rawlog(LT_TRACE, "Was moving %04x%04x to %04x%04x (became %08x)...",
               region, o_oth, region, o_off, m_references[which][0]);
     do_rawlog(LT_TRACE, "Chunk length %04x into hole length %04x", o_len, len);
-    debug_dump_region(region, tracelog_fp);
-    dump_debug_log(tracelog_fp);
+    trace = lookup_log(LT_TRACE);
+    debug_dump_region(region, trace->fp);
+    dump_debug_log(trace->fp);
     mush_panic("Invalid region after migrate_slide!");
   }
 #endif
@@ -2154,7 +2154,7 @@
   }
 #ifdef CHUNK_PARANOID
   if (!FitsInSpace(s_len, ChunkFullLen(region, offset))) {
-    dump_debug_log(tracelog_fp);
+    dump_debug_log(lookup_log(LT_TRACE)->fp);
     mush_panicf("Trying to migrate into too small a hole: %04x into %04x!",
                 s_len, length);
   }
@@ -2180,7 +2180,7 @@
               s_reg, s_off, region, o_off, region, offset);
     do_rawlog(LT_TRACE, "Chunk length %04x into hole length %04x, alignment %d",
               s_len, length, align);
-    debug_dump_region(region, tracelog_fp);
+    debug_dump_region(region, lookup_log(LT_TRACE)->fp);
     mush_panic("Invalid region after migrate_move!");
   }
 #endif
Index: src/boolexp.c
===================================================================
--- src/boolexp.c	(.../184p2)	(revision 828)
+++ src/boolexp.c	(.../184p3)	(revision 828)
@@ -188,6 +188,7 @@
   OP_TEVAL, /**< Tests S/ARG */
   OP_TFLAG, /**< Tests FLAG^ARG */
   OP_TTYPE, /**< Tests TYPE^ARG */
+  OP_TNAME, /**< Tests name == ARG */
   OP_TPOWER, /**< Tests POWER^ARG */
   OP_TCHANNEL, /**< Tests CHANNEL^ARG */
   OP_TIP, /**< Tests IP^ARG */
@@ -248,6 +249,7 @@
   {"FLAG", OP_TFLAG},
   {"POWER", OP_TPOWER},
   {"TYPE", OP_TTYPE},
+  {"NAME", OP_TNAME},
   {"CHANNEL", OP_TCHANNEL},
   {"OBJID", OP_TOBJID},
   {"IP", OP_TIP},
@@ -510,6 +512,12 @@
         r = check_attrib_lock(player, target, s, (char *) bytecode + arg);
         boolexp_recursion--;
         break;
+      case OP_TNAME:
+        boolexp_recursion++;
+        r = quick_wild((char *) bytecode + arg, Name(player)) ||
+          match_aliases(player, (char *) bytecode + arg);
+        boolexp_recursion--;
+        break;
       case OP_TFLAG:
         /* Note that both fields of a boolattr struct are upper-cased */
         if (sees_flag("FLAG", target, player, (char *) bytecode + arg))
@@ -759,6 +767,9 @@
       case OP_TEVAL:
         safe_format(boolexp_buf, &buftop, "%s/%s", s, bytecode + arg);
         break;
+      case OP_TNAME:
+        safe_format(boolexp_buf, &buftop, "NAME^%s", bytecode + arg);
+        break;
       case OP_TFLAG:
         safe_format(boolexp_buf, &buftop, "FLAG^%s", bytecode + arg);
         break;
@@ -1703,6 +1714,7 @@
     case OP_TEVAL:
     case OP_TATR:
     case OP_TFLAG:
+    case OP_TNAME:
     case OP_TPOWER:
     case OP_TOBJID:
     case OP_TTYPE:
@@ -1948,6 +1960,9 @@
     case OP_TEVAL:
       printf("TEVAL \"%s\"\n", bytecode + arg);
       break;
+    case OP_TNAME:
+      printf("NAME \"%s\"\n", bytecode + arg);
+      break;
     case OP_TFLAG:
       printf("TFLAG \"%s\"\n", bytecode + arg);
       break;
Index: src/bsd.c
===================================================================
--- src/bsd.c	(.../184p2)	(revision 828)
+++ src/bsd.c	(.../184p3)	(revision 828)
@@ -157,8 +157,7 @@
 #endif
 int que_next(void);             /* from cque.c */
 
-void dispatch(void);            /* from timer.c */
-dbref email_register_player(const char *name, const char *email, const char *host, const char *ip);     /* from player.c */
+dbref email_register_player(DESC *d, const char *name, const char *email, const char *host, const char *ip);    /* from player.c */
 
 #ifdef SUN_OS
 static int extrafd;
@@ -291,7 +290,7 @@
 extern const unsigned char *tables;
 
 sig_atomic_t signal_shutdown_flag = 0;  /**< Have we caught a shutdown signal? */
-sig_atomic_t signal_dump_flag = 0;      /**< Have we caught a dump signal? */
+sig_atomic_t usr2_triggered = 0;        /**< Have we caught a USR2 signal? */
 
 #ifndef BOOLEXP_DEBUGGING
 #ifdef WIN32SERVICES
@@ -348,7 +347,7 @@
                             const unsigned char *prefix);
 static int fcache_read(FBLOCK *cp, const char *filename);
 static void logout_sock(DESC *d);
-static void shutdownsock(DESC *d);
+static void shutdownsock(DESC *d, const char *reason);
 DESC *initializesock(int s, char *addr, char *ip, int use_ssl);
 int process_output(DESC *d);
 /* Notify.c */
@@ -393,8 +392,8 @@
 static const char *time_format_1(time_t dt);
 static const char *time_format_2(time_t dt);
 static void announce_connect(DESC *d, int isnew, int num);
-static void announce_disconnect(DESC *saved);
-void inactivity_check(void);
+static void announce_disconnect(DESC *saved, const char *reason);
+bool inactivity_check(void);
 void reopen_logs(void);
 void load_reboot_db(void);
 
@@ -624,6 +623,8 @@
     load_reboot_db();
   }
 
+  init_sys_events();
+
   shovechars((Port_t) TINYPORT, (Port_t) SSLPORT);
 
   /* someone has told us to shut down */
@@ -935,16 +936,24 @@
       if (WIFSIGNALED(dump_status)) {
         do_rawlog(LT_ERR, "ERROR! forking dump exited with signal %d",
                   WTERMSIG(dump_status));
+        queue_event(SYSEVENT, "DUMP`ERROR", "%s,%d,SIGNAL %d",
+                    T("GAME: ERROR! Forking database save failed!"),
+                    1, dump_status);
         flag_broadcast("ROYALTY WIZARD", 0,
                        T("GAME: ERROR! Forking database save failed!"));
       } else if (WIFEXITED(dump_status)) {
         if (WEXITSTATUS(dump_status) == 0) {
           time(&globals.last_dump_time);
+          queue_event(SYSEVENT, "DUMP`COMPLETE", "%s,%d",
+                      DUMP_NOFORK_COMPLETE, 1);
           if (DUMP_NOFORK_COMPLETE && *DUMP_NOFORK_COMPLETE)
             flag_broadcast(0, 0, "%s", DUMP_NOFORK_COMPLETE);
         } else {
           do_rawlog(LT_ERR, "ERROR! forking dump exited with exit code %d",
                     WEXITSTATUS(dump_status));
+          queue_event(SYSEVENT, "DUMP`ERROR", "%s,%d,EXIT %d",
+                      T("GAME: ERROR! Forking database save failed!"),
+                      1, dump_status);
           flag_broadcast("ROYALTY WIZARD", 0,
                          T("GAME: ERROR! Forking database save failed!"));
         }
@@ -968,18 +977,20 @@
       shutdown_flag = 1;
     }
 
-    if (signal_dump_flag) {
-      globals.paranoid_dump = 0;
-      do_rawlog(LT_CHECK, "DUMP by external signal");
-      fork_and_dump(1);
-      signal_dump_flag = 0;
+    if (usr2_triggered) {
+      if (!queue_event(SYSEVENT, "SIGNAL`USR2", "%s", "")) {
+        globals.paranoid_dump = 0;
+        do_rawlog(LT_CHECK, "DUMP by external signal");
+        fork_and_dump(1);
+      }
+      usr2_triggered = 0;
     }
 
     if (shutdown_flag)
       break;
 
     /* test for events */
-    dispatch();
+    sq_run_all();
 
     /* any queued robot commands waiting? */
     /* timeout.tv_sec used to be set to que_next(), the number of
@@ -1115,13 +1126,13 @@
         output_ready = FD_ISSET(d->descriptor, &output_set);
         if (input_ready) {
           if (!process_input(d, output_ready)) {
-            shutdownsock(d);
+            shutdownsock(d, "disconnect");
             continue;
           }
         }
         if (output_ready) {
           if (!process_output(d)) {
-            shutdownsock(d);
+            shutdownsock(d, "disconnect");
           }
         }
       }
@@ -1251,12 +1262,8 @@
   global_eval_context.wenv[0] = arg;
   sp = save = safe_atr_value(a);
   bp = buff;
-  // A disconnected descriptor has dbref of 0. Not right at all, but ...
-  // Nothing to do about it?
   process_expression(buff, &bp, &sp,
-                     thing,
-                     d->player ? d->player : -1,
-                     d->player ? d->player : -1, PE_DEFAULT, PT_DEFAULT, NULL);
+                     thing, d->player, d->player, PE_DEFAULT, PT_DEFAULT, NULL);
   safe_chr('\n', buff, &bp);
   *bp = '\0';
   free((void *) save);
@@ -1483,7 +1490,7 @@
     do_rawlog(LT_CONN,
               "[%d/%s/%s] Logout by %s(#%d) <Connection not dropped>",
               d->descriptor, d->addr, d->ip, Name(d->player), d->player);
-    announce_disconnect(d);
+    announce_disconnect(d, "logout");
     if (can_mail(d->player)) {
       do_mail_purge(d->player);
     }
@@ -1508,7 +1515,7 @@
   d->output_suffix = 0;
   d->output_size = 0;
   d->output.head = 0;
-  d->player = 0;
+  d->player = NOTHING;
   d->output.tail = &d->output.head;
   d->input.head = 0;
   d->input.tail = &d->input.head;
@@ -1528,7 +1535,7 @@
  * \param d pointer to descriptor to disconnect.
  */
 static void
-shutdownsock(DESC *d)
+shutdownsock(DESC *d, const char *reason)
 {
   if (d->connected) {
     do_rawlog(LT_CONN, "[%d/%s/%s] Logout by %s(#%d)",
@@ -1536,7 +1543,7 @@
     if (d->connected != 2) {
       fcache_dump(d, fcache.quit_fcache, NULL);
       /* Player was not allowed to log in from the connect screen */
-      announce_disconnect(d);
+      announce_disconnect(d, reason);
       if (can_mail(d->player)) {
         do_mail_purge(d->player);
       }
@@ -1554,6 +1561,10 @@
     do_rawlog(LT_CONN, "[%d/%s/%s] Connection closed, never connected.",
               d->descriptor, d->addr, d->ip);
   }
+  /* (descriptor, ip, cause, recv/sent/cmds) */
+  queue_event(SYSEVENT, "SOCKET`DISCONNECT", "%d,%s,%s,%lu/%lu/%d",
+              d->descriptor, d->ip,
+              reason, d->input_chars, d->output_chars, d->cmds);
   process_output(d);
   clearstrings(d);
   shutdown(d->descriptor, 2);
@@ -1600,7 +1611,7 @@
   d->output_suffix = 0;
   d->output_size = 0;
   d->output.head = 0;
-  d->player = 0;
+  d->player = NOTHING;
   d->output.tail = &d->output.head;
   d->input.head = 0;
   d->input.tail = &d->input.head;
@@ -1644,6 +1655,7 @@
 #endif
   im_insert(descs_by_fd, d->descriptor, d);
   welcome_user(d, 1);
+  queue_event(SYSEVENT, "SOCKET`CONNECT", "%d,%s", d->descriptor, d->ip);
   return d;
 }
 
@@ -2289,7 +2301,11 @@
         retval = do_command(cdesc, (char *) t->start);
         reset_cpu_timer();
         if (retval == 0) {
-          shutdownsock(cdesc);
+          shutdownsock(cdesc, "quit");
+        } else if (retval == -3) {
+          shutdownsock(cdesc, "http disconnect");
+        } else if (retval == -2) {
+          shutdownsock(cdesc, "sitelocked");
         } else if (retval == -1) {
           logout_sock(cdesc);
         } else {
@@ -2407,14 +2423,15 @@
                  "</BODY></HEAD>", MUDNAME, MUDURL, MUDURL, MUDURL, MUDNAME);
         queue_write(d, (unsigned char *) buf, strlen(buf));
         queue_eol(d);
-        return 0;
+        return -3;
       }
       if (j) {
         send_prefix(d);
         dump_users(d, command + j);
         send_suffix(d);
-      } else if (!check_connect(d, command))
-        return 0;
+      } else if (!check_connect(d, command)) {
+        return -2;
+      }
     }
   }
   return 1;
@@ -2529,9 +2546,13 @@
 
   parse_connect(msg, command, user, password);
 
+  if (!check_fails(d->ip)) {
+    queue_string_eol(d, T(connect_fail_limit_exceeded));
+    return 1;
+  }
   if (string_prefix("connect", command)) {
-    if ((player =
-         connect_player(user, password, d->addr, d->ip, errbuf)) == NOTHING) {
+    if ((player = connect_player(d, user, password, d->addr, d->ip, errbuf))
+        == NOTHING) {
       queue_string_eol(d, errbuf);
       do_rawlog(LT_CONN, "[%d/%s/%s] Failed connect to '%s'.",
                 d->descriptor, d->addr, d->ip, user);
@@ -2546,8 +2567,8 @@
     }
 
   } else if (!strcasecmp(command, "cd")) {
-    if ((player =
-         connect_player(user, password, d->addr, d->ip, errbuf)) == NOTHING) {
+    if ((player = connect_player(d, user, password, d->addr, d->ip, errbuf))
+        == NOTHING) {
       queue_string_eol(d, errbuf);
       do_rawlog(LT_CONN, "[%d/%s/%s] Failed connect to '%s'.",
                 d->descriptor, d->addr, d->ip, user);
@@ -2569,8 +2590,8 @@
     }
 
   } else if (!strcasecmp(command, "cv")) {
-    if ((player =
-         connect_player(user, password, d->addr, d->ip, errbuf)) == NOTHING) {
+    if ((player = connect_player(d, user, password, d->addr, d->ip, errbuf))
+        == NOTHING) {
       queue_string_eol(d, errbuf);
       do_rawlog(LT_CONN, "[%d/%s/%s] Failed connect to '%s'.",
                 d->descriptor, d->addr, d->ip, user);
@@ -2589,8 +2610,8 @@
     }
 
   } else if (!strcasecmp(command, "ch")) {
-    if ((player =
-         connect_player(user, password, d->addr, d->ip, errbuf)) == NOTHING) {
+    if ((player = connect_player(d, user, password, d->addr, d->ip, errbuf))
+        == NOTHING) {
       queue_string_eol(d, errbuf);
       do_rawlog(LT_CONN, "[%d/%s/%s] Failed connect to '%s'.",
                 d->descriptor, d->addr, d->ip, user);
@@ -2617,6 +2638,9 @@
           && !Deny_Silent_Site(d->ip, AMBIGUOUS)) {
         do_rawlog(LT_CONN, "[%d/%s/%s] Refused create for '%s'.",
                   d->descriptor, d->addr, d->ip, user);
+        queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                    d->descriptor, d->ip, count_failed(d->ip),
+                    "create: sitelocked !create", user);
       }
       return 0;
     }
@@ -2628,15 +2652,21 @@
       do_rawlog(LT_CONN,
                 "REFUSED CREATION for %s from %s on descriptor %d.\n",
                 user, d->addr, d->descriptor);
+      queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                  d->descriptor, d->ip, count_failed(d->ip),
+                  "create: creation not allowed", user);
       return 0;
     } else if (MAX_LOGINS && !under_limit) {
       fcache_dump(d, fcache.full_fcache, NULL);
       do_rawlog(LT_CONN,
                 "REFUSED CREATION for %s from %s on descriptor %d.\n",
                 user, d->addr, d->descriptor);
+      queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                  d->descriptor, d->ip, count_failed(d->ip),
+                  "create: max login count reached", user);
       return 0;
     }
-    player = create_player(user, password, d->addr, d->ip);
+    player = create_player(d, user, password, d->addr, d->ip);
     if (player == NOTHING) {
       queue_string_eol(d, T(create_fail));
       do_rawlog(LT_CONN,
@@ -2648,6 +2678,8 @@
                 "[%d/%s/%s] Failed create for '%s' (bad password).",
                 d->descriptor, d->addr, d->ip, user);
     } else {
+      queue_event(SYSEVENT, "PLAYER`CREATE", "%s,%s,%s,%d",
+                  unparse_objid(player), Name(player), "create", d->descriptor);
       do_rawlog(LT_CONN, "[%d/%s/%s] Created %s(#%d)",
                 d->descriptor, d->addr, d->ip, Name(player), player);
       if ((dump_messages(d, player, 1)) == 0) {
@@ -2664,6 +2696,9 @@
         do_rawlog(LT_CONN,
                   "[%d/%s/%s] Refused registration (bad site) for '%s'.",
                   d->descriptor, d->addr, d->ip, user);
+        queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                    d->descriptor, d->ip, mark_failed(d->ip),
+                    "register: sitelocked host or ip", user);
       }
       return 0;
     }
@@ -2672,9 +2707,12 @@
       do_rawlog(LT_CONN,
                 "Refused registration (creation disabled) for %s from %s on descriptor %d.\n",
                 user, d->addr, d->descriptor);
+      queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                  d->descriptor, d->ip, mark_failed(d->ip),
+                  "register: registration disabled", user);
       return 0;
     }
-    if ((player = email_register_player(user, password, d->addr, d->ip)) ==
+    if ((player = email_register_player(d, user, password, d->addr, d->ip)) ==
         NOTHING) {
       queue_string_eol(d, T(register_fail));
       do_rawlog(LT_CONN, "[%d/%s/%s] Failed registration for '%s'.",
@@ -2813,7 +2851,7 @@
 
   DESC_ITER_CONN(d) {
     if (boot) {
-      boot_desc(boot);
+      boot_desc(boot, "boot");
       boot = NULL;
     }
     if (d->player == player
@@ -2825,7 +2863,7 @@
     }
   }
   if (boot)
-    boot_desc(boot);
+    boot_desc(boot, "boot");
   if (count && idleonly) {
     if (count == 1)
       notify(player, T("You boot an idle self."));
@@ -2841,9 +2879,9 @@
  * \param d pointer to descriptor to disconnect.
  */
 void
-boot_desc(DESC *d)
+boot_desc(DESC *d, const char *cause)
 {
-  shutdownsock(d);
+  shutdownsock(d, cause);
 }
 
 /** Given a player dbref, return the player's first connected descriptor.
@@ -3075,7 +3113,7 @@
 void
 signal_dump(int sig __attribute__ ((__unused__)))
 {
-  signal_dump_flag = 1;
+  usr2_triggered = 1;
   reload_sig_handler(SIGUSR2, signal_dump);
 }
 #endif
@@ -3278,10 +3316,6 @@
   char tbuf1[BUFFER_LEN];
   char tbuf2[BUFFER_LEN];
 
-  if (!GoodObject(call_by->player)) {
-    do_rawlog(LT_ERR, "Bogus caller #%d of dump_users", call_by->player);
-    return;
-  }
   while (*match && *match == ' ')
     match++;
   now = mudtime;
@@ -3306,8 +3340,7 @@
 
     sprintf(tbuf1, "%-16s %10s   %4s%c %s", Name(d->player),
             time_format_1(now - d->connected_at),
-            time_format_2(now - d->last_time),
-            (Dark(d->player) ? 'D' : (Hidden(d) ? 'H' : ' '))
+            time_format_2(now - d->last_time), (Dark(d->player) ? 'D' : ' ')
             , d->doing);
     queue_string_eol(call_by, tbuf1);
   }
@@ -3408,7 +3441,8 @@
     if (d->connected)
       count++;
     if ((name && *name)
-        && (!d->connected || !string_prefix(Name(d->player), name)))
+        && (!d->connected || !GoodObject(d->player)
+            || !string_prefix(Name(d->player), name)))
       continue;
     if (d->connected) {
       sprintf(tbuf, "%-16s %6s %9s %5s  %4d %3d%c %s", Name(d->player),
@@ -3489,7 +3523,8 @@
     if (d->connected)
       count++;
     if ((name && *name)
-        && (!d->connected || !string_prefix(Name(d->player), name)))
+        && (!d->connected || !GoodObject(d->player)
+            || !string_prefix(Name(d->player), name)))
       continue;
     if (d->connected) {
       notify_format(player, "%-16s %6s %9s %5s %5d %3d%c %7lu %7lu %7d",
@@ -3576,7 +3611,7 @@
 }
 
 /* connection messages
- * isnew: newly creaetd or not?
+ * isnew: newly created or not?
  * num: how many times connected?
  */
 static void
@@ -3658,6 +3693,9 @@
   for (j = 0; j < NUMQ; j++)
     global_eval_context.rnxt[j] = NULL;
   strcpy(global_eval_context.ccom, "");
+
+  queue_event(player, "PLAYER`CONNECT", "%s,%d,%d",
+              unparse_objid(player), num, d->descriptor);
   /* And then load it up, as follows:
    * %0 (unused, reserved for "reason for disconnect")
    * %1 (number of connections after connect)
@@ -3706,7 +3744,7 @@
 }
 
 static void
-announce_disconnect(DESC *saved)
+announce_disconnect(DESC *saved, const char *reason)
 {
   dbref loc;
   int num;
@@ -3755,6 +3793,21 @@
     global_eval_context.wnxt[j] = myenv[j];
   }
 
+  /* Eww. Unwieldy.
+   * (objid, count, hidden, cause, ip, descriptor, conn,
+   * idle, recv/sent/commands)  */
+  queue_event(player, "PLAYER`DISCONNECT",
+              "%s,%d,%d,%s,%s,%d,%d,%d,%lu/%lu/%d",
+              unparse_objid(player),
+              num - 1,
+              Hidden(saved),
+              reason,
+              saved->ip,
+              saved->descriptor,
+              (int) difftime(mudtime, saved->connected_at),
+              (int) difftime(mudtime, saved->last_time),
+              saved->input_chars, saved->output_chars, saved->cmds);
+
   (void) queue_attribute(player, "ADISCONNECT", player);
   if (ROOM_CONNECTS)
     if (IsRoom(loc) || IsThing(loc)) {
@@ -4245,7 +4298,7 @@
     int fd = parse_integer(name);
 
     d = im_find(descs_by_fd, fd);
-    if (d && (Priv_Who(executor) || d->player == executor))
+    if (d && (Priv_Who(executor) || (d->connected && d->player == executor)))
       return d;
     else
       return NULL;
@@ -4431,6 +4484,8 @@
 
   if (!GoodObject(zone)
       || (!Priv_Who(executor) && !eval_lock(victim, zone, Zone_Lock))) {
+    if (GoodObject(zone))
+      fail_lock(victim, zone, Zone_Lock, NULL, NOTHING);
     safe_str(T(e_perm), buff, bp);
     return;
   }
@@ -4757,11 +4812,12 @@
 }
 
 
-/** Hide or unhide a player.
+/** Hide or unhide the specified descriptor/player.
  * Although hiding is a per-descriptor state, this function sets all of
  * a player's connected descriptors to be hidden.
- * \param player dbref of player to hide.
- * \param hide if 1, hide; if 0, unhide.
+ * \param player dbref of player using command.
+ * \param hide if 1, hide; if 0, unhide. If 2, unhide if all connections are hidden, hide if any are unhidden
+ * \param victim descriptor, or name of player, to hide (or NULL to hide enacting player)
  */
 void
 hide_player(dbref player, int hide, char *victim)
@@ -4794,6 +4850,8 @@
         notify(player, T("Noone is connected to that descriptor."));
         return;
       }
+      if (hide == 2)
+        hide = !(d->hide);
       d->hide = hide;
       if (hide) {
         notify(player, T("Connection hidden."));
@@ -4815,6 +4873,17 @@
     notify(player, T("That player is not online."));
     return;
   }
+
+  if (hide == 2) {
+    hide = 0;
+    DESC_ITER_CONN(d) {
+      if (d->player == thing && !d->hide) {
+        hide = 1;
+        break;
+      }
+    }
+  }
+
   DESC_ITER_CONN(d) {
     if (d->player == thing)
       d->hide = hide;
@@ -4835,13 +4904,15 @@
 
 /** Perform the periodic check of inactive descriptors, and
  * disconnect them or autohide them as appropriate.
+ * \return true if any players were booted/autohidden.
  */
-void
+bool
 inactivity_check(void)
 {
   DESC *d, *nextd;
   time_t now;
   int idle, idle_for, unconnected_idle;
+  bool booted = false;
 
   now = mudtime;
   idle = INACTIVITY_LIMIT ? INACTIVITY_LIMIT : INT_MAX;
@@ -4858,7 +4929,7 @@
 
     /* If they've been idle for 60 seconds and are set KEEPALIVE and using
        a telnet-aware client, send a NOP */
-    if (d->conn_flags & CONN_TELNET && idle_for >= 60
+    if (d->connected && d->conn_flags & CONN_TELNET && idle_for >= 60
         && IS(d->player, TYPE_PLAYER, "KEEPALIVE")) {
       const uint8_t nopmsg[2] = { IAC, NOP };
       queue_newwrite(d, nopmsg, 2);
@@ -4867,15 +4938,17 @@
 
     if ((d->connected) ? (idle_for > idle) : (idle_for > unconnected_idle)) {
 
-      if (!d->connected)
-        shutdownsock(d);
-      else if (!Can_Idle(d->player)) {
+      if (!d->connected) {
+        shutdownsock(d, "idle");
+        booted = true;
+      } else if (!Can_Idle(d->player)) {
 
         queue_string(d, T("\n*** Inactivity timeout ***\n"));
         do_rawlog(LT_CONN,
                   "[%d/%s/%s] Logout by %s(#%d) <Inactivity Timeout>",
                   d->descriptor, d->addr, d->ip, Name(d->player), d->player);
-        boot_desc(d);
+        boot_desc(d, "idle");
+        booted = true;
       } else if (Unfind(d->player)) {
 
         if ((Can_Hide(d->player)) && (!Hidden(d))) {
@@ -4883,10 +4956,12 @@
                        T
                        ("\n*** Inactivity limit reached. You are now HIDDEN. ***\n"));
           d->hide = 1;
+          booted = true;
         }
       }
     }
   }
+  return booted;
 }
 
 
@@ -5197,12 +5272,11 @@
       d->prev = NULL;
       descriptor_list = d;
       im_insert(descs_by_fd, d->descriptor, d);
-      if (d->connected && d->player && GoodObject(d->player) &&
-          IsPlayer(d->player))
+      if (d->connected && GoodObject(d->player) && IsPlayer(d->player))
         set_flag_internal(d->player, "CONNECTED");
       else if ((!d->player || !GoodObject(d->player)) && d->connected) {
         d->connected = 0;
-        d->player = 0;
+        d->player = NOTHING;
       }
     }
   }                             /* while loop */
@@ -5210,7 +5284,7 @@
   /* Now announce disconnects of everyone who's not really here */
   while (closed) {
     nextclosed = closed->next;
-    announce_disconnect(closed);
+    announce_disconnect(closed, "disconnect");
     mush_free(closed->ttype, "terminal description");
     mush_free(closed, "descriptor");
     closed = nextclosed;
Index: src/SWITCHES
===================================================================
--- src/SWITCHES	(.../184p2)	(revision 828)
+++ src/SWITCHES	(.../184p3)	(revision 828)
@@ -18,6 +18,7 @@
 CLEAR
 CLONE
 CMD
+COLNAMES
 COMBINE
 COMMANDS
 CONN
@@ -62,10 +63,12 @@
 HIDE
 IGNORE
 ILIST
+INPLACE
 INSIDE
 INVENTORY
 IPRINT
 JOIN
+LEAVE
 LETTER
 LIST
 LIMIT
@@ -99,6 +102,7 @@
 PANIC
 PARANOID
 PARENT
+PLAYER
 PLAYERS
 PORT
 POWERS
Index: src/funstr.c
===================================================================
--- src/funstr.c	(.../184p2)	(revision 828)
+++ src/funstr.c	(.../184p3)	(revision 828)
@@ -453,12 +453,14 @@
   free_ansi_string(src);
 }
 
+extern int sort_order; /* from sort.c */
+
 static int
 comp_gencomp(dbref executor, char *left, char *right, char *type)
 {
   int c;
   c = gencomp(executor, left, right, type);
-  return (c > 0 ? 1 : (c < 0 ? -1 : 0));
+  return (c > 0 ? 1 : (c < 0 ? -1 : 0)) * sort_order;
 }
 
 /* ARGSUSED */
@@ -574,7 +576,7 @@
 
     if (matches) {
       /* Now, assign the captures, if we have returns. */
-      nqregs = list2arr(qregs, NUMQ, args[2], ' ');
+      nqregs = list2arr(qregs, NUMQ, args[2], ' ', 0);
 
       for (i = 0; i < nqregs; i++) {
         if (ret[i] && qregs[i][0] && !qregs[i][1]) {
@@ -1243,35 +1245,36 @@
    * takes a delimiter argument and trim style.
    */
 
-  char sep;
+
   enum trim_style { TRIM_LEFT, TRIM_RIGHT, TRIM_BOTH } trim;
   int trim_style_arg, trim_char_arg;
   ansi_string *as;
   int i;
+  char *delims;
+  char totrim[0x100];
+
+  memset(totrim, 0, 0x100);
 
   /* Alas, PennMUSH and TinyMUSH used different orders for the arguments.
    * We'll give the users an option about it
    */
   if (!strcmp(called_as, "TRIMTINY")) {
-    trim_style_arg = 2;
-    trim_char_arg = 3;
-  } else if (!strcmp(called_as, "TRIMPENN")) {
-    trim_style_arg = 3;
+    trim_style_arg = 1;
     trim_char_arg = 2;
-  } else if (TINY_TRIM_FUN) {
+  } else if (!strcmp(called_as, "TRIMPENN")) {
     trim_style_arg = 2;
-    trim_char_arg = 3;
-  } else {
-    trim_style_arg = 3;
+    trim_char_arg = 1;
+  } else if (TINY_TRIM_FUN) {
+    trim_style_arg = 1;
     trim_char_arg = 2;
+  } else {
+    trim_style_arg = 2;
+    trim_char_arg = 1;
   }
 
-  if (!delim_check(buff, bp, nargs, args, trim_char_arg, &sep))
-    return;
-
   /* If a trim style is provided, it must be the third argument. */
-  if (nargs >= trim_style_arg) {
-    switch (*args[trim_style_arg - 1]) {
+  if (nargs > trim_style_arg) {
+    switch (*args[trim_style_arg]) {
     case 'l':
     case 'L':
       trim = TRIM_LEFT;
@@ -1287,6 +1290,16 @@
   } else
     trim = TRIM_BOTH;
 
+  if (nargs > trim_char_arg && args[trim_char_arg] && *args[trim_char_arg]) {
+    delims = args[trim_char_arg];
+    while (*delims) {
+      totrim[(unsigned char) *delims] = 1;
+      delims++;
+    }
+  } else {
+    totrim[(unsigned char) ' '] = 1;
+  }
+
   /* We will never need to check for buffer length overrunning, since
    * we will always get a smaller string. Thus, we can copy at the
    * same time we skip stuff.
@@ -1296,7 +1309,7 @@
   as = parse_ansi_string(args[0]);
   if (trim != TRIM_RIGHT) {
     for (i = 0; i < as->len; i++) {
-      if (as->text[i] != sep)
+      if (!totrim[(unsigned char) as->text[i]])
         break;
       as->text[i] = '\0';
     }
@@ -1304,7 +1317,7 @@
   /* Cut off the trailing stuff, if appropriate. */
   if ((trim != TRIM_LEFT)) {
     for (i = as->len - 1; i >= 0; i--) {
-      if (as->text[i] != sep)
+      if (!totrim[(unsigned char) as->text[i]])
         break;
       as->text[i] = '\0';
     }
@@ -1668,12 +1681,14 @@
 #define AL_LEFT 1    /**< Align left */
 #define AL_RIGHT 2   /**< Align right */
 #define AL_CENTER 3  /**< Align center */
-#define AL_FULL 4  /**< Fully-justify */
-#define AL_WPFULL 5  /**< Fully-justify */
+#define AL_FULL 4    /**< Full justify */
+#define AL_WPFULL 5  /**< Paragraph full-justify */
+#define AL_TYPE 0x0F /**< Only the bottom 4 bits are used for the type. */
 /* Flags */
 #define AL_REPEAT 0x100  /**< Repeat column */
 #define AL_COALESCE_LEFT 0x200  /**< Coalesce empty column with column to left */
 #define AL_COALESCE_RIGHT 0x400  /**< Coalesce empty column with column to right */
+#define AL_NOFILL 0x800  /**< No filler on the right of this. */
 
 static int
 align_one_line(char *buff, char **bp, int ncols,
@@ -1715,6 +1730,10 @@
       /* To coalesce left on this line, modify the left column's
        * width and set the current column width to 0 (which we can
        * teach it to skip). */
+      /* If the next column is marked NOFILL, we inherit that. */
+      if (calign[i + 1] & AL_NOFILL) {
+        calign[i] |= AL_NOFILL;
+      }
       cols[i] += cols[i + 1] + fslen;
       cols[i + 1] = 0;
     }
@@ -1737,7 +1756,9 @@
         cols_done++;
         continue;
       } else {
-        lp += cols[i];
+        if (!(calign[i] & AL_NOFILL)) {
+          lp += cols[i];
+        }
         if (i < (ncols - 1) && fslen)
           safe_str(fieldsep, line, &lp);
         cols_done++;
@@ -1793,13 +1814,13 @@
     if (HAS_ANSI(adata[i])) {
       write_ansi_data(&adata[i], line, &lp);
     }
-    switch (calign[i] & 0xF) {
+    switch (calign[i] & AL_TYPE) {
     case AL_FULL:
     case AL_WPFULL:
       // This is stupid: If it's full justify and not a hard break, then
       // we stretch spaces. If it is a hard break, then we fall through
       // to left-align.
-      iswpfull = (calign[i] & 0xF) == AL_WPFULL;
+      iswpfull = (calign[i] & AL_TYPE) == AL_WPFULL;
       // For a word processor full justify, # of spaces needed needs to be
       // less than half of the lenth.
       spacesneeded = cols[i] - len;
@@ -1831,17 +1852,26 @@
       }
     default:                   // Left-align
       safe_str(segment, line, &lp);
-      lp += cols[i] - len;
+      /* Don't fill if we're set NOFILL */
+      if (!(calign[i] & AL_NOFILL)) {
+        lp += cols[i] - len;
+      }
       break;
     case AL_RIGHT:
-      lp += cols[i] - len;
+      /* Don't fill if we're set NOFILL and this is an empty line. */
+      if (*segment || !(calign[i] & AL_NOFILL)) {
+        lp += cols[i] - len;
+      }
       safe_str(segment, line, &lp);
       break;
     case AL_CENTER:
       j = cols[i] - len;
       lp += j >> 1;
       safe_str(segment, line, &lp);
-      lp += (j >> 1) + (j & 1);
+      /* Don't fill if we're set NOFILL */
+      if (!(calign[i] & AL_NOFILL)) {
+        lp += (j >> 1) + (j & 1);
+      }
       break;
     }
     if (HAS_ANSI(adata[i])) {
@@ -1923,36 +1953,41 @@
       i *= 10;
       i += *ptr - '0';
     }
-    if (*ptr == '.') {
-      calign[ncols] |= AL_REPEAT;
-      ptr++;
-    }
-    if (*ptr == '`') {
-      calign[ncols] |= AL_COALESCE_LEFT;
-      ptr++;
-    }
-    if (*ptr == '\'') {
-      calign[ncols] |= AL_COALESCE_RIGHT;
-      ptr++;
-    }
-    if (*ptr == '(') {
-      ptr++;
-      ansistr = ptr;
-      while (*ptr && *ptr != ')')
+    while (*ptr && !isspace((unsigned char) *ptr)) {
+      switch (*ptr) {
+      case '.':
+        calign[ncols] |= AL_REPEAT;
+        break;
+      case '`':
+        calign[ncols] |= AL_COALESCE_LEFT;
+        break;
+      case '\'':
+        calign[ncols] |= AL_COALESCE_RIGHT;
+        break;
+      case '$':
+        calign[ncols] |= AL_NOFILL;
+        break;
+      case '(':
         ptr++;
-      if (*ptr != ')') {
-        safe_str(T("#-1 INVALID ALIGN STRING"), buff, bp);
-        return;
+        ansistr = ptr;
+        while (*ptr && *ptr != ')')
+          ptr++;
+        if (*ptr != ')') {
+          safe_str(T("#-1 INVALID ALIGN STRING"), buff, bp);
+          return;
+        }
+        *ptr = '\0';
+        define_ansi_data(&adata[ncols], ansistr);
+        break;
       }
-      *(ptr++) = '\0';
-      define_ansi_data(&adata[ncols], ansistr);
+      ptr++;
     }
+
     cols[ncols++] = i;
     if (!*ptr)
       break;
   }
 
-
   for (i = 0; i < ncols; i++) {
     if (cols[i] < 0) {
       safe_str(T("#-1 CANNOT HAVE COLUMNS OF NEGATIVE SIZE"), buff, bp);
Index: src/rob.c
===================================================================
--- src/rob.c	(.../184p2)	(revision 828)
+++ src/rob.c	(.../184p3)	(revision 828)
@@ -55,6 +55,7 @@
 do_kill(dbref player, const char *what, int cost, int slay)
 {
   dbref victim;
+  int overridekill = 0;
   char tbuf1[BUFFER_LEN], tbuf2[BUFFER_LEN], *tp;
 
   if (slay && !Wizard(player)) {
@@ -102,8 +103,7 @@
       return;
     }
   }
-  if (((get_random32(0, KILL_BASE_COST) < (uint32_t) cost) || slay) &&
-      !Wizard(victim)) {
+  if (((get_random32(0, 100) < (uint32_t) cost) || slay) && !Wizard(victim)) {
     /* you killed him */
     tp = tbuf1;
     safe_format(tbuf1, &tp, T("You killed %s!"), Name(victim));
@@ -111,28 +111,36 @@
     tp = tbuf2;
     safe_format(tbuf2, &tp, T("killed %s!"), Name(victim));
     *tp = '\0';
-    do_halt(victim, "", victim);
+
+    overridekill = queue_event(player, "OBJECT`KILL", "%s,%d,%d",
+                               unparse_objid(victim), cost, slay);
+    if (!overridekill) {
+      do_halt(victim, "", victim);
+    }
     did_it(player, victim, "DEATH", tbuf1, "ODEATH", tbuf2, "ADEATH", NOTHING);
 
     /* notify victim */
     notify_format(victim, T("%s killed you!"), Name(player));
 
-    /* maybe pay off the bonus */
-    /* if we were not called via slay */
-    if (!slay) {
-      int payoff = cost * KILL_BONUS / 100;
-      if (payoff + Pennies(Owner(victim)) > Max_Pennies(Owner(victim)))
-        payoff = Max_Pennies(Owner(victim)) - Pennies(Owner(victim));
-      if (payoff > 0) {
-        notify_format(victim, T("Your insurance policy pays %d %s."),
-                      payoff, ((payoff == 1) ? MONEY : MONIES));
-        giveto(Owner(victim), payoff);
-      } else {
-        notify(victim, T("Your insurance policy has been revoked."));
+    if (!overridekill) {
+      /* Overriding the kill event with the events system prevents do_halt,
+       * @tel and the payoff. */
+      /* Pay off the bonus, if we were not called via slay */
+      if (!slay) {
+        int payoff = cost * KILL_BONUS / 100;
+        if (payoff + Pennies(Owner(victim)) > Max_Pennies(Owner(victim)))
+          payoff = Max_Pennies(Owner(victim)) - Pennies(Owner(victim));
+        if (payoff > 0) {
+          notify_format(victim, T("Your insurance policy pays %d %s."),
+                        payoff, ((payoff == 1) ? MONEY : MONIES));
+          giveto(Owner(victim), payoff);
+        } else {
+          notify(victim, T("Your insurance policy has been revoked."));
+        }
       }
+      /* send him home */
+      safe_tel(victim, HOME, 0, player, "killed");
     }
-    /* send him home */
-    safe_tel(victim, HOME, 0);
     /* if victim is object also dequeue all commands */
   } else {
     /* notify player and victim only */
@@ -145,12 +153,13 @@
  * \param player the enactor/buyer
  * \param item the item to buy
  * \param from who to buy it from
- * \param cost the cost
+ * \param price the price to pay for it, or -1 for any price
  */
 void
 do_buy(dbref player, char *item, char *from, int price)
 {
   dbref vendor;
+  dbref failvendor = NOTHING;
   char prices[BUFFER_LEN];
   char *plus;
   char *cost;
@@ -216,12 +225,14 @@
   boughtit = -1;
   affordable = 1;
   do {
+    if (vendor == player)
+      continue;                 /* Can't buy from yourself. Only occurs with no "from <vendor>" arg */
     a = atr_get(vendor, "PRICELIST");
     if (!a)
       continue;
     mush_strncpy(prices, atr_value(a), BUFFER_LEN);
     upcasestr(prices);
-    count = list2arr(r, BUFFER_LEN / 2, prices, ' ');
+    count = list2arr(r, BUFFER_LEN / 2, prices, ' ', 0);
     if (!count)
       continue;
     for (i = 0; i < count; i++) {
@@ -230,7 +241,7 @@
         cost = r[i] + len;
         if (!*cost)
           continue;
-        costcount = list2arr(c, BUFFER_LEN / 2, cost, ',');
+        costcount = list2arr(c, BUFFER_LEN / 2, cost, ',', 0);
         for (ci = 0; ci < costcount; ci++) {
           cost = c[ci];
           /* Formats:
@@ -270,6 +281,18 @@
             continue;
           }
           if (boughtit >= 0) {
+            /* No point checking the lock before this point, as
+               we don't try and give them money if they aren't
+               selling what we're buying */
+            if (!eval_lock(player, vendor, Pay_Lock)) {
+              boughtit = 0;
+              if (failvendor == NOTHING)
+                failvendor = vendor;
+              /* We don't run fail_lock here in case we end up successfully
+                 buying from someone else. Only fail_lock() if the failure
+                 stops us buying from anyone */
+              continue;
+            }
             if (!payfor(player, boughtit)) {
               affordable = 0;
               boughtit = 0;
@@ -301,7 +324,13 @@
     }
   } while (!from && ((vendor = Next(vendor)) != NOTHING));
 
-  if (price >= 0) {
+  if (failvendor != NOTHING) {
+    /* Found someone selling, but they wouldn't take our money */
+    fail_lock(player, failvendor, Pay_Lock,
+              tprintf(T("%s doesn't want your money."), Name(failvendor)),
+              NOTHING);
+  } else if (price >= 0) {
+    /* Noone we wanted to buy from selling for the right amount */
     if (!from) {
       notify(player, T("I can't find that item with that price here."));
     } else {
@@ -309,12 +338,14 @@
                     Name(vendor));
     }
   } else if (affordable) {
+    /* Didn't find anyone selling it */
     if (!from) {
       notify(player, T("I can't find that item here."));
     } else {
       notify_format(player, T("%s isn't selling that item."), Name(vendor));
     }
   } else {
+    /* We found someone selling, but didn't have the pennies to buy it */
     notify(player, T("You can't afford that."));
   }
 }
@@ -403,7 +434,7 @@
       }
 
       if (Mobile(thing) && (EnterOk(who) || controls(player, who))) {
-        moveto(thing, who);
+        moveto(thing, who, player, "give");
 
         /* Notify the giver with their GIVE message */
         bp = tbuf1;
@@ -459,7 +490,7 @@
       notify_format(player, T("%s refuses your money."), Name(who));
       giveto(player, amount);
       return;
-    } else if (a) {
+    } else if (a && (amount > 0 || !IsPlayer(who))) {
       /* give pennies to object with COST */
       int cost = 0;
       char *preserveq[NUMQ];
@@ -468,13 +499,6 @@
       char *fbp, *asave;
       char const *ap;
 
-      a = atr_get(who, "COST");
-      if (!a) {
-        /* No cost attribute */
-        notify_format(player, T("%s refuses your money."), Name(who));
-        giveto(player, amount);
-        return;
-      }
       save_global_regs("give_save", preserveq);
       save_global_env("give_save", preserves);
       asave = safe_atr_value(a);
@@ -499,6 +523,12 @@
         giveto(player, amount);
         return;
       }
+      if (!eval_lock(player, who, Pay_Lock)) {
+        giveto(player, amount);
+        fail_lock(player, who, Pay_Lock,
+                  tprintf(T("%s refuses your money."), Name(who)), NOTHING);
+        return;
+      }
       if ((amount - cost) > 0) {
         notify_format(player, T("You get %d in change."), amount - cost);
       } else {
@@ -514,7 +544,13 @@
                   NOTHING, pay_env, NA_INTER_SEE);
       return;
     } else {
-      /* give pennies to a player */
+      /* give pennies to a player with no @cost, or "give" a negative amount to a player */
+      if (!Wizard(player) && !eval_lock(player, who, Pay_Lock)) {
+        giveto(player, amount);
+        fail_lock(player, who, Pay_Lock,
+                  tprintf(T("%s refuses your money."), Name(who)), NOTHING);
+        return;
+      }
       if (amount > 0) {
         notify_format(player,
                       T("You give %d %s to %s."), amount,
Index: src/funufun.c
===================================================================
--- src/funufun.c	(.../184p2)	(revision 828)
+++ src/funufun.c	(.../184p3)	(revision 828)
@@ -170,8 +170,11 @@
   }
 
   tp = tbuf = safe_atr_value(attrib);
-  if (attrib->flags & AF_DEBUG)
+  if (AF_NoDebug(attrib))
+    pe_flags |= PE_NODEBUG;     /* no_debug overrides debug */
+  else if (AF_Debug(attrib))
     pe_flags |= PE_DEBUG;
+
   process_expression(buff, bp, &tp, obj, executor, enactor, pe_flags,
                      PT_DEFAULT, pe_info);
   free(tbuf);
@@ -232,7 +235,9 @@
     return;                     /* attr isn't inheritable */
 
   /* DEBUG attributes */
-  if (AF_Debug(a))
+  if (AF_NoDebug(a))
+    pe_flags |= PE_NODEBUG;     /* no_debug overrides debug */
+  else if (AF_Debug(a))
     pe_flags |= PE_DEBUG;
 
   ufun.thing = executor;
Index: src/sort.c
===================================================================
--- src/sort.c	(.../184p2)	(revision 828)
+++ src/sort.c	(.../184p3)	(revision 828)
@@ -148,7 +148,7 @@
     return 0;
   n = parse_integer(result);
 
-  return n * sort_order;
+  return n;
 }
 
 
@@ -226,27 +226,6 @@
 
 /****************************** gensort ************/
 
-typedef struct sort_record s_rec;
-
-/** Sorting strings by different values. We store both the string and
- * its 'key' to sort by. Sort of a hardcode munge.
- */
-struct sort_record {
-  char *ptr;     /**< NULL except for sortkey */
-  char *val;     /**< The string this is */
-  dbref db;      /**< dbref (default 0, bad is -1) */
-  union {
-    struct {
-      char *s;     /**< string comparisons */
-      bool freestr;   /**< free str on completion */
-    } str;
-    int num;       /**< integer comparisons */
-    NVAL numval;   /**< float comparisons */
-    time_t tm;     /**< time comparisions */
-  } memo;
-};
-
-
 #define GENRECORD(x) void x(s_rec *rec,dbref player,char *sortflags); \
   void x(s_rec *rec, \
     dbref player __attribute__ ((__unused__)), \
@@ -271,19 +250,22 @@
   char *s = rec->val;
   int intval;
   int numdigits;
+  bool usedup = false;
   dbref victim;
 
   while (s && *s) {
     switch (*s) {
     case ESC_CHAR:
+      usedup = true;
       while (*s && *s != 'm')
         s++;
-      s++; /* Advance past m */
+      s++;                      /* Advance past m */
       break;
     case TAG_START:
+      usedup = true;
       while (*s && *s != TAG_END)
         s++;
-      s++; /* Advance past tag_end */
+      s++;                      /* Advance past tag_end */
       break;
     case '0':
     case '1':
@@ -295,6 +277,7 @@
     case '7':
     case '8':
     case '9':
+      usedup = true;
       intval = 0;
       while (*s && isdigit((int) *s)) {
         intval *= 10;
@@ -324,6 +307,7 @@
       break;
     case NUMBER_TOKEN:
       if (isdigit((int) *(s + 1))) {
+        usedup = true;
         s++;
         victim = 0;
         while (*s && isdigit((int) *s)) {
@@ -345,8 +329,14 @@
     }
   }
   *bp = '\0';
-  rec->memo.str.s = mush_strdup(buff, "genrecord");
-  rec->memo.str.freestr = 1;
+
+  /* Don't strdup if we haven't done anything useful. */
+  if (usedup) {
+    rec->memo.str.s = mush_strdup(buff, "genrecord");
+    rec->memo.str.freestr = 1;
+  } else {
+    rec->memo.str.s = rec->val;
+  }
 }
 
 GENRECORD(gen_dbref)
@@ -430,11 +420,6 @@
   }
 }
 
-
-typedef int (*qsort_func) (const void *, const void *);
-typedef void (*makerecord) (s_rec *, dbref player, char *sortflags);
-
-
 /* Compare(r,x,y) {
  *   if (x->db < 0 && y->db < 0)
  *     return 0;  // Garbage is identical.
@@ -509,7 +494,7 @@
   const s_rec *sr1 = (const s_rec *) s1;
   const s_rec *sr2 = (const s_rec *) s2;
 
-  return compare_attr_names(sr1->memo.str.s, sr2->memo.str.s);
+  return compare_attr_names(sr1->memo.str.s, sr2->memo.str.s) * sort_order;
 
 }
 
@@ -541,11 +526,11 @@
     cmp = strcoll(a1, a2);
     if (cmp != 0) {
       /* Current branch differs */
-      return cmp * sort_order;
+      return (cmp < 0 ? -1 : 1);
     }
     if (branches1 != branches2) {
       /* Current branch is the same, but one attr has more branches */
-      return (branches1 < branches2 ? -1 : 1) * sort_order;
+      return (branches1 < branches2 ? -1 : 1);
     }
     a1 = next1;
     a2 = next2;
@@ -556,16 +541,6 @@
 }
 
 static int
-si_comp(const void *s1, const void *s2)
-{
-  const s_rec *sr1 = (const s_rec *) s1;
-  const s_rec *sr2 = (const s_rec *) s2;
-  int res = 0;
-  res = strcasecoll(sr1->memo.str.s, sr2->memo.str.s);
-  return Compare(res, sr1, sr2) * sort_order;
-}
-
-static int
 i_comp(const void *s1, const void *s2)
 {
   const s_rec *sr1 = (const s_rec *) s1;
@@ -590,15 +565,9 @@
   return Compare2F(sr1->memo.numval, sr2->memo.numval, sr1, sr2) * sort_order;
 }
 
-typedef struct _list_type_list_ {
-  SortType name;
-  makerecord make_record;
-  qsort_func sorter;
-  uint32_t flags;
-} list_type_list;
-
 #define IS_DB 0x1U
 #define IS_STRING 0x2U
+#define IS_CASE_INSENS 0x4U
 
 char ALPHANUM_LIST[] = "A";
 char INSENS_ALPHANUM_LIST[] = "I";
@@ -618,28 +587,105 @@
 char ATTRNAME_LIST[] = "LATTR";
 char *UNKNOWN_LIST = NULL;
 
-list_type_list ltypelist[] = {
+ListTypeInfo ltypelist[] = {
   /* List type name,            recordmaker,    comparer, dbrefs? */
-  {ALPHANUM_LIST, gen_alphanum, s_comp, IS_STRING},
-  {INSENS_ALPHANUM_LIST, gen_alphanum, si_comp, IS_STRING},
-  {DBREF_LIST, gen_dbref, i_comp, 0},
-  {NUMERIC_LIST, gen_num, i_comp, 0},
-  {FLOAT_LIST, gen_float, f_comp, 0},
-  {MAGIC_LIST, gen_magic, si_comp, IS_STRING},
-  {DBREF_NAME_LIST, gen_db_name, si_comp, IS_DB | IS_STRING},
-  {DBREF_NAMEI_LIST, gen_db_name, si_comp, IS_DB | IS_STRING},
-  {DBREF_IDLE_LIST, gen_db_idle, i_comp, IS_DB},
-  {DBREF_CONN_LIST, gen_db_conn, i_comp, IS_DB},
-  {DBREF_CTIME_LIST, gen_db_ctime, tm_comp, IS_DB},
-  {DBREF_OWNER_LIST, gen_db_owner, i_comp, IS_DB},
-  {DBREF_LOCATION_LIST, gen_db_loc, i_comp, IS_DB},
-  {DBREF_ATTR_LIST, gen_db_attr, s_comp, IS_DB | IS_STRING},
-  {DBREF_ATTRI_LIST, gen_db_attr, si_comp, IS_DB | IS_STRING},
-  {ATTRNAME_LIST, gen_alphanum, attr_comp, IS_STRING},
+  {ALPHANUM_LIST, NULL, 0, gen_alphanum, s_comp, IS_STRING},
+  {INSENS_ALPHANUM_LIST, NULL, 0, gen_alphanum, s_comp,
+   IS_STRING | IS_CASE_INSENS},
+  {DBREF_LIST, NULL, 0, gen_dbref, i_comp, 0},
+  {NUMERIC_LIST, NULL, 0, gen_num, i_comp, 0},
+  {FLOAT_LIST, NULL, 0, gen_float, f_comp, 0},
+  {MAGIC_LIST, NULL, 0, gen_magic, s_comp, IS_STRING | IS_CASE_INSENS},
+  {DBREF_NAME_LIST, NULL, 0, gen_db_name, s_comp, IS_DB | IS_STRING},
+  {DBREF_NAMEI_LIST, NULL, 0, gen_db_name, s_comp,
+   IS_DB | IS_STRING | IS_CASE_INSENS},
+  {DBREF_IDLE_LIST, NULL, 0, gen_db_idle, i_comp, IS_DB},
+  {DBREF_CONN_LIST, NULL, 0, gen_db_conn, i_comp, IS_DB},
+  {DBREF_CTIME_LIST, NULL, 0, gen_db_ctime, tm_comp, IS_DB},
+  {DBREF_OWNER_LIST, NULL, 0, gen_db_owner, i_comp, IS_DB},
+  {DBREF_LOCATION_LIST, NULL, 0, gen_db_loc, i_comp, IS_DB},
+  {DBREF_ATTR_LIST, NULL, 0, gen_db_attr, s_comp, IS_DB | IS_STRING},
+  {DBREF_ATTRI_LIST, NULL, 0, gen_db_attr, s_comp,
+   IS_DB | IS_STRING | IS_CASE_INSENS},
+  {ATTRNAME_LIST, NULL, 0, gen_alphanum, attr_comp, IS_STRING},
   /* This stops the loop, so is default */
-  {NULL, gen_alphanum, s_comp, IS_STRING}
+  {NULL, NULL, 0, gen_alphanum, s_comp, IS_STRING}
 };
 
+/**
+ * Given a string description of a sort type, generate and return a
+ * ListTypeInfo that can be passed to slist_* functions.
+ * \param sort_type A string describing a sort type.
+ * \retval ListTypeInfo containing all generating and comparison information
+ *         needed.
+ */
+ListTypeInfo *
+get_list_type_info(SortType sort_type)
+{
+  int i, len;
+  char *ptr = NULL;
+  ListTypeInfo *lti;
+
+  /* i is either the right one or the default, so we return it anyway. */
+  lti = mush_calloc(1, sizeof(ListTypeInfo), "list_type_info");
+
+  lti->sort_order = ASCENDING;
+
+  if (*sort_type == '-') {
+    lti->sort_order = DESCENDING;
+    sort_type++;
+  }
+  if (!sort_type) {
+    /* Advance i to the default */
+    for (i = 0; ltypelist[i].name; i++) ;
+  } else if ((ptr = strchr(sort_type, ':'))) {
+    len = ptr - sort_type;
+    ptr += 1;
+    if (!*ptr)
+      ptr = NULL;
+    for (i = 0;
+         ltypelist[i].name && strncasecmp(ltypelist[i].name, sort_type, len);
+         i++) ;
+  } else {
+    for (i = 0; ltypelist[i].name && strcasecmp(ltypelist[i].name, sort_type);
+         i++) ;
+  }
+
+  lti->name = ltypelist[i].name;
+  if (ptr) {
+    lti->attrname = mush_strdup(ptr, "list_type_info_attrname");
+  } else {
+    lti->attrname = NULL;
+  }
+  lti->make_record = ltypelist[i].make_record;
+  lti->sorter = ltypelist[i].sorter;
+  lti->flags = ltypelist[i].flags;
+  return lti;
+}
+
+/**
+ * Free a ListTypeInfo struct.
+ * \param lti The ListTypeInfo to free. Must be created by get_list_type_info.
+ */
+void
+free_list_type_info(ListTypeInfo * lti)
+{
+  if (lti->attrname) {
+    mush_free(lti->attrname, "list_type_info_attrname");
+  }
+  mush_free(lti, "list_type_info");
+}
+
+/**
+ * Get the type of a list, as provided by a user. If it is not specified,
+ * try and guess the list type.
+ * \param args The arguments to a function.
+ * \param nargs # of <args>
+ * \param type_pos where to look in args for the sort_type definition.
+ * \param ptrs The list to autodetect on
+ * \param nptrs # of items in <ptrs>
+ * \retval A string that describes the comparison information.
+ */
 SortType
 get_list_type(char *args[], int nargs, int type_pos, char *ptrs[], int nptrs)
 {
@@ -668,6 +714,13 @@
   return autodetect_list(ptrs, nptrs);
 }
 
+/**
+ * Get the type of a list, but return UNKNOWN if it is not specified.
+ * \param args The arguments to a function.
+ * \param nargs # of <args>
+ * \param type_pos where to look in args for the sort_type definition.
+ * \retval A string that describes the comparison information.
+ */
 SortType
 get_list_type_noauto(char *args[], int nargs, int type_pos)
 {
@@ -696,9 +749,24 @@
   return UNKNOWN_LIST;
 }
 
+static void
+genrecord(s_rec *sp, dbref player, ListTypeInfo * lti)
+{
+  lti->make_record(sp, player, lti->attrname);
+  if (lti->flags & IS_CASE_INSENS && sp->memo.str.s) {
+    if (sp->memo.str.freestr == 0) {
+      sp->memo.str.s = mush_strdup(sp->memo.str.s, "genrecord");
+      sp->memo.str.freestr = 1;
+    }
+    upcasestr(sp->memo.str.s);
+  }
+}
 
 /** A generic comparer routine to compare two values of any sort type.
- * \param
+ * \param player Player doing the comparison
+ * \param a Key 1 to compare
+ * \param b Key 2 to compare
+ * \param sort_type SortType describing what kind of comparison to make.
  */
 int
 gencomp(dbref player, char *a, char *b, SortType sort_type)
@@ -707,6 +775,7 @@
   int i, len;
   int result;
   s_rec s1, s2;
+  ListTypeInfo *lti;
   ptr = NULL;
   if (!sort_type) {
     /* Advance i to the default */
@@ -723,6 +792,8 @@
     for (i = 0; ltypelist[i].name && strcasecmp(ltypelist[i].name, sort_type);
          i++) ;
   }
+  lti = get_list_type_info(sort_type);
+
   if (ltypelist[i].flags & IS_DB) {
     s1.db = parse_objid(a);
     s2.db = parse_objid(b);
@@ -736,81 +807,166 @@
 
   s1.val = a;
   s2.val = b;
-  ltypelist[i].make_record(&s1, player, ptr);
-  ltypelist[i].make_record(&s2, player, ptr);
-  result = ltypelist[i].sorter((const void *) &s1, (const void *) &s2);
-  if (ltypelist[i].flags & IS_STRING) {
+  genrecord(&s1, player, lti);
+  genrecord(&s2, player, lti);
+  result = lti->sorter((const void *) &s1, (const void *) &s2);
+  if (lti->flags & IS_STRING) {
     if (s1.memo.str.freestr)
       mush_free(s1.memo.str.s, "genrecord");
     if (s2.memo.str.freestr)
       mush_free(s2.memo.str.s, "genrecord");
   }
+  free_list_type_info(lti);
   return result;
 }
 
-/** A generic sort routine to sort several different
- * types of arrays, in place.
+/**
+ * Given a player dbref (For use with viewing permissions for attrs, etc),
+ * list of keys, list of strings it maps to (sortkey()-style),
+ * # of keys+strings and a list type info, build an array of
+ * s_rec structures representing each item.
  * \param player the player executing the sort.
- * \param s the array to sort.
- * \param n number of elements in array s
- * \param sort_type the string that describes the sort type.
+ * \param keys the array of items to sort.
+ * \param strs If non-NULL, these are what to sort <keys> using.
+ * \param n Number of items in <keys> and <strs>
+ * \param lti List Type Info describing how it's sorted and built.
+ * \retval A pointer to the first s_rec of an <n> s_rec array.
  */
-
-void
-do_gensort(dbref player, char *keys[], char *strs[], int n, SortType sort_type)
+s_rec *
+slist_build(dbref player, char *keys[], char *strs[], int n, ListTypeInfo * lti)
 {
-  char *ptr;
-  static char stype[BUFFER_LEN];
-  int i, sorti;
+  int i;
   s_rec *sp;
-  ptr = NULL;
-  sort_order = ASCENDING;
-  if (sort_type && *sort_type == '-') {
-    sort_type++;
-    sort_order = DESCENDING;
-  }
-  if (!sort_type || !*sort_type) {
-    /* Advance sorti to the default */
-    for (sorti = 0; ltypelist[sorti].name; sorti++) ;
-  } else if (strchr(sort_type, ':') != NULL) {
-    strcpy(stype, sort_type);
-    ptr = strchr(stype, ':');
-    *ptr++ = '\0';
-    if (!*ptr)
-      ptr = NULL;
-    for (sorti = 0;
-         ltypelist[sorti].name && strcasecmp(ltypelist[sorti].name, stype);
-         sorti++) ;
-  } else {
-    for (sorti = 0;
-         ltypelist[sorti].name && strcasecmp(ltypelist[sorti].name, sort_type);
-         sorti++) ;
-  }
+
+  sort_order = lti->sort_order;
+
   sp = mush_calloc(n, sizeof(s_rec), "do_gensort");
+
   for (i = 0; i < n; i++) {
     /* Elements are 0 by default thanks to calloc. Only need to touch
        those that need other values. */
     sp[i].val = keys[i];
     if (strs)
       sp[i].ptr = strs[i];
-    if (ltypelist[sorti].flags & IS_DB) {
+    if (lti->flags & IS_DB) {
       sp[i].db = parse_objid(keys[i]);
       if (!RealGoodObject(sp[i].db))
         sp[i].db = NOTHING;
     }
-    ltypelist[sorti].make_record(&(sp[i]), player, ptr);
+    genrecord(&sp[i], player, lti);
   }
-  qsort((void *) sp, n, sizeof(s_rec), ltypelist[sorti].sorter);
+  return sp;
+}
+
 
+/**
+ * Given an array of s_rec items, sort them in-place using a specified
+ * ListTypeInformation.
+ * \param sp the array of sort_records, returned by slist_build
+ * \param n Number of items in <sp>
+ * \param lti List Type Info describing how it's sorted and built.
+ */
+void
+slist_qsort(s_rec *sp, int n, ListTypeInfo * lti)
+{
+  qsort((void *) sp, n, sizeof(s_rec), lti->sorter);
+}
+
+/**
+ * Given an array of _sorted_ s_rec items, unique them in place by
+ * freeing them and marking the final elements' freestr = 0.
+ * \param sp the array of sort_records, returned by slist_build
+ * \param n Number of items in <sp>
+ * \param lti List Type Info describing how it's sorted and built.
+ * \retval The count of unique items.
+ */
+int
+slist_uniq(s_rec *sp, int n, ListTypeInfo * lti)
+{
+  int count, i;
+
+  /* Quick sanity check. */
+  if (n < 2)
+    return n;
+
+  /* First item's always 'unique' :D. */
+  count = 1;
+
+  for (i = 1; i < n; i++) {
+    /* If sp[i] is a duplicate of sp[count - 1], free it. If it's not,
+     * move it to sp[count] and increment count. */
+    if (lti->sorter((const void *) &sp[count - 1], (const void *) &sp[i])) {
+      /* Not a duplicate. */
+      sp[count++] = sp[i];
+    } else {
+      /* Free it if needed. */
+      if ((lti->flags & IS_STRING) && sp[i].memo.str.freestr) {
+        mush_free(sp[i].memo.str.s, "genrecord");
+      }
+    }
+  }
+  for (i = count; i < n; i++) {
+    if ((lti->flags & IS_STRING) && sp[i].memo.str.freestr) {
+      sp[i].memo.str.freestr = 0;
+      sp[i].memo.str.s = NULL;
+    }
+  }
+  return count;
+}
+
+/**
+ * Given an array of s_rec items, free them if they are not NULL.
+ * \param sp the array of sort_records, returned by slist_build
+ * \param n Number of items in <keys> and <strs>
+ * \param lti List Type Info describing how it's sorted and built.
+ */
+void
+slist_free(s_rec *sp, int n, ListTypeInfo * lti)
+{
+  int i;
+  for (i = 0; i < n; i++) {
+    if ((lti->flags & IS_STRING) && sp[i].memo.str.freestr)
+      mush_free(sp[i].memo.str.s, "genrecord");
+  }
+  mush_free(sp, "do_gensort");
+}
+
+int
+slist_comp(s_rec *s1, s_rec *s2, ListTypeInfo * lti)
+{
+  return lti->sorter((const void *) s1, (const void *) s2);
+}
+
+/** A generic sort routine to sort several different
+ * types of arrays, in place.
+ * \param player the player executing the sort.
+ * \param s the array to sort.
+ * \param n number of elements in array s
+ * \param sort_type the string that describes the sort type.
+ */
+void
+do_gensort(dbref player, char *keys[], char *strs[], int n, SortType sort_type)
+{
+  s_rec *sp;
+  ListTypeInfo *lti;
+  int i;
+
+  lti = get_list_type_info(sort_type);
+  sp = slist_build(player, keys, strs, n, lti);
+  slist_qsort(sp, n, lti);
+
+  /* Change keys and strs around. */
   for (i = 0; i < n; i++) {
     keys[i] = sp[i].val;
     if (strs) {
       strs[i] = sp[i].ptr;
     }
-    if ((ltypelist[sorti].flags & IS_STRING) && sp[i].memo.str.freestr)
-      mush_free(sp[i].memo.str.s, "genrecord");
   }
-  mush_free(sp, "do_gensort");
+
+  /* Free the s_rec list */
+  slist_free(sp, n, lti);
+
+  free_list_type_info(lti);
 }
 
 SortType
@@ -823,6 +979,7 @@
   if (a == b) {
     return a;
   }
+
   /* Float and numeric means float. */
   if ((a == NUMERIC_LIST || a == FLOAT_LIST) &&
       (b == NUMERIC_LIST || b == FLOAT_LIST)) {
@@ -859,11 +1016,13 @@
       if (is_strict_number(ptrs[i])) {
         lt = L_FLOAT;
         sort_type = FLOAT_LIST;
+        break;
       }
     case L_DBREF:
       if (is_objid(ptrs[i]) && (i == 0 || lt == L_DBREF)) {
         lt = L_DBREF;
         sort_type = DBREF_LIST;
+        break;
       }
     case L_ALPHANUM:
       return MAGIC_LIST;
Index: src/flags.c
===================================================================
--- src/flags.c	(.../184p2)	(revision 828)
+++ src/flags.c	(.../184p3)	(revision 828)
@@ -248,7 +248,7 @@
   {"Tport_Anything", '\0', NOTYPE, TEL_OTHER, F_WIZARD | F_LOG, F_WIZARD},
   {"Tport_Anywhere", '\0', NOTYPE, TEL_ANYWHERE, F_WIZARD | F_LOG, F_WIZARD},
   {"Unkillable", '\0', NOTYPE, UNKILLABLE, F_WIZARD | F_LOG, F_WIZARD},
-  {"Can_nspemit", '\0', NOTYPE, CAN_NSPEMIT, F_WIZARD | F_LOG, F_WIZARD},
+  {"Can_spoof", '\0', NOTYPE, CAN_NSPEMIT, F_WIZARD | F_LOG, F_WIZARD},
   {NULL, '\0', 0, 0, 0, 0}
 };
 
@@ -895,6 +895,11 @@
     f = add_power("Sql_Ok", '\0', NOTYPE, F_WIZARD | F_LOG, F_ANY);
     if (!match_power("Use_SQL"))
       flag_add(flags, "Use_SQL", f);
+    if ((f = match_power("Can_nspemit")) && !match_power("Can_spoof")) {
+      mush_free((void *) f->name, "flag.name");
+      f->name = mush_strdup("Can_spoof", "flag.name");
+      flag_add(flags, "Can_spoof", f);
+    }
     add_power("Debit", '\0', NOTYPE, F_WIZARD | F_LOG, F_ANY);
     add_power("Pueblo_Send", '\0', NOTYPE, F_WIZARD | F_LOG, F_ANY);
     add_power("Many_Attribs", '\0', NOTYPE, F_WIZARD | F_LOG, F_ANY);
Index: src/funmath.c
===================================================================
--- src/funmath.c	(.../184p2)	(revision 828)
+++ src/funmath.c	(.../184p3)	(revision 828)
@@ -816,8 +816,8 @@
   if (!delim_check(buff, bp, nargs, args, 3, &sep))
     return;
 
-  v1len = list2arr(v1, BUFFER_LEN / 2, args[0], sep);
-  v2len = list2arr(v2, BUFFER_LEN / 2, args[1], sep);
+  v1len = list2arr(v1, BUFFER_LEN / 2, args[0], sep, 1);
+  v2len = list2arr(v2, BUFFER_LEN / 2, args[1], sep, 1);
 
   if (v1len != 3 || v2len != 3) {
     safe_str(T("#-1 VECTORS MUST BE THREE-DIMENSIONAL"), buff, bp);
@@ -917,19 +917,12 @@
   safe_number(ceil(parse_number(args[0])), buff, bp);
 }
 
-double
-fround(double n, int d)
-{
-  double ex = pow(10.0, d);
-  return floor(n * ex + 0.5) / ex;
-}
-
 /* ARGSUSED */
 FUNCTION(fun_round)
 {
-  int places;
-  double n, rounded;
-  char *sbp;
+  unsigned int places;
+  double n;
+  char *sbp, *decimal;
   bool pad = 0;
 
   if (!is_number(args[0])) {
@@ -939,45 +932,42 @@
     n = parse_number(args[0]);
 
   if (nargs >= 2) {
-    if (!is_integer(args[1])) {
+    if (!is_uinteger(args[1])) {
       safe_str(T(e_int), buff, bp);
       return;
     }
-    places = parse_integer(args[1]);
+    places = parse_uinteger(args[1]);
   } else
     places = 0;
 
   if (nargs == 3)
     pad = parse_boolean(args[2]);
 
-  if (places < 0)
-    places = 0;
-  else if (places > FLOAT_PRECISION)
+  if (places > (unsigned int) FLOAT_PRECISION)
     places = FLOAT_PRECISION;
 
 #ifdef HAVE_ROUND
   if (places == 0)
-    rounded = round(n);
+    safe_number(round(n), buff, bp);
   else
-    rounded = fround(n, places);
-#else
-  rounded = fround(n, places);
 #endif
-
-  sbp = *bp;
-  safe_number(rounded, buff, bp);
-
-  if (pad && places > 0) {
-    char *decimal;
-
+  {
+    sbp = *bp;
+    safe_format(buff, bp, "%.*f", places, n);
     *(*bp) = '\0';
+
     decimal = strchr(sbp, '.');
-    if (!decimal) {
-      safe_chr('.', buff, bp);
-      safe_fill('0', places, buff, bp);
-    } else {
-      size_t padding = places - (*bp - decimal) + 1;
-      safe_fill('0', padding, buff, bp);
+    if (!pad && decimal) {
+      int n, trailing;
+      decimal += 1;
+      trailing = strlen(decimal);
+      for (n = 0; n < trailing; n++, decimal++) {
+        size_t len = strspn(decimal, "0");
+        if (*(decimal + len) == '\0') {
+          *bp = decimal;
+          break;
+        }
+      }
     }
   }
 }
@@ -1813,7 +1803,7 @@
   /* Allocate memory */
   ptr = mush_calloc(BUFFER_LEN, sizeof(char *), "string");
 
-  nptr = list2arr(ptr, BUFFER_LEN, args[1], sep);
+  nptr = list2arr(ptr, BUFFER_LEN, args[1], sep, 1);
 
   op = math_hash_lookup(args[0], arglens[0]);
 
Index: src/create.c
===================================================================
--- src/create.c	(.../184p2)	(revision 828)
+++ src/create.c	(.../184p3)	(revision 828)
@@ -95,6 +95,8 @@
   dbref new_exit;
   char *flaglist, *flagname;
   char flagbuff[BUFFER_LEN];
+  char *name = NULL;
+  char *alias = NULL;
 
   if (!command_check_byname(player, "@dig")) {
     notify(player, T("Permission denied."));
@@ -111,8 +113,14 @@
   if (!*direction) {
     notify(player, T("Open where?"));
     return NOTHING;
-  } else if (!ok_name(direction)) {
+  } else
+    if (ok_object_name
+        ((char *) direction, player, NOTHING, TYPE_EXIT, &name, &alias) < 1) {
     notify(player, T("That's a strange name for an exit!"));
+    if (name)
+      mush_free(name, "name.newname");
+    if (alias)
+      mush_free(alias, "name.newname");
     return NOTHING;
   }
   if (!Open_Anywhere(player) && !controls(player, loc)) {
@@ -122,7 +130,9 @@
     new_exit = new_object();
 
     /* initialize everything */
-    set_name(new_exit, direction);
+    set_name(new_exit, name);
+    if (alias && *alias != ALIAS_DELIMITER)
+      atr_add(new_exit, "ALIAS", alias, player, 0);
     Owner(new_exit) = Owner(player);
     Zone(new_exit) = Zone(player);
     Source(new_exit) = loc;
@@ -137,6 +147,9 @@
       }
     }
 
+    mush_free(name, "name.newname");
+    if (alias)
+      mush_free(alias, "name.newname");
 
     /* link it in */
     PUSH(new_exit, Exits(loc));
@@ -161,8 +174,14 @@
     }
     current_state.exits++;
     local_data_create(new_exit);
+    queue_event(player, "OBJECT`CREATE", "%s", unparse_objid(new_exit));
     return new_exit;
   }
+  if (name)
+    mush_free(name, "name.newname");
+  if (alias)
+    mush_free(alias, "name.newname");
+
   return NOTHING;
 }
 
@@ -408,7 +427,8 @@
  * \endverbatim
  * \param player the enactor.
  * \param name the name of the room to create.
- * \param argv array of additional arguments to command (exit forward,exit back)
+ * \param argv array of additional arguments to command
+ *             (exit forward,exit back,newdbref)
  * \param tport if 1, teleport the player to the new room.
  * \return dbref of new room, or NOTHING.
  */
@@ -418,13 +438,22 @@
   dbref room;
   char *flaglist, *flagname;
   char flagbuff[BUFFER_LEN];
+  char *newdbref = NULL;
+
+  if (argv[3] && *argv[3]) {
+    newdbref = argv[3];
+  }
 
   /* we don't need to know player's location!  hooray! */
   if (*name == '\0') {
     notify(player, T("Dig what?"));
-  } else if (!ok_name(name)) {
+  } else if (!ok_name(name, 0)) {
     notify(player, T("That's a silly name for a room!"));
   } else if (can_pay_fees(player, ROOM_COST)) {
+    if (!make_first_free_wrapper(player, newdbref)) {
+      return NOTHING;
+    }
+
     room = new_object();
 
     /* Initialize everything */
@@ -460,6 +489,7 @@
       sprintf(roomstr, "#%d", room);
       do_teleport(player, "me", roomstr, 0, 0); /* if flag, move the player */
     }
+    queue_event(player, "OBJECT`CREATE", "%s", unparse_objid(room));
     return room;
   }
   return NOTHING;
@@ -486,7 +516,7 @@
   if (*name == '\0') {
     notify(player, T("Create what?"));
     return NOTHING;
-  } else if (!ok_name(name)) {
+  } else if (!ok_name(name, 0)) {
     notify(player, T("That's a silly name for a thing!"));
     return NOTHING;
   } else if (cost < OBJECT_COST) {
@@ -540,6 +570,9 @@
     notify_format(player, T("Created: Object %s."), unparse_dbref(thing));
     current_state.things++;
     local_data_create(thing);
+
+    queue_event(player, "OBJECT`CREATE", "%s", unparse_objid(thing));
+
     return thing;
   }
   return NOTHING;
@@ -588,6 +621,8 @@
 
   Contents(clone) = Location(clone) = Next(clone) = NOTHING;
 
+  queue_event(player, "OBJECT`CREATE", "%s,%s",
+              unparse_objid(clone), unparse_objid(thing));
   return clone;
 
 }
@@ -610,14 +645,15 @@
   dbref clone, thing;
   char dbnum[BUFFER_LEN];
 
-  if (newname && *newname && !ok_name(newname)) {
-    notify(player, T("That is not a reasonable name."));
-    return NOTHING;
-  }
   thing = noisy_match_result(player, name, NOTYPE, MAT_EVERYTHING);
   if ((thing == NOTHING))
     return NOTHING;
 
+  if (newname && *newname && !ok_name(newname, IsExit(thing))) {
+    notify(player, T("That is not a reasonable name."));
+    return NOTHING;
+  }
+
   if (!controls(player, thing) || IsPlayer(thing) ||
       (IsRoom(thing) && !command_check_byname(player, "@dig")) ||
       (IsExit(thing) && !command_check_byname(player, "@open")) ||
@@ -646,9 +682,9 @@
       clone = clone_object(player, thing, newname, preserve);
       notify_format(player, T("Cloned: Object %s."), unparse_dbref(clone));
       if (IsRoom(player))
-        moveto(clone, player);
+        moveto(clone, player, player, "cloned");
       else
-        moveto(clone, Location(player));
+        moveto(clone, Location(player), player, "cloned");
       current_state.things++;
       local_data_clone(clone, thing);
       real_did_it(player, clone, NULL, NULL, NULL, NULL, "ACLONE", NOTHING,
@@ -691,9 +727,9 @@
       clone = do_real_open(player, newname, dbnum, NOTHING);
     else
       clone = do_real_open(player, Name(thing), dbnum, NOTHING);
-    if (!GoodObject(clone))
+    if (!GoodObject(clone)) {
       return NOTHING;
-    else {
+    } else {
       atr_cpy(clone, thing);
       clone_locks(player, thing, clone);
       Zone(clone) = Zone(thing);
Index: src/extmail.c
===================================================================
--- src/extmail.c	(.../184p2)	(revision 828)
+++ src/extmail.c	(.../184p3)	(revision 828)
@@ -1159,6 +1159,18 @@
 }
 
 static int
+can_mail_to(dbref player, dbref target)
+{
+  if (!can_mail(player)) {
+    return 0;
+  }
+  if (!(Hasprivs(player) || eval_lock(player, target, Mail_Lock))) {
+    return 0;
+  }
+  return 1;
+}
+
+static int
 real_send_mail(dbref player, dbref target, char *subject, char *message,
                mail_flag flags, int silent, int nosig)
 {
@@ -1289,9 +1301,17 @@
   mdb_top++;
 
   /* notify people */
-  if (!silent)
-    notify_format(player,
-                  T("MAIL: You sent your message to %s."), Name(target));
+  if (!silent) {
+    if (can_mail_to(target, player)) {
+      notify_format(player,
+                    T("MAIL: You sent your message to %s."), Name(target));
+    } else {
+      notify_format(player,
+                    T
+                    ("MAIL: You sent your message to %s, but they can't mail you!"),
+                    Name(target));
+    }
+  }
   notify_format(target,
                 T("MAIL: You have a new message (%d) from %s."),
                 rc + uc + cc + 1, Name(player));
@@ -2509,14 +2529,13 @@
   /* Initialize the mail selector - this matches all messages */
   ms->low = 0;
   ms->high = 0;
-  ms->flags = 0x00FF | M_MSUNREAD;
+  ms->flags = 0x00FF | M_MSUNREAD | M_FOLDER;
   ms->player = 0;
   ms->days = -1;
   ms->day_comp = 0;
   /* Now, parse the message list */
   if (!msglist || !*msglist) {
     /* All messages in current folder */
-    ms->flags |= M_FOLDER;
     return 1;
   }
   /* Don't mess with msglist itself */
@@ -2524,15 +2543,16 @@
   p = tbuf1;
   while (p && *p && isspace((unsigned char) *p))
     p++;
-  if (!p || !*p) {
-    ms->flags |= M_FOLDER;
+  if (!p || !*p)
     return 1;                   /* all messages in current folder */
-  }
+
   if (isdigit((unsigned char) *p) || *p == '-') {
     if (!parse_message_spec(player, p, &ms->low, &ms->high, &folder)) {
       notify(player, T("MAIL: Invalid message specification"));
       return 0;
     }
+    /* remove current folder when other folder specified */
+    ms->flags &= ~M_FOLDER;
     ms->flags |= FolderBit(folder);
   } else if (*p == '~') {
     /* exact # of days old */
@@ -2611,7 +2631,7 @@
   } else if (!strcasecmp(p, "all")) {
     ms->flags = M_ALL;
   } else if (!strcasecmp(p, "folder")) {
-    ms->flags = M_FOLDER;
+    ms->flags |= M_FOLDER;
   } else if (!strcasecmp(p, "urgent")) {
     ms->flags = M_URGENT | M_FOLDER;
   } else if (!strcasecmp(p, "unread")) {
Index: src/funtime.c
===================================================================
--- src/funtime.c	(.../184p2)	(revision 828)
+++ src/funtime.c	(.../184p3)	(revision 828)
@@ -328,7 +328,7 @@
 {
   /* converts time string to a struct tm. Returns 1 on success, 0 on fail.
    * Formats of the time string are taken from the file listed in the
-   * DATEMSK env variable 
+   * DATEMSK env variable
    */
   struct tm *tc;
 
@@ -449,19 +449,35 @@
 FUNCTION(fun_convtime)
 {
   /* converts time string to seconds */
-
   struct tm ttm;
+  char *tz = NULL;
+  int doutc = (!strcmp(called_as, "CONVUTCTIME") ||
+               (nargs > 1 && !strcmp(args[1], "utc")));
 
   if (do_convtime(args[0], &ttm)
 #ifdef HAS_GETDATE
       || do_convtime_gd(args[0], &ttm)
 #endif
     ) {
+    if (doutc) {
+      tz = getenv("TZ");
+      /* A blank, overridden TZ forces UTC. */
+      setenv("TZ", "", 1);
+      tzset();
+    }
 #ifdef SUN_OS
     safe_integer(timelocal(&ttm), buff, bp);
 #else
     safe_integer(mktime(&ttm), buff, bp);
 #endif                          /* SUN_OS */
+    if (doutc) {
+      if (tz) {
+        setenv("TZ", tz, 1);
+      } else {
+        unsetenv("TZ");
+      }
+      tzset();
+    }
   } else {
     safe_str("-1", buff, bp);
   }
Index: src/plyrlist.c
===================================================================
--- src/plyrlist.c	(.../184p2)	(revision 828)
+++ src/plyrlist.c	(.../184p3)	(revision 828)
@@ -22,6 +22,7 @@
 #include "flags.h"
 #include "htab.h"
 #include "mymalloc.h"
+#include "parse.h"
 #include "confmagic.h"
 
 
@@ -115,16 +116,16 @@
 dbref
 lookup_player(const char *name)
 {
-  int p;
+  dbref d;
 
   if (!name || !*name)
     return NOTHING;
   if (*name == NUMBER_TOKEN) {
-    name++;
-    if (!is_strict_number(name))
+    d = parse_objid(name);
+    if (GoodObject(d) && IsPlayer(d))
+      return d;
+    else
       return NOTHING;
-    p = atoi(name);
-    return ((GoodObject(p) && IsPlayer(p)) ? p : NOTHING);
   }
   if (*name == LOOKUP_TOKEN)
     name++;
Index: src/funlist.c
===================================================================
--- src/funlist.c	(.../184p2)	(revision 828)
+++ src/funlist.c	(.../184p3)	(revision 828)
@@ -47,7 +47,7 @@
  * \return number of words split out.
  */
 int
-list2arr_ansi(char *r[], int max, char *list, char sep)
+list2arr_ansi(char *r[], int max, char *list, char sep, int nullok)
 {
   char *p, *lp;
   int i;
@@ -58,7 +58,7 @@
    * actually has markup. Unfortunately, freearr(), which is called only for
    * list2arr_ansi()'d stuff, requires we malloc each item. Sigh. */
   if (!has_markup(list)) {
-    int ret = list2arr(r, max, list, sep);
+    int ret = list2arr(r, max, list, sep, nullok);
     for (i = 0; i < ret; i++) {
       /* This is lame, but fortunately, assignment happens after we call
        * mush_strdup. A-hehehehe. */
@@ -73,12 +73,17 @@
   aptr = trim_space_sep(aptr, sep);
 
   lp = list;
-  p = split_token(&aptr, sep);
-  for (i = 0; p && (i < max); i++, p = split_token(&aptr, sep)) {
+  do {
+    p = split_token(&aptr, sep);
+  } while (!nullok && p && !*p);
+  for (i = 0; p && (i < max); i++) {
     lp = list;
     safe_ansi_string(as, p - (as->text), strlen(p), list, &lp);
     *lp = '\0';
     r[i] = mush_strdup(list, "list2arr_item");
+    do {
+      p = split_token(&aptr, sep);
+    } while (!nullok && p && !*p);
   }
   free_ansi_string(as);
   return i;
@@ -94,22 +99,32 @@
  * \return number of words split out.
  */
 int
-list2arr(char *r[], int max, char *list, char sep)
+list2arr(char *r[], int max, char *list, char sep, int nullok)
 {
   char *p;
   int i;
   char *aptr;
   size_t len;
 
+  /* Quick-casing an empty list. */
+  if (!*list) {
+    return 0;
+  }
+
   aptr = remove_markup(list, &len);
 
   memcpy(list, aptr, len);
 
   aptr = trim_space_sep(list, sep);
 
-  p = split_token(&aptr, sep);
-  for (i = 0; p && (i < max); i++, p = split_token(&aptr, sep)) {
+  do {
+    p = split_token(&aptr, sep);
+  } while (!nullok && p && !*p);
+  for (i = 0; p && (i < max); i++) {
     r[i] = p;
+    do {
+      p = split_token(&aptr, sep);
+    } while (!nullok && p && !*p);
   }
   return i;
 }
@@ -213,8 +228,8 @@
 
   if (!ptrs1 || !ptrs2)
     mush_panic("Unable to allocate memory in fun_munge");
-  nptrs1 = list2arr_ansi(ptrs1, MAX_SORTSIZE, args[1], sep);
-  nptrs2 = list2arr_ansi(ptrs2, MAX_SORTSIZE, args[2], sep);
+  nptrs1 = list2arr_ansi(ptrs1, MAX_SORTSIZE, args[1], sep, 1);
+  nptrs2 = list2arr_ansi(ptrs2, MAX_SORTSIZE, args[2], sep, 1);
   memcpy(ptrs3, ptrs2, MAX_SORTSIZE * sizeof(char *));
 
   if (nptrs1 != nptrs2) {
@@ -242,7 +257,7 @@
   results = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
   if (!results)
     mush_panic("Unable to allocate memory in fun_munge");
-  nresults = list2arr_ansi(results, MAX_SORTSIZE, rlist, sep);
+  nresults = list2arr_ansi(results, MAX_SORTSIZE, rlist, sep, 1);
 
   first = 1;
   for (i = 0; i < nresults; i++) {
@@ -298,7 +313,7 @@
 
   /* Turn the first list into an array. */
   strcpy(wordlist, args[0]);
-  nwords = list2arr_ansi(ptrs, MAX_SORTSIZE, wordlist, sep);
+  nwords = list2arr_ansi(ptrs, MAX_SORTSIZE, wordlist, sep, 1);
 
   s = trim_space_sep(args[1], ' ');
 
@@ -586,7 +601,7 @@
   /* split the list up, or return if the list is empty */
   if (!*args[0])
     return;
-  n = list2arr_ansi(words, MAX_SORTSIZE, args[0], sep);
+  n = list2arr_ansi(words, MAX_SORTSIZE, args[0], sep, 1);
 
   /* shuffle it */
   for (i = 0; i < n; i++) {
@@ -623,7 +638,7 @@
   } else
     strcpy(outsep, args[3]);
 
-  nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, args[0], sep);
+  nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, args[0], sep, 1);
   sort_type = get_list_type(args, nargs, 2, ptrs, nptrs);
   do_gensort(executor, ptrs, NULL, nptrs, sort_type);
   arr2list(ptrs, nptrs, buff, bp, outsep);
@@ -662,7 +677,7 @@
   if (!fetch_ufun_attrib(args[0], executor, &ufun, UFUN_DEFAULT))
     return;
 
-  nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, args[1], sep);
+  nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, args[1], sep, 1);
 
   /* Now we make a list of keys */
   for (i = 0; i < nptrs; i++) {
@@ -733,7 +748,7 @@
   save_global_env("sortby", tptr);
 
   /* Split up the list, sort it, reconstruct it. */
-  nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, args[1], sep);
+  nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, args[1], sep, 1);
   if (nptrs > 1)                /* pointless to sort less than 2 elements */
     sane_qsort((void **) ptrs, 0, nptrs - 1, u_comp);
 
@@ -744,15 +759,37 @@
   free_anon_attrib(attrib);
 }
 
+#define OUTSEP() do { \
+    if (found) { \
+      safe_strl(osep, osepl, buff, bp); \
+    } else { \
+      found = 1; \
+    } \
+} while (0)
+
 /* ARGSUSED */
-FUNCTION(fun_setinter)
+FUNCTION(fun_setmanip)
 {
   char sep;
   char **a1, **a2;
   int n1, n2, x1, x2, val;
+  int orign1, orign2;
+  int found = 0;
   SortType sort_type = UNKNOWN_LIST;
   int osepl = 0;
   char *osep = NULL, osepd[2] = { '\0', '\0' };
+  s_rec *sp1, *sp2;
+  ListTypeInfo *lti;
+
+  bool dolt = 0, dogt = 0, doeq = 0;
+  if (strstr(called_as, "DIFF")) {
+    dolt = 1;
+  } else if (strstr(called_as, "INTER")) {
+    doeq = 1;
+  } else {
+    /* Setunion. */
+    dolt = dogt = doeq = 1;
+  }
 
   /* if no lists, then no work */
   if (!*args[0] && !*args[1])
@@ -764,11 +801,11 @@
   a1 = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
   a2 = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
   if (!a1 || !a2)
-    mush_panic("Unable to allocate memory in fun_inter");
+    mush_panic("Unable to allocate memory in fun_setmanip");
 
   /* make arrays out of the lists */
-  n1 = list2arr_ansi(a1, MAX_SORTSIZE, args[0], sep);
-  n2 = list2arr_ansi(a2, MAX_SORTSIZE, args[1], sep);
+  orign1 = n1 = list2arr_ansi(a1, MAX_SORTSIZE, args[0], sep, 1);
+  orign2 = n2 = list2arr_ansi(a2, MAX_SORTSIZE, args[1], sep, 1);
 
   if (nargs < 4) {
     sort_type = autodetect_2lists(a1, n1, a2, n2);
@@ -798,362 +835,73 @@
   }
 
   /* sort each array */
-  do_gensort(executor, a1, NULL, n1, sort_type);
-  do_gensort(executor, a2, NULL, n2, sort_type);
+  lti = get_list_type_info(sort_type);
+  sp1 = slist_build(executor, a1, NULL, n1, lti);
+  sp2 = slist_build(executor, a2, NULL, n2, lti);
+  slist_qsort(sp1, n1, lti);
+  n1 = slist_uniq(sp1, n1, lti);
+  slist_qsort(sp2, n2, lti);
+  n2 = slist_uniq(sp2, n2, lti);
 
-  /* get the first value for the intersection, removing duplicates */
+  /* get the first value for the intersection, removing duplicates
+   * We already know that duplicates have been removed from each list. */
   x1 = x2 = 0;
-  while ((val = gencomp(executor, a1[x1], a2[x2], sort_type))) {
+  while ((x1 < n1) && (x2 < n2)) {
+    val = slist_comp(&sp1[x1], &sp2[x2], lti);
     if (val < 0) {
+      if (dolt) {
+        OUTSEP();
+        safe_str(sp1[x1].val, buff, bp);
+      }
       x1++;
-      if (x1 >= n1) {
-        freearr(a1, n1);
-        freearr(a2, n2);
-        mush_free(a1, "ptrarray");
-        mush_free(a2, "ptrarray");
-        return;
+    } else if (val > 0) {
+      if (dogt) {
+        OUTSEP();
+        safe_str(sp2[x2].val, buff, bp);
       }
-    } else {
       x2++;
-      if (x2 >= n2) {
-        freearr(a1, n1);
-        freearr(a2, n2);
-        mush_free(a1, "ptrarray");
-        mush_free(a2, "ptrarray");
-        return;
-      }
-    }
-  }
-  safe_str(a1[x1], buff, bp);
-  while (!gencomp(executor, a1[x1], a2[x2], sort_type)) {
-    x1++;
-    if (x1 >= n1) {
-      freearr(a1, n1);
-      freearr(a2, n2);
-      mush_free(a1, "ptrarray");
-      mush_free(a2, "ptrarray");
-      return;
-    }
-  }
-
-  /* get values for the intersection, until at least one list is empty */
-  while ((x1 < n1) && (x2 < n2)) {
-    while ((val = gencomp(executor, a1[x1], a2[x2], sort_type))) {
-      if (val < 0) {
-        x1++;
-        if (x1 >= n1) {
-          freearr(a1, n1);
-          freearr(a2, n2);
-          mush_free(a1, "ptrarray");
-          mush_free(a2, "ptrarray");
-          return;
-        }
-      } else {
-        x2++;
-        if (x2 >= n2) {
-          freearr(a1, n1);
-          freearr(a2, n2);
-          mush_free(a1, "ptrarray");
-          mush_free(a2, "ptrarray");
-          return;
-        }
+    } else {
+      if (doeq) {
+        OUTSEP();
+        safe_str(sp1[x1].val, buff, bp);
       }
-    }
-    safe_strl(osep, osepl, buff, bp);
-    safe_str(a1[x1], buff, bp);
-    while (!gencomp(executor, a1[x1], a2[x2], sort_type)) {
       x1++;
-      if (x1 >= n1) {
-        freearr(a1, n1);
-        freearr(a2, n2);
-        mush_free(a1, "ptrarray");
-        mush_free(a2, "ptrarray");
-        return;
-      }
+      x2++;
     }
   }
-  freearr(a1, n1);
-  freearr(a2, n2);
-  mush_free(a1, "ptrarray");
-  mush_free(a2, "ptrarray");
-}
-
-/* ARGSUSED */
-FUNCTION(fun_setunion)
-{
-  char sep;
-  char **a1, **a2;
-  int n1, n2, x1, x2, val, orign1, orign2;
-  int lastx1, lastx2, found;
-  SortType sort_type = UNKNOWN_LIST;
-  int osepl = 0;
-  char *osep = NULL, osepd[2] = { '\0', '\0' };
-
-  /* if no lists, then no work */
-  if (!*args[0] && !*args[1])
-    return;
-
-  if (!delim_check(buff, bp, nargs, args, 3, &sep))
-    return;
-
-  a1 = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
-  a2 = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
-  if (!a1 || !a2)
-    mush_panic("Unable to allocate memory in fun_setunion");
-
-  /* make arrays out of the lists */
-  orign1 = n1 = list2arr_ansi(a1, MAX_SORTSIZE, args[0], sep);
-  orign2 = n2 = list2arr_ansi(a2, MAX_SORTSIZE, args[1], sep);
-
-  if (nargs < 4) {
-    osepd[0] = sep;
-    osep = osepd;
-    if (sep)
-      osepl = 1;
-  } else if (nargs == 4) {
-    sort_type = get_list_type_noauto(args, nargs, 4);
-    if (sort_type == UNKNOWN_LIST) {
-      osep = args[3];
-      osepl = arglens[3];
-    } else {
-      osepd[0] = sep;
-      osep = osepd;
-      if (sep)
-        osepl = 1;
+  if (dolt) {
+    while (x1 < n1) {
+      OUTSEP();
+      safe_str(sp1[x1++].val, buff, bp);
     }
-  } else if (nargs == 5) {
-    sort_type = get_list_type_noauto(args, nargs, 4);
-    osep = args[4];
-    osepl = arglens[4];
   }
-
-  if (sort_type == UNKNOWN_LIST) {
-    sort_type = autodetect_2lists(a1, n1, a2, n2);
-  }
-
-  /* sort each array */
-  do_gensort(executor, a1, NULL, n1, sort_type);
-  do_gensort(executor, a2, NULL, n2, sort_type);
-
-  /* get values for the union, in order, skipping duplicates */
-  lastx1 = lastx2 = -1;
-  found = x1 = x2 = 0;
-  if (n1 == 1 && !*a1[0])
-    n1 = 0;
-  if (n2 == 1 && !*a2[0])
-    n2 = 0;
-  while ((x1 < n1) || (x2 < n2)) {
-    /* If we've already copied off something from a1, and our current
-     * look at a1 is the same element, or we've copied from a2 and
-     * our current look at a1 is the same element, skip forward in a1.
-     */
-    if (x1 < n1 && lastx1 >= 0) {
-      val = gencomp(executor, a1[lastx1], a1[x1], sort_type);
-      if (val == 0) {
-        x1++;
-        continue;
-      }
-    }
-    if (x1 < n1 && lastx2 >= 0) {
-      val = gencomp(executor, a2[lastx2], a1[x1], sort_type);
-      if (val == 0) {
-        x1++;
-        continue;
-      }
-    }
-    if (x2 < n2 && lastx1 >= 0) {
-      val = gencomp(executor, a1[lastx1], a2[x2], sort_type);
-      if (val == 0) {
-        x2++;
-        continue;
-      }
-    }
-    if (x2 < n2 && lastx2 >= 0) {
-      val = gencomp(executor, a2[lastx2], a2[x2], sort_type);
-      if (val == 0) {
-        x2++;
-        continue;
-      }
-    }
-    if (x1 >= n1) {
-      /* Just copy off the rest of a2 */
-      if (x2 < n2) {
-        if (found)
-          safe_strl(osep, osepl, buff, bp);
-        safe_str(a2[x2], buff, bp);
-        lastx2 = x2;
-        x2++;
-        found = 1;
-      }
-    } else if (x2 >= n2) {
-      /* Just copy off the rest of a1 */
-      if (x1 < n1) {
-        if (found)
-          safe_strl(osep, osepl, buff, bp);
-        safe_str(a1[x1], buff, bp);
-        lastx1 = x1;
-        x1++;
-        found = 1;
-      }
-    } else {
-      /* At this point, we're merging. Take the lower of the two. */
-      val = gencomp(executor, a1[x1], a2[x2], sort_type);
-      if (val <= 0) {
-        if (found)
-          safe_strl(osep, osepl, buff, bp);
-        safe_str(a1[x1], buff, bp);
-        lastx1 = x1;
-        x1++;
-        found = 1;
-      } else {
-        if (found)
-          safe_strl(osep, osepl, buff, bp);
-        safe_str(a2[x2], buff, bp);
-        lastx2 = x2;
-        x2++;
-        found = 1;
-      }
+  if (dogt) {
+    while (x2 < n2) {
+      OUTSEP();
+      safe_str(sp2[x2++].val, buff, bp);
     }
   }
+
+  /* Free everything we've allocated. */
+  slist_free(sp1, n1, lti);
+  slist_free(sp2, n2, lti);
+  free_list_type_info(lti);
   freearr(a1, orign1);
   freearr(a2, orign2);
   mush_free(a1, "ptrarray");
   mush_free(a2, "ptrarray");
 }
 
-/* ARGSUSED */
-FUNCTION(fun_setdiff)
-{
-  char sep;
-  char **a1, **a2;
-  int n1, n2, x1, x2, val;
-  SortType sort_type = UNKNOWN_LIST;
-  int osepl = 0;
-  char *osep = NULL, osepd[2] = { '\0', '\0' };
-
-  /* if no lists, then no work */
-  if (!*args[0] && !*args[1])
-    return;
-
-  if (!delim_check(buff, bp, nargs, args, 3, &sep))
-    return;
-
-  a1 = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
-  a2 = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
-  if (!a1 || !a2)
-    mush_panic("Unable to allocate memory in fun_diff");
-
-  /* make arrays out of the lists */
-  n1 = list2arr_ansi(a1, MAX_SORTSIZE, args[0], sep);
-  n2 = list2arr_ansi(a2, MAX_SORTSIZE, args[1], sep);
-
-  if (nargs < 4) {
-    osepd[0] = sep;
-    osep = osepd;
-    if (sep)
-      osepl = 1;
-  } else if (nargs == 4) {
-    sort_type = get_list_type_noauto(args, nargs, 4);
-    if (sort_type == UNKNOWN_LIST) {
-      osep = args[3];
-      osepl = arglens[3];
-    } else {
-      osepd[0] = sep;
-      osep = osepd;
-      if (sep)
-        osepl = 1;
-    }
-  } else if (nargs == 5) {
-    sort_type = get_list_type_noauto(args, nargs, 4);
-    osep = args[4];
-    osepl = arglens[4];
-  }
-
-  if (sort_type == UNKNOWN_LIST) {
-    sort_type = autodetect_2lists(a1, n1, a2, n2);
-  }
-
-  /* sort each array */
-  do_gensort(executor, a1, NULL, n1, sort_type);
-  do_gensort(executor, a2, NULL, n2, sort_type);
-
-  /* get the first value for the difference, removing duplicates */
-  x1 = x2 = 0;
-  while ((val = gencomp(executor, a1[x1], a2[x2], sort_type)) >= 0) {
-    if (val > 0) {
-      x2++;
-      if (x2 >= n2)
-        break;
-    }
-    if (!val) {
-      x1++;
-      if (x1 >= n1) {
-        freearr(a1, n1);
-        freearr(a2, n2);
-        mush_free(a1, "ptrarray");
-        mush_free(a2, "ptrarray");
-        return;
-      }
-    }
-  }
-  safe_str(a1[x1], buff, bp);
-  do {
-    x1++;
-    if (x1 >= n1) {
-      freearr(a1, n1);
-      freearr(a2, n2);
-      mush_free(a1, "ptrarray");
-      mush_free(a2, "ptrarray");
-      return;
-    }
-  } while (!gencomp(executor, a1[x1], a1[x1 - 1], sort_type));
-
-  /* get values for the difference, until at least one list is empty */
-  while (x2 < n2) {
-    if ((val = gencomp(executor, a1[x1], a2[x2], sort_type)) < 0) {
-      safe_strl(osep, osepl, buff, bp);
-      safe_str(a1[x1], buff, bp);
-    }
-    if (val <= 0) {
-      do {
-        x1++;
-        if (x1 >= n1) {
-          freearr(a1, n1);
-          freearr(a2, n2);
-          mush_free(a1, "ptrarray");
-          mush_free(a2, "ptrarray");
-          return;
-        }
-      } while (!gencomp(executor, a1[x1], a1[x1 - 1], sort_type));
-    }
-    if (val >= 0)
-      x2++;
-  }
-
-  /* empty out remaining values, still removing duplicates */
-  while (x1 < n1) {
-    safe_strl(osep, osepl, buff, bp);
-    safe_str(a1[x1], buff, bp);
-    do {
-      x1++;
-    } while ((x1 < n1) && !gencomp(executor, a1[x1], a1[x1 - 1], sort_type));
-  }
-  freearr(a1, n1);
-  freearr(a2, n2);
-  mush_free(a1, "ptrarray");
-  mush_free(a2, "ptrarray");
-}
-
-#define CACHE_SIZE 8  /**< Maximum size of the lnum cache */
-
 FUNCTION(fun_unique)
 {
   char sep;
-  char **a1, **a2;
-  int n1, x1, x2;
-  SortType sort_type = ALPHANUM_LIST;
+  char **ary;
+  int orign, n, i;
   int osepl = 0;
   char *osep = NULL, osepd[2] = { '\0', '\0' };
+  SortType sort_type = ALPHANUM_LIST;
+  ListTypeInfo *lti;
+  s_rec *sp;
 
   /* if no lists, then no work */
   if (!*args[0])
@@ -1162,24 +910,16 @@
   if (!delim_check(buff, bp, nargs, args, 3, &sep))
     return;
 
-  a1 = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
+  ary = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
 
-  if (!a1)
+  if (!ary)
     mush_panic("Unable to allocate memory in fun_unique");
 
-  /* make array out of the list */
-  n1 = list2arr_ansi(a1, MAX_SORTSIZE, args[0], sep);
-
-  a2 = mush_calloc(n1, sizeof(char *), "ptrarray");
-  if (!a2)
-    mush_panic("Unable to allocate memory in fun_unique");
+  /* make an array out of the list */
+  orign = n = list2arr_ansi(ary, MAX_SORTSIZE, args[0], sep, 1);
 
   if (nargs >= 2)
-    sort_type = get_list_type_noauto(args, nargs, 2);
-
-  if (sort_type == UNKNOWN_LIST) {
-    sort_type = autodetect_list(a1, n1);
-  }
+    sort_type = get_list_type(args, nargs, 2, ary, n);
 
   if (nargs < 4) {
     osepd[0] = sep;
@@ -1191,29 +931,24 @@
     osepl = arglens[3];
   }
 
+  lti = get_list_type_info(sort_type);
+  sp = slist_build(executor, ary, NULL, n, lti);
+  n = slist_uniq(sp, n, lti);
 
-  a2[0] = a1[0];
-  for (x1 = x2 = 1; x1 < n1; x1++) {
-    if (gencomp(executor, a1[x1], a2[x2 - 1], sort_type) == 0)
-      continue;
-    a2[x2] = a1[x1];
-    x2++;
-  }
-
-  for (x1 = 0; x1 < x2; x1++) {
-    if (x1 > 0)
+  for (i = 0; i < n; i++) {
+    if (i > 0)
       safe_strl(osep, osepl, buff, bp);
-    safe_str(a2[x1], buff, bp);
+    safe_str(sp[i].val, buff, bp);
   }
 
-  freearr(a1, n1);
-  /* We don't freearr(a2) since it wasn't generated by
-   * list2arr, and is instead just pointers into a1 */
-  mush_free(a1, "ptrarray");
-  mush_free(a2, "ptrarray");
-
+  slist_free(sp, n, lti);
+  free_list_type_info(lti);
+  freearr(ary, orign);
+  mush_free(ary, "ptrarray");
 }
 
+#define CACHE_SIZE 8  /**< Maximum size of the lnum cache */
+
 /* ARGSUSED */
 FUNCTION(fun_lnum)
 {
@@ -1280,6 +1015,11 @@
   strcpy(csep[cpos], osep);
   cp = cresult[cpos];
 
+  if (step == 0.0)
+    step = 1.0;
+  else if (step < 0.0)
+    step = step * -1.0;
+
   istart = (int) start;
   iend = (int) end;
   istep = (int) step;
@@ -1979,7 +1719,7 @@
 
   /* Turn the first list into an array. */
   strcpy(wordlist, args[0]);
-  nwords = list2arr_ansi(ptrs, MAX_SORTSIZE, wordlist, sep);
+  nwords = list2arr_ansi(ptrs, MAX_SORTSIZE, wordlist, sep, 1);
 
   s = trim_space_sep(args[1], ' ');
 
@@ -2120,7 +1860,7 @@
 
   words = mush_calloc(BUFFER_LEN, sizeof(char *), "wordlist");
 
-  origcount = count = list2arr_ansi(words, BUFFER_LEN, args[0], sep);
+  origcount = count = list2arr_ansi(words, BUFFER_LEN, args[0], sep, 1);
   if (count == 0) {
     mush_free(words, "wordlist");
     return;
@@ -2166,8 +1906,8 @@
   orig = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
   repl = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
   /* Turn them into lists */
-  ocount = list2arr(orig, MAX_SORTSIZE, args[0], sep);
-  rcount = list2arr(repl, MAX_SORTSIZE, args[1], sep);
+  ocount = list2arr(orig, MAX_SORTSIZE, args[0], sep, 1);
+  rcount = list2arr(repl, MAX_SORTSIZE, args[1], sep, 1);
 
   strncpy(haystack, remove_markup(args[2], NULL), BUFFER_LEN);
   if (!*haystack) {
@@ -2270,7 +2010,7 @@
 
   /* Split lp up into an ansi-safe list */
   ptrs = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
-  nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, lp, sep);
+  nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, lp, sep, 1);
 
   pe_info->iter_nesting++;
   pe_info->local_iter_nesting++;
@@ -2448,7 +2188,7 @@
 
   /* Split lp up into an ansi-safe list */
   ptrs = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
-  nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, lp, sep);
+  nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, lp, sep, 1);
 
   /* Step through the list. */
   for (i = 0; i < nptrs;) {
@@ -2511,7 +2251,7 @@
   strcpy(place, "1");
 
   ptrs = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
-  nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, lp, sep);
+  nptrs = list2arr_ansi(ptrs, MAX_SORTSIZE, lp, sep, 1);
 
   /* Build our %0 args */
   for (i = 0; i < nptrs; i++) {
@@ -2578,7 +2318,7 @@
     lp[n] = trim_space_sep(args[n + 1], sep);
     if (*lp[n]) {
       ptrs[n] = mush_calloc(MAX_SORTSIZE, sizeof(char *), "ptrarray");
-      nptrs[n] = list2arr_ansi(ptrs[n], MAX_SORTSIZE, lp[n], sep);
+      nptrs[n] = list2arr_ansi(ptrs[n], MAX_SORTSIZE, lp[n], sep, 1);
     } else {
       ptrs[n] = NULL;
       nptrs[n] = 0;
@@ -3091,7 +2831,7 @@
    */
   if (subpatterns == 0)
     subpatterns = 33;
-  nqregs = list2arr(qregs, NUMQ, args[2], ' ');
+  nqregs = list2arr(qregs, NUMQ, args[2], ' ', 1);
 
   /* Initialize every q-register used to '' */
   for (i = 0; i < nqregs; i++) {
Index: src/lock.c
===================================================================
--- src/lock.c	(.../184p2)	(revision 828)
+++ src/lock.c	(.../184p3)	(revision 828)
@@ -68,7 +68,8 @@
 lock_type Leave_Lock = "Leave";     /**< Name of leave lock */
 lock_type Drop_Lock = "Drop";       /**< Name of drop lock */
 lock_type Give_Lock = "Give";       /**< Name of give lock */
-lock_type From_Lock = "From";       /**< Name of frop lock */
+lock_type From_Lock = "From";       /**< Name of from lock */
+lock_type Pay_Lock = "Pay";         /**< Name of pay lock */
 lock_type Receive_Lock = "Receive"; /**< Name of receive lock */
 lock_type Mail_Lock = "Mail";       /**< Name of mail lock */
 lock_type Follow_Lock = "Follow";   /**< Name of follow lock */
@@ -100,6 +101,7 @@
   {"Drop", TRUE_BOOLEXP, GOD, LF_PRIVATE, NULL},
   {"Give", TRUE_BOOLEXP, GOD, LF_PRIVATE, NULL},
   {"From", TRUE_BOOLEXP, GOD, LF_PRIVATE, NULL},
+  {"Pay", TRUE_BOOLEXP, GOD, LF_PRIVATE, NULL},
   {"Receive", TRUE_BOOLEXP, GOD, LF_PRIVATE, NULL},
   {"Mail", TRUE_BOOLEXP, GOD, LF_PRIVATE, NULL},
   {"Follow", TRUE_BOOLEXP, GOD, LF_PRIVATE, NULL},
@@ -1001,24 +1003,28 @@
   if (key == TRUE_BOOLEXP) {
     add_lock(GOD, zone, Zone_Lock, parse_boolexp(zone, "=me", Zone_Lock),
              LF_DEFAULT);
-    if (noisy)
+    if (noisy) {
       notify_format(player,
                     T
                     ("Unlocked zone %s - automatically zone-locking to itself"),
                     unparse_object(player, zone));
+    }
+  } else if (!noisy) {
+    return;
   } else if (eval_lock(Location(player), zone, Zone_Lock)) {
     /* Does #0 and #2 pass it? If so, probably trivial elock */
     if (eval_lock(PLAYER_START, zone, Zone_Lock) &&
         eval_lock(MASTER_ROOM, zone, Zone_Lock)) {
-      if (noisy)
-        notify_format(player,
-                      T("Zone %s really should have a more secure zone-lock."),
-                      unparse_object(player, zone));
-    } else                      /* Probably inexact zone lock */
+      notify_format(player,
+                    T("Zone %s really should have a more secure zone-lock."),
+                    unparse_object(player, zone));
+    } else {
+      /* Probably inexact zone lock */
       notify_format(player,
                     T
                     ("Warning: Zone %s may have loose zone lock. Lock zones to =player, not player"),
                     unparse_object(player, zone));
+    }
   }
 }
 
Index: src/destroy.c
===================================================================
--- src/destroy.c	(.../184p2)	(revision 828)
+++ src/destroy.c	(.../184p3)	(revision 828)
@@ -492,8 +492,9 @@
     return;
   }
 
-  if (ADESTROY_ATTR)
+  if (ADESTROY_ATTR) {
     did_it(player, thing, NULL, NULL, NULL, NULL, "ADESTROY", NOTHING);
+  }
 
   return;
 
@@ -591,20 +592,25 @@
 free_object(dbref thing)
 {
   dbref i, loc;
+  const char *type;
   if (!GoodObject(thing))
     return;
   local_data_free(thing);
   switch (Typeof(thing)) {
   case TYPE_THING:
+    type = "THING";
     clear_thing(thing);
     break;
   case TYPE_PLAYER:
+    type = "PLAYER";
     clear_player(thing);
     break;
   case TYPE_EXIT:
+    type = "EXIT";
     clear_exit(thing);
     break;
   case TYPE_ROOM:
+    type = "ROOM";
     clear_room(thing);
     break;
   default:
@@ -612,6 +618,20 @@
            thing);
     return;
   }
+  /* We queue the object-destroy event. Since the event will deal with an
+   * object that doesn't exist anymore, we pass it what information we can,
+   * but as strings.
+   * It's okay to pass it information that will be freed shortly.
+   *
+   * Information needed:
+   *   dbref, type, owner dbref, parent dbref, zone dbref
+   */
+  queue_event(SYSEVENT, "OBJECT`DESTROY",
+              "%s,%s,%s,%s,%s,%s",
+              unparse_objid(thing), Name(thing), type,
+              unparse_objid(Owner(thing)),
+              unparse_objid(Parent(thing)), unparse_objid(Zone(thing)));
+
   change_quota(Owner(thing), QUOTA_COST);
   do_halt(thing, "", thing);
   /* The equivalent of an @drain/any/all: */
@@ -654,7 +674,7 @@
       case TYPE_PLAYER:
       case TYPE_THING:
         /* Huh.  It thought it was here, but we didn't agree. */
-        enter_room(i, Home(i), 0);
+        moveto(i, Home(i), SYSEVENT, "container destroyed");
         break;
       case TYPE_EXIT:
         /* If our destination is destroyed, then we relink to the
@@ -775,9 +795,9 @@
       if (!GoodObject(target) || recursive_member(target, first, 0))
         target = DEFAULT_HOME;
       if (target != NOTHING) {
-        /* Use enter_room() on everything so that AENTER and such
+        /* Use moveto() on everything so that AENTER and such
          * are all triggered properly. */
-        enter_room(first, target, 0);
+        moveto(first, target, SYSEVENT, "container destroyed");
       }
       break;
     }
@@ -987,8 +1007,6 @@
   }
 }
 
-
-
 /** Destroy all the objects we said we would destroy later. */
 void
 purge(void)
@@ -1096,8 +1114,9 @@
       case TYPE_THING:
         if (!GoodObject(home) || IsGarbage(home) || IsExit(home))
           Home(thing) = DEFAULT_HOME;
-        if (!GoodObject(loc) || IsGarbage(loc) || IsExit(loc))
-          enter_room(thing, Home(thing), 0);
+        if (!GoodObject(loc) || IsGarbage(loc) || IsExit(loc)) {
+          moveto(thing, Home(thing), SYSEVENT, "dbck");
+        }
         break;
       case TYPE_EXIT:
         if (Contents(thing) != NOTHING) {
@@ -1355,7 +1374,7 @@
           PUSH(thing, Contents(DEFAULT_HOME));
           Location(thing) = DEFAULT_HOME;
         }
-        enter_room(thing, Location(thing), 0);
+        moveto(thing, Location(thing), SYSEVENT, "dbck");
         /* If we've managed to reconnect it, then we've reconnected
          * its contents. */
         mark_contents(Contents(thing));
@@ -1452,7 +1471,7 @@
       ClearMarked(thing);
     else if (Mobile(thing)) {
       do_rawlog(LT_ERR, "ERROR DBCK: Moved object %d", thing);
-      moveto(thing, DEFAULT_HOME);
+      moveto(thing, DEFAULT_HOME, SYSEVENT, "dbck");
     }
 }
 
Index: src/match.c
===================================================================
--- src/match.c	(.../184p2)	(revision 828)
+++ src/match.c	(.../184p3)	(revision 828)
@@ -4,15 +4,19 @@
  * \brief Matching of object names.
  *
  * These are the PennMUSH name-matching routines, fully re-entrant.
+ *  match_result_relative(who,where,name,type,flags) return match, AMBIGUOUS or NOTHING
  *  match_result(who,name,type,flags) - return match, AMBIGUOUS, or NOTHING
  *  noisy_match_result(who,name,type,flags) - return match or NOTHING,
  *      and notify player on failures
  *  last_match_result(who,name,type,flags) - return match or NOTHING,
  *      and return the last match found in ambiguous situations
  *
+ *  match_result_internal() does the legwork for all of the above.
+ *
  * who = dbref of player to match for
+ * where = dbref of object to match relative to. For all functions which don't take a 'where' arg, use 'who'.
  * name = string to match on
- * type = preferred type of match (TYPE_THING, etc.) or NOTYPE
+ * type = preferred type(s) of match (TYPE_THING, etc.) or NOTYPE
  * flags = a set of bits indicating what kind of matching to do
  *
  * flags are defined in match.h, but here they are for reference:
@@ -26,11 +30,11 @@
  * MAT_ABSOLUTE         - match any <#dbref>
  * MAT_PMATCH           - match <playerName> or *<playerName>
  * MAT_PLAYER           - match *<playerName>
- * MAT_NEIGHBOR         - match something in 'who's location
- * MAT_POSSESSION       - match something in 'who's inventory
- * MAT_EXIT             - match an exit in 'who's location
- * MAT_CARRIED_EXIT     - match an exit in the room 'who'
- * MAT_CONTAINER        - match the name of 'who's location
+ * MAT_NEIGHBOR         - match something in 'where's location
+ * MAT_POSSESSION       - match something in 'where's inventory
+ * MAT_EXIT             - match an exit in 'where's location
+ * MAT_CARRIED_EXIT     - match an exit in the room 'where'
+ * MAT_CONTAINER        - match the name of 'where's location
  * MAT_REMOTE_CONTENTS  - matches the same as MAT_POSSESSION
  * MAT_ENGLISH          - match natural english 'my 2nd flower'
  * MAT_TYPE             - match only objects of the given type(s)
@@ -41,6 +45,8 @@
  * MAT_NEAR_THINGS      - objects,near
  * MAT_REMOTE           - absolute,player,remote_contents,exit,remotes
  * MAT_LIMITED          - absolute,player,neighbor
+ * MAT_CONTENTS         - only match objects located inside 'where'
+ * MAT_OBJ_CONTENTS     - possession,player,absolute,english,contents
  */
 
 #include "copyrite.h"
@@ -62,9 +68,11 @@
 static int parse_english(char **name, long *flags);
 static dbref match_player(dbref who, const char *name, int partial);
 extern int check_alias(const char *command, const char *list);  /* game.c */
-static int match_aliases(dbref match, const char *name);
 static dbref choose_thing(const dbref who, const int preferred_type, long flags,
                           dbref thing1, dbref thing2);
+static dbref match_result_internal(dbref who, dbref where, const char *xname,
+                                   int type, long flags);
+
 
 dbref
 noisy_match_result(const dbref who, const char *name, const int type,
@@ -217,6 +225,8 @@
 
 #define MATCH_TYPE ((type & Typeof(match)) ? 1 : ((flags & MAT_TYPE) ? 0 : -1))
 
+#define MATCH_CONTENTS (!(flags & MAT_CONTENTS) || (Location(match) == where))
+
 #define BEST_MATCH choose_thing(who, type, flags, bestmatch, match)
 
 static dbref
@@ -301,7 +311,7 @@
   return (GoodObject(who) && partial ? visible_short_page(who, name) : NOTHING);
 }
 
-static int
+int
 match_aliases(dbref match, const char *name)
 {
 
@@ -324,8 +334,24 @@
 dbref
 match_result(dbref who, const char *xname, int type, long flags)
 {
+  return match_result_internal(who, who, xname, type, flags);
+}
+
+dbref
+match_result_relative(dbref who, dbref where, const char *xname, int type,
+                      long flags)
+{
+  return match_result_internal(who, where, xname, type, flags);
+}
+
+/* The object 'who' is trying to find something called 'xname' relative to the object 'where'.
+ * In most cases, 'who' and 'where' will be the same object. */
+static dbref
+match_result_internal(dbref who, dbref where, const char *xname, int type,
+                      long flags)
+{
   dbref match;                  /* object we're currently checking for a match */
-  dbref loc;                    /* location of 'who' */
+  dbref loc;                    /* location of 'where' */
   dbref bestmatch = NOTHING;    /* the best match we've found so bar */
   dbref abs = parse_objid(xname);       /* try to match xname as a dbref/objid */
   int final = 0;                /* the Xth object we want, with english matching (5th foo) */
@@ -334,22 +360,37 @@
   int right_type = 0;           /* number of objects of preferred type found, when we have a type but MAT_TYPE isn't given */
   int exact = 0;                /* set to 1 when we've found an exact match, not just a partial one */
   int done = 0;                 /* set to 1 when we're using final, and have found the Xth object */
-  int goodwho = GoodObject(who);
+  int goodwhere = RealGoodObject(where);
   char *name, *sname;           /* name contains the object name searched for, after english matching tokens are stripped from xname */
+
 #ifdef DEBUG_OBJECT_MATCHING
-  debugMatchTo = (goodwho && IsPlayer(who) ? who : 1);
+  debugMatchTo = (GoodObject(who) && IsPlayer(who) ? who : 1);
   notify(debugMatchTo, "ENTERING MATCH_RESULT");
   notify_format(debugMatchTo, "FLAGS: %ld, TYPE: %d", flags, (type == NOTYPE));
 #endif
+
+  loc = (goodwhere ? (IsRoom(where) ? where : Location(where)) : NOTHING);
+
+  if (((flags & MAT_NEAR) && !goodwhere)
+      || ((flags & MAT_CONTENTS) && !goodwhere)) {
+    /* It can't be nearby/in where's contents if where is invalid */
+    if ((flags & MAT_NOISY) && GoodObject(who)) {
+      notify(who, T("I can't see that here."));
+    }
+    return NOTHING;
+  }
+
   /* match "me" */
-  match = who;
-  if (goodwho && MATCH_TYPE && (flags & MAT_ME) && !strcasecmp(xname, "me")) {
+  match = where;
+  if (goodwhere && MATCH_TYPE && (flags & MAT_ME) && !(flags & MAT_CONTENTS)
+      && !strcasecmp(xname, "me")) {
     return match;
   }
 
   /* match "here" */
-  match = (goodwho ? (IsRoom(who) ? NOTHING : Location(who)) : NOTHING);
-  if ((flags & MAT_HERE) && !strcasecmp(xname, "here") && GoodObject(match)
+  match = (goodwhere ? (IsRoom(where) ? NOTHING : Location(where)) : NOTHING);
+  if ((flags & MAT_HERE) && !(flags & MAT_CONTENTS)
+      && !strcasecmp(xname, "here") && GoodObject(match)
       && MATCH_TYPE) {
     if (MATCH_CONTROLS) {
       return match;
@@ -363,23 +404,26 @@
        ((flags & MAT_PLAYER) && *xname == LOOKUP_TOKEN)) &&
       ((type & TYPE_PLAYER) || !(flags & MAT_TYPE))) {
     match = match_player(who, xname, !(flags & MAT_EXACT));
-    if (GoodObject(match)) {
-      if (!(flags & MAT_NEAR) || Long_Fingers(who) ||
-          (nearby(who, match) || controls(who, match))) {
-        if (MATCH_CONTROLS) {
-          return match;
-        } else {
-          nocontrol = 1;
+    if (MATCH_CONTENTS) {
+      if (GoodObject(match)) {
+        if (!(flags & MAT_NEAR) || Long_Fingers(who) ||
+            (nearby(who, match) || controls(who, match))) {
+          if (MATCH_CONTROLS) {
+            return match;
+          } else {
+            nocontrol = 1;
+          }
         }
+      } else {
+        bestmatch = BEST_MATCH;
       }
-    } else {
-      bestmatch = BEST_MATCH;
     }
   }
 
   /* dbref match */
   match = abs;
-  if (RealGoodObject(match) && (flags & MAT_ABSOLUTE) && MATCH_TYPE) {
+  if (RealGoodObject(match) && (flags & MAT_ABSOLUTE) && MATCH_TYPE
+      && MATCH_CONTENTS) {
     if (!(flags & MAT_NEAR) || Long_Fingers(who)
         || (nearby(who, match) || controls(who, match))) {
       /* valid dbref match */
@@ -403,17 +447,18 @@
 #endif
 
   while (1) {
-    loc = (goodwho ? (IsRoom(who) ? who : Location(who)) : NOTHING);
 #ifdef DEBUG_OBJECT_MATCHING
-    notify_format(debugMatchTo, "Running for #%d in #%d", who, loc);
+    notify_format(debugMatchTo, "Running for #%d in #%d", where, loc);
 #endif
-    if (goodwho && ((flags & MAT_POSSESSION) || (flags & MAT_REMOTE_CONTENTS))) {
+    if (goodwhere
+        && ((flags & MAT_POSSESSION) || (flags & MAT_REMOTE_CONTENTS))) {
 #ifdef DEBUG_OBJECT_MATCHING
-      notify(debugMatchTo, "STARTING POSSESSION");
+      notify_format(debugMatchTo, "STARTING POSSESSION with #%d",
+                    Contents(where));
 #endif
-      MATCH_LIST(Contents(who));
+      MATCH_LIST(Contents(where));
     }
-    if (GoodObject(loc) && (flags & MAT_NEIGHBOR)) {
+    if (GoodObject(loc) && (flags & MAT_NEIGHBOR) && !(flags & MAT_CONTENTS)) {
 #ifdef DEBUG_OBJECT_MATCHING
       notify(debugMatchTo, "STARTING NEIGHBOURS");
 #endif
@@ -424,13 +469,14 @@
 #ifdef DEBUG_OBJECT_MATCHING
         notify_format(debugMatchTo, "STARTING EXIT");
 #endif
-        if (flags & MAT_REMOTES && GoodObject(Zone(loc)) && IsRoom(Zone(loc))) {
+        if ((flags & MAT_REMOTES) && !(flags & (MAT_NEAR | MAT_CONTENTS))
+            && GoodObject(Zone(loc)) && IsRoom(Zone(loc))) {
 #ifdef DEBUG_OBJECT_MATCHING
           notify(debugMatchTo, "STARTING EXIT-REMOTE");
 #endif
           MATCH_LIST(Exits(Zone(loc)));
         }
-        if (flags & MAT_GLOBAL) {
+        if ((flags & MAT_GLOBAL) && !(flags & (MAT_NEAR | MAT_CONTENTS))) {
 #ifdef DEBUG_OBJECT_MATCHING
           notify(debugMatchTo, "STARTING EXIT-GLOBAL");
 #endif
@@ -444,18 +490,18 @@
         }
       }
     }
-    if ((flags & MAT_CONTAINER) && goodwho) {
+    if ((flags & MAT_CONTAINER) && !(flags & MAT_CONTENTS) && goodwhere) {
 #ifdef DEBUG_OBJECT_MATCHING
       notify(debugMatchTo, "STARTING CONTAINER");
 #endif
       MATCH_LIST(loc);
     }
     if ((type & TYPE_EXIT) || !(flags & MAT_TYPE)) {
-      if ((flags & MAT_CARRIED_EXIT) && goodwho && IsRoom(who)) {
+      if ((flags & MAT_CARRIED_EXIT) && goodwhere && IsRoom(where)) {
 #ifdef DEBUG_OBJECT_MATCHING
         notify_format(debugMatchTo, "STARTING CEXIT");
 #endif
-        MATCH_LIST(Exits(who));
+        MATCH_LIST(Exits(where));
       }
     }
     break;
@@ -475,7 +521,7 @@
     }
   }
 
-  if (!GoodObject(bestmatch) && (flags & MAT_NOISY)) {
+  if (!GoodObject(bestmatch) && (flags & MAT_NOISY) && GoodObject(who)) {
     /* give error message */
     if (bestmatch == AMBIGUOUS) {
       notify(who, T("I don't know which one you mean!"));
Index: src/player.c
===================================================================
--- src/player.c	(.../184p2)	(revision 828)
+++ src/player.c	(.../184p3)	(revision 828)
@@ -51,9 +51,10 @@
 #include "confmagic.h"
 
 dbref email_register_player
-  (const char *name, const char *email, const char *host, const char *ip);
-static dbref make_player
-  (const char *name, const char *password, const char *host, const char *ip);
+  (DESC *d, const char *name, const char *email, const char *host,
+   const char *ip);
+static dbref make_player(const char *name, const char *password,
+                         const char *host, const char *ip);
 void do_password(dbref player, dbref cause, const char *old,
                  const char *newobj);
 
@@ -83,6 +84,8 @@
 #define IPFAIL(x) ipFails[((failIdx + FAIL_COUNT) - x) % FAIL_COUNT]
 
 static int failCount = 0;
+const char *connect_fail_limit_exceeded =
+  "This IP address has failed too many times. Please try again in 10 minutes.";
 
 /** Check if the given IP has had too many failures to be allowed
  * to log in.
@@ -90,7 +93,7 @@
  * \retval 1 Okay to log in.
  * \retval 0 Do not allow to log in.
  */
-static int
+int
 check_fails(const char *ipaddr)
 {
   int i;
@@ -102,28 +105,54 @@
     return 1;
 
   for (i = 0; i < failCount; i++) {
-    if (IPFAIL(i).failTime > since) {
-      if (!strncmp(ipaddr, IPFAIL(i).ip, IP_LENGTH)) {
-        numFails++;
-        if (numFails >= CONNECT_FAIL_LIMIT) {
-          return 0;
-        }
+    if (IPFAIL(i).failTime < since) {
+      break;
+    }
+    if (!strncmp(ipaddr, IPFAIL(i).ip, IP_LENGTH)) {
+      numFails++;
+      if (numFails >= CONNECT_FAIL_LIMIT) {
+        return 0;
       }
     }
   }
   return 1;
 }
 
-static void
+int
+count_failed(const char *ipaddr)
+{
+  int i, numFails;
+  time_t since = time(NULL) - 600;
+
+  numFails = 0;
+  for (i = 0; i < failCount; i++) {
+    if (IPFAIL(i).failTime < since) {
+      break;
+    }
+    if (!strncmp(ipaddr, IPFAIL(i).ip, IP_LENGTH)) {
+      numFails++;
+    }
+  }
+  return numFails;
+}
+
+/** Mark the given IP as a failure.
+ * \param ipaddr The IP address to check.
+ * \retval The # of fails the IP has had in the past 10 minutes.
+ */
+int
 mark_failed(const char *ipaddr)
 {
   failIdx++;
   failIdx %= FAIL_COUNT;
 
-  if (failCount < FAIL_COUNT)
+  if (failCount < FAIL_COUNT) {
     failCount++;
+  }
   strncpy(IPFAIL(0).ip, ipaddr, IP_LENGTH);
   IPFAIL(0).failTime = time(NULL);
+
+  return count_failed(ipaddr);
 }
 
 
@@ -184,17 +213,11 @@
  * (with reason for failure returned in errbuf).
  */
 dbref
-connect_player(const char *name, const char *password, const char *host,
-               const char *ip, char *errbuf)
+connect_player(DESC *d, const char *name, const char *password,
+               const char *host, const char *ip, char *errbuf)
 {
   dbref player;
-
-  if (!check_fails(ip)) {
-    strcpy(errbuf,
-           T
-           ("This IP address has failed too many times. Please try again in 10 minutes."));
-    return NOTHING;
-  }
+  int count;
 
   /* Default error */
   strcpy(errbuf,
@@ -206,7 +229,9 @@
   /* validate name */
   if ((player = lookup_player(name)) == NOTHING) {
     /* Invalid player names are failures, too. */
-    mark_failed(ip);
+    count = mark_failed(ip);
+    queue_event(SYSEVENT, "SOCKET`LOGINFAIL", "%d,%s,%d,%s,#%d",
+                d->descriptor, ip, count, "invalid player", -1);
     return NOTHING;
   }
 
@@ -215,8 +240,11 @@
     do_log(LT_CONN, 0, 0,
            "Connection to GOING player %s not allowed from %s (%s)", name,
            host, ip);
+    queue_event(SYSEVENT, "SOCKET`LOGINFAIL", "%d,%s,%d,%s,#%d",
+                d->descriptor, ip, count_failed(ip), "player is going", player);
     return NOTHING;
   }
+  /* Check sitelock patterns */
   if (Guest(player)
       && (!Site_Can_Guest(host, player) || !Site_Can_Guest(ip, player))) {
     if (!Deny_Silent_Site(host, AMBIGUOUS) && !Deny_Silent_Site(ip, AMBIGUOUS)) {
@@ -224,6 +252,9 @@
              "Connection to %s (GUEST) not allowed from %s (%s)", name,
              host, ip);
       strcpy(errbuf, T("Guest connections not allowed."));
+      count = mark_failed(ip);
+      queue_event(SYSEVENT, "SOCKET`LOGINFAIL", "%d,%s,%d,%s,#%d",
+                  d->descriptor, ip, count, "failed sitelock", player);
     }
     return NOTHING;
   } else if (!Guest(player)
@@ -234,6 +265,9 @@
              "Connection to %s (Non-GUEST) not allowed from %s (%s)", name,
              host, ip);
       strcpy(errbuf, T("Player connections not allowed."));
+      count = mark_failed(ip);
+      queue_event(SYSEVENT, "SOCKET`LOGINFAIL", "%d,%s,%d,%s,#%d",
+                  d->descriptor, ip, count, "failed sitelock", player);
     }
     return NOTHING;
   }
@@ -243,9 +277,12 @@
       /* Increment count of login failures */
       ModTime(player)++;
       check_lastfailed(player, host);
-      mark_failed(ip);
+      count = mark_failed(ip);
+      queue_event(SYSEVENT, "SOCKET`LOGINFAIL", "%d,%s,%d,%s,#%d",
+                  d->descriptor, ip, count, "invalid password", player);
       return NOTHING;
     }
+
   /* If it's a Guest player, and already connected, search the
    * db for another Guest player to connect them to. */
   if (Guest(player)) {
@@ -254,6 +291,9 @@
     if (!GoodObject(player)) {
       do_log(LT_CONN, 0, 0, "Can't connect to a guest (too many connected)");
       strcpy(errbuf, T("Too many guests are connected now."));
+      queue_event(SYSEVENT, "SOCKET`LOGINFAIL", "%d,%s,%d,%s,#%d",
+                  d->descriptor, ip, count_failed(ip), "too many guests",
+                  player);
       return NOTHING;
     }
   }
@@ -275,20 +315,34 @@
  *  password.
  */
 dbref
-create_player(const char *name, const char *password, const char *host,
-              const char *ip)
+create_player(DESC *d, const char *name, const char *password,
+              const char *host, const char *ip)
 {
   if (!ok_player_name(name, NOTHING, NOTHING)) {
     do_log(LT_CONN, 0, 0, "Failed creation (bad name) from %s", host);
+    if (d) {
+      queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                  d->descriptor, ip, mark_failed(ip), "create: bad name", name);
+    }
     return NOTHING;
   }
   if (!ok_password(password)) {
     do_log(LT_CONN, 0, 0, "Failed creation (bad password) from %s", host);
+    if (d) {
+      queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                  d->descriptor, ip, mark_failed(ip),
+                  "create: bad password", name);
+    }
     return AMBIGUOUS;
   }
   if (DBTOP_MAX && (db_top >= DBTOP_MAX + 1) && (first_free == NOTHING)) {
     /* Oops, out of db space! */
     do_log(LT_CONN, 0, 0, "Failed creation (no db space) from %s", host);
+    if (d) {
+      queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                  d->descriptor, ip, mark_failed(ip),
+                  "create: no db space left to create!", name);
+    }
     return NOTHING;
   }
   /* else he doesn't already exist, create him */
@@ -318,8 +372,8 @@
  * \return dbref of created player or NOTHING if creation failed.
  */
 dbref
-email_register_player(const char *name, const char *email, const char *host,
-                      const char *ip)
+email_register_player(DESC *d, const char *name, const char *email,
+                      const char *host, const char *ip)
 {
   char *p;
   char passwd[BUFFER_LEN];
@@ -329,8 +383,14 @@
   dbref player;
   FILE *fp;
 
+  if (!check_fails(ip)) {
+    return NOTHING;
+  }
+
   if (!ok_player_name(name, NOTHING, NOTHING)) {
     do_log(LT_CONN, 0, 0, "Failed registration (bad name) from %s", host);
+    queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                d->descriptor, ip, mark_failed(ip), "register: bad name", name);
     return NOTHING;
   }
   /* Make sure that the email address is valid. A valid address must
@@ -349,25 +409,35 @@
         do_log(LT_CONN, 0, 0,
                "Failed registration (bad site in email: %s) from %s",
                email, host);
+        queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                    d->descriptor, ip, mark_failed(ip),
+                    "register: bad site in email", name);
       }
       return NOTHING;
     }
   } else if ((p = strchr(email, '!'))) {
     *p = '\0';
     if (!Site_Can_Register(email)) {
-      *p = '!';
       if (!Deny_Silent_Site(email, AMBIGUOUS)) {
+        *p = '!';
         do_log(LT_CONN, 0, 0,
                "Failed registration (bad site in email: %s) from %s",
                email, host);
+        queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                    d->descriptor, ip, mark_failed(ip),
+                    "register: bad site in email", name);
       }
       return NOTHING;
-    } else
+    } else {
       *p = '!';
+    }
   } else {
     if (!Deny_Silent_Site(host, AMBIGUOUS)) {
       do_log(LT_CONN, 0, 0, "Failed registration (bad email: %s) from %s",
              email, host);
+      queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                  d->descriptor, ip, mark_failed(ip),
+                  "register: sitelocked host", name);
     }
     return NOTHING;
   }
@@ -375,6 +445,9 @@
   if (DBTOP_MAX && (db_top >= DBTOP_MAX + 1) && (first_free == NOTHING)) {
     /* Oops, out of db space! */
     do_log(LT_CONN, 0, 0, "Failed registration (no db space) from %s", host);
+    queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                d->descriptor, ip, count_failed(ip),
+                "register: no db space left to create!", name);
     return NOTHING;
   }
 
@@ -388,6 +461,7 @@
    * character. Email first, since that's more likely to go bad.
    * Some security precautions we'll take:
    *  1) We'll use sendmail -t, so we don't pass user-given values to a shell.
+   *  2) We'll cross our fingers and hope nobody uses this to spam.
    */
 
   release_fd();
@@ -399,6 +473,9 @@
     do_log(LT_CONN, 0, 0,
            "Failed registration of %s by %s: unable to open sendmail",
            name, email);
+    queue_event(SYSEVENT, "SOCKET`CREATEFAIL", "%d,%s,%d,%s,%s",
+                d->descriptor, ip, count_failed(ip),
+                "register: Unable to open sendmail!", name);
     reserve_fd();
     return NOTHING;
   }
@@ -420,13 +497,16 @@
   reserve_fd();
   /* Ok, all's well, make a player */
   player = make_player(name, passwd, host, ip);
+  queue_event(SYSEVENT, "PLAYER`CREATE", "%s,%s,%s,%d",
+              unparse_objid(player), name, "register", d->descriptor);
   (void) atr_add(player, "REGISTERED_EMAIL", email, GOD, 0);
   return player;
 }
 #else
 dbref
-email_register_player(const char *name, const char *email, const char *host,
-                      const char *ip __attribute__ ((__unused__)))
+email_register_player(DESC *d, const char *name, const char *email,
+                      const char *host, const char *ip
+                      __attribute__ ((__unused__)))
 {
   do_log(LT_CONN, 0, 0, "Failed registration (no sendmail) from %s", host);
   do_log(LT_CONN, 0, 0, "Requested character: '%s'. Email address: %s\n",
Index: src/wild.c
===================================================================
--- src/wild.c	(.../184p2)	(revision 828)
+++ src/wild.c	(.../184p3)	(revision 828)
@@ -47,6 +47,8 @@
 /** Maximum number of wildcarded arguments */
 #define NUMARGS (10)
 
+bool help_wild(const char *restrict tstr, const char *restrict dstr);
+
 const unsigned char *tables = NULL;  /** Pointer to character tables */
 
 /** Do a wildcard match, without remembering the wild data.
@@ -82,7 +84,7 @@
 
 static bool
 real_atr_wild(const char *restrict tstr,
-              const char *restrict dstr, int *invokes);
+              const char *restrict dstr, int *invokes, char sep);
 /** Do an attribute name wildcard match.
  *
  * This probably crashes if fed NULLs instead of strings, too.
@@ -100,12 +102,19 @@
 atr_wild(const char *restrict tstr, const char *restrict dstr)
 {
   int invokes = 10000;
-  return real_atr_wild(tstr, dstr, &invokes);
+  return real_atr_wild(tstr, dstr, &invokes, '`');
+}
+
+bool
+help_wild(const char *restrict tstr, const char *restrict dstr)
+{
+  int invokes = 10000;
+  return real_atr_wild(tstr, dstr, &invokes, ' ');
 }
 
 static bool
 real_atr_wild(const char *restrict tstr,
-              const char *restrict dstr, int *invokes)
+              const char *restrict dstr, int *invokes, char sep)
 {
   int starcount;
   if (*invokes > 0) {
@@ -115,7 +124,7 @@
   }
 
   if (!*tstr)
-    return !strchr(dstr, '`');
+    return !strchr(dstr, sep);
 
   while (*tstr != '*') {
     switch (*tstr) {
@@ -123,16 +132,21 @@
       /* Single character match.  Return false if at
        * end of data.
        */
-      if (!*dstr || *dstr == '`')
+      if (!*dstr || *dstr == sep)
         return 0;
       break;
     case '`':
       /* Delimiter match.  Special handling if at end of pattern. */
-      if (*dstr != '`')
-        return 0;
-      if (!tstr[1])
-        return !strchr(dstr + 1, '`');
-      break;
+      if (sep != '`') {
+        tstr--;
+        /* FALL THROUGH */
+      } else {
+        if (*dstr != sep)
+          return 0;
+        if (!tstr[1])
+          return !strchr(dstr + 1, sep);
+        break;
+      }
     case '\\':
       /* Escape character.  Move up, and force literal
        * match of next character.
@@ -159,7 +173,7 @@
   /* Skip over wildcards. */
   while (starcount < 2 && ((*tstr == '?') || (*tstr == '*'))) {
     if (*tstr == '?') {
-      if (!*dstr || *dstr == '`')
+      if (!*dstr || *dstr == sep)
         return 0;
       dstr++;
       starcount = 0;
@@ -174,12 +188,12 @@
 
   /* Return true on trailing '**'. */
   if (!*tstr)
-    return starcount == 2 || !strchr(dstr, '`');
+    return starcount == 2 || !strchr(dstr, sep);
 
   if (*tstr == '?') {
     /* Scan for possible matches. */
     while (*dstr) {
-      if (*dstr != '`' && real_atr_wild(tstr + 1, dstr + 1, invokes))
+      if (*dstr != sep && real_atr_wild(tstr + 1, dstr + 1, invokes, sep))
         return 1;
       dstr++;
       if (*invokes <= 0)
@@ -195,12 +209,12 @@
       if (EQUAL(0, *dstr, *tstr)) {
         if (!*(tstr + 1) && *(dstr + 1))
           return 0;             /* No more in pattern string, but more in target */
-        if (real_atr_wild(tstr + 1, dstr + 1, invokes))
+        if (real_atr_wild(tstr + 1, dstr + 1, invokes, sep))
           return 1;
       }
       if (*invokes <= 0)
         return 0;
-      if (starcount < 2 && *dstr == '`')
+      if (starcount < 2 && *dstr == sep)
         return 0;
       dstr++;
     }
Index: src/look.c
===================================================================
--- src/look.c	(.../184p2)	(revision 828)
+++ src/look.c	(.../184p3)	(revision 828)
@@ -47,7 +47,7 @@
 static int look_helper_veiled(dbref player, dbref thing, dbref parent,
                               char const *pattern, ATTR *atr, void *args);
 void decompile_atrs(dbref player, dbref thing, const char *name,
-                    const char *pattern, const char *prefix, int skipdef);
+                    const char *pattern, const char *prefix, int skipflags);
 void decompile_locks(dbref player, dbref thing, const char *name,
                      int skipdef, const char *prefix);
 static char *parent_chain(dbref player, dbref thing);
@@ -707,7 +707,7 @@
            results when the remote exit is set transparent, and possibly lets you look at the back
            of the door you're looking through, which is odd */
         thing =
-          match_result(box, objname, NOTYPE, MAT_POSSESSION | MAT_ENGLISH);
+          match_result_relative(player, box, objname, NOTYPE, MAT_OBJ_CONTENTS);
         if (!GoodObject(thing)) {
           notify(player, T("I don't see that here."));
           return;
@@ -715,7 +715,8 @@
         look_simple(player, thing);
         return;
       }
-      thing = match_result(box, objname, NOTYPE, MAT_POSSESSION | MAT_ENGLISH);
+      thing =
+        match_result_relative(player, box, objname, NOTYPE, MAT_OBJ_CONTENTS);
       if (thing == NOTHING) {
         notify(player, T("I don't see that here."));
         return;
@@ -757,7 +758,6 @@
     }
   }
 
-
   switch (Typeof(thing)) {
   case TYPE_ROOM:
     look_room(player, thing, LOOK_NORMAL);
@@ -1465,7 +1465,7 @@
   *bp = '\0';
   notify(player, msg);
   /* Now deal with attribute flags, if not FugueEditing */
-  if (!*dh->prefix) {
+  if (dh->skipdef < 2) {
     /* If skipdef is on, only show sets that aren't the defaults */
     const char *privs = NULL;
     if (dh->skipdef && ptr) {
@@ -1478,7 +1478,8 @@
       privs = privs_to_string(attr_privs_view, AL_FLAGS(atr));
     }
     if (privs && *privs)
-      notify_format(player, "@set %s/%s=%s", dh->name, AL_NAME(atr), privs);
+      notify_format(player, "%s@set %s/%s=%s", dh->prefix, dh->name,
+                    AL_NAME(atr), privs);
   }
   return 1;
 }
@@ -1489,7 +1490,7 @@
  * \param name name to refer to object by in decompile.
  * \param pattern pattern to match attributes to decompile.
  * \param prefix prefix to use for decompile/tf.
- * \param skipdef if true, skip showing default attribute flags.
+ * \param skipflags if 0, show attribute flags. If 1, skip default attr flags. If 2, skip all attr flags.
  */
 void
 decompile_atrs(dbref player, dbref thing, const char *name, const char *pattern,
@@ -1558,7 +1559,12 @@
   char object[BUFFER_LEN];
   char *objp, *attrib, *attrname, *name;
 
-  int skipdef = (dec_type & DEC_SKIPDEF);
+  int skipdef = 0;
+
+  if (dec_type & DEC_TF)
+    skipdef = 2;
+  else if (dec_type & DEC_SKIPDEF)
+    skipdef = 1;
 
   /* @decompile must always have an argument */
   if (!xname || !*xname) {
Index: src/notify.c
===================================================================
--- src/notify.c	(.../184p2)	(revision 828)
+++ src/notify.c	(.../184p3)	(revision 828)
@@ -791,8 +791,11 @@
             continue;
 
           if (!(flags & NA_SPOOF)
-              && (nsfunc && ((Nospoof(target) && (target != speaker))
-                             || (flags & NA_NOSPOOF)))) {
+              && (nsfunc
+                  &&
+                  ((Nospoof(target)
+                    && ((target != speaker) || Paranoid(target)))
+                   || (flags & NA_NOSPOOF)))) {
             if (Paranoid(target) || (flags & NA_PARANOID)) {
               if (!havepara) {
                 paranoid = nsfunc(speaker, func, fdata, 1);
@@ -951,7 +954,7 @@
       )
       atr_comm_match(target, speaker, '^', ':',
                      (char *) notify_makestring(msgbuf, messages, NA_COLOR, 0),
-                     0, 1, NULL, NULL, NULL);
+                     0, 1, NULL, NULL, NULL, 0);
 
     /* If object is flagged AUDIBLE and has a @FORWARDLIST, send
      *  stuff on */
Index: src/game.c
===================================================================
--- src/game.c	(.../184p2)	(revision 828)
+++ src/game.c	(.../184p3)	(revision 828)
@@ -326,6 +326,8 @@
     /* The dump failed. Disk might be full or something went bad with the
        compression slave. Boo! */
     do_rawlog(LT_ERR, "ERROR! Database save failed.");
+    queue_event(SYSEVENT, "DUMP`ERROR", "%s,%d,PERROR %s",
+                T("GAME: ERROR! Database save failed!"), 0, strerror(errno));
     flag_broadcast("WIZARD ROYALTY", 0,
                    T("GAME: ERROR! Database save failed!"));
     if (f)
@@ -614,8 +616,13 @@
       _exit(status ? 0 : 1);    /* d_d_i() returns true on success but exit code should be 0 on success */
     } else {
       reserve_fd();
-      if (status && DUMP_NOFORK_COMPLETE && *DUMP_NOFORK_COMPLETE)
-        flag_broadcast(0, 0, "%s", DUMP_NOFORK_COMPLETE);
+      if (status) {
+        queue_event(SYSEVENT, "DUMP`COMPLETE", "%s,%d",
+                    DUMP_NOFORK_COMPLETE, 0);
+        if (status && DUMP_NOFORK_COMPLETE && *DUMP_NOFORK_COMPLETE) {
+          flag_broadcast(0, 0, "%s", DUMP_NOFORK_COMPLETE);
+        }
+      }
     }
   }
 #ifdef LOG_CHUNK_STATS
@@ -968,7 +975,7 @@
 /** Check each attribute on each object in x for a $command matching cptr */
 #define list_match(x)        list_check(x, player, '$', ':', cptr, 0)
 /** Check each attribute on x for a $command matching cptr */
-#define cmd_match(x)         atr_comm_match(x, player, '$', ':', cptr, 0, 1, NULL, NULL, &errdb)
+#define cmd_match(x)         atr_comm_match(x, player, '$', ':', cptr, 0, 1, NULL, NULL, &errdb, 0)
 #define MAYBE_ADD_ERRDB(errdb)  \
         do { \
           if (GoodObject(errdb) && errdblist) { \
@@ -1055,7 +1062,7 @@
  * \param from_port if 1, the command was direct input from a socket.
  */
 void
-process_command(dbref player, char *command, dbref cause, int from_port)
+process_command(dbref player, char *command, dbref cause, dbref caller, int from_port)
 {
   int a;
   char *p;                      /* utility */
@@ -1108,8 +1115,9 @@
     do_log(LT_ERR, NOTHING, NOTHING,
            "Command attempted by %s(#%d) in invalid location #%d.",
            Name(player), player, Location(player));
-    if (Mobile(player))
-      moveto(player, PLAYER_START);     /* move it someplace valid */
+    if (Mobile(player)) {
+      moveto(player, PLAYER_START, SYSEVENT, "dbck");   /* move it someplace valid */
+    }
   }
   orator = player;
 
@@ -1139,7 +1147,7 @@
 
   strcpy(unp, command);
 
-  cptr = command_parse(player, cause, command, from_port);
+  cptr = command_parse(player, cause, caller, command, from_port);
   if (cptr) {
     mush_strncpy(global_eval_context.ucom, cptr, BUFFER_LEN);
     a = 0;
@@ -1365,8 +1373,8 @@
   dbref errdb = NOTHING;
 
   while (thing != NOTHING) {
-    if (atr_comm_match
-        (thing, player, type, end, str, just_match, 1, NULL, NULL, &errdb))
+    if (atr_comm_match(thing, player, type,
+                       end, str, just_match, 1, NULL, NULL, &errdb, 0))
       match = 1;
     else {
       MAYBE_ADD_ERRDB(errdb);
@@ -1585,7 +1593,7 @@
 /** Would the scan command find an matching attribute on x for player p? */
 #define ScanFind(p,x)  \
   (Can_Examine(p,x) && \
-      ((num = atr_comm_match(x, p, '$', ':', command, 1, 1, atrname, &ptr, NULL)) != 0))
+      ((num = atr_comm_match(x, p, '$', ':', command, 1, 1, atrname, &ptr, NULL, 0)) != 0))
 
 /** Scan for matches of $commands.
  * This function scans for possible matches of user-def'd commands from the
Index: src/parse.c
===================================================================
--- src/parse.c	(.../184p2)	(revision 828)
+++ src/parse.c	(.../184p3)	(revision 828)
@@ -143,6 +143,37 @@
   return parse_integer(s + 1);
 }
 
+/** Given a thing, return a buffer with its objid.
+ * This thing cheats, it uses a static buffer so it can safely return
+ * around 400-ish objids before rewinding back to start. This is not
+ * intended for use with large lists, but for queue_event() or for calling
+ * functions that need multiple char *s
+ *
+ * \param thing thing to the return the objid of.
+ * \return The objid string.
+ */
+const char *
+unparse_objid(dbref thing)
+{
+  static char obuff[BUFFER_LEN];
+  static char *obp = obuff;
+  char *retval;
+
+  if (!GoodObject(thing)) {
+    return "#-1";
+  }
+
+  if ((obp - obuff) >= (BUFFER_LEN - 40)) {
+    obp = obuff;
+  }
+  retval = obp;
+
+  safe_dbref(thing, obuff, &obp);
+  safe_chr(':', obuff, &obp);
+  safe_integer(CreTime(thing), obuff, &obp);
+  *(obp++) = '\0';
+  return retval;
+}
 
 /** Given a string, parse out an object id or dbref.
  * \param str string to parse.
@@ -606,6 +637,7 @@
   pe_info->dolists = 0;
   pe_info->switch_nesting = -1;
   pe_info->local_switch_nesting = -1;
+  pe_info->debugging = 0;
 
   return pe_info;
 }
@@ -700,6 +732,7 @@
   int temp_eflags;
   int qindex;
   int retval = 0;
+  int old_debugging = 0;
 
   if (!buff || !bp || !str || !*str)
     return 0;
@@ -709,7 +742,7 @@
       /* Can't just put #-1 CPU USAGE EXCEEDED in buff here, because
        * it might never get displayed.
        */
-      if (!Quiet(enactor))
+      if (GoodObject(enactor) && !Quiet(enactor))
         notify(enactor, T("CPU usage exceeded."));
       do_rawlog(LT_TRACE,
                 "CPU time limit exceeded. enactor=#%d executor=#%d caller=#%d code=%s",
@@ -728,6 +761,10 @@
   if (!pe_info) {
     made_info = 1;
     pe_info = make_pe_info();
+  } else {
+    old_debugging = pe_info->debugging;
+    if (caller != executor)
+      pe_info->debugging = 0;
   }
 
   /* If we've been asked to evaluate, log the expression if:
@@ -760,8 +797,14 @@
     goto exit_sequence;
   }
 
+  if (eflags & PE_DEBUG)
+    pe_info->debugging = 1;
+  else if (eflags & PE_NODEBUG)
+    pe_info->debugging = -1;
+
   if (eflags != PE_NOTHING) {
-    debugging = (Debug(executor) || (eflags & PE_DEBUG))
+    debugging = ((Debug(executor) && pe_info->debugging != -1)
+                 || (pe_info->debugging == 1))
       && (Connected(Owner(executor)) || atr_get(executor, "DEBUGFORWARDLIST"));
     if (debugging) {
       int j;
@@ -1056,9 +1099,9 @@
           (*str)++;
           if (pe_info->iter_nesting >= 0 && pe_info->local_iter_nesting >= 0) {
             if (nextc == 'l') {
-              safe_str(pe_info->
-                       iter_itext[pe_info->iter_nesting -
-                                  pe_info->local_iter_nesting], buff, bp);
+              safe_str(pe_info->iter_itext[pe_info->iter_nesting -
+                                           pe_info->local_iter_nesting], buff,
+                       bp);
               break;
             }
             if (!isdigit((unsigned char) nextc)) {
@@ -1084,7 +1127,7 @@
           (*str)++;
           if (pe_info->switch_nesting >= 0
               && pe_info->local_switch_nesting >= 0) {
-            if (nextc == 'l') {
+            if (nextc == 'l' || nextc == 'L') {
               inum_this = pe_info->local_switch_nesting;
             } else if (!isdigit((unsigned char) nextc)) {
               safe_str(T(e_int), buff, bp);
@@ -1096,9 +1139,8 @@
                 (pe_info->local_switch_nesting - inum_this) < 0) {
               safe_str(T(e_argrange), buff, bp);
             } else {
-              safe_str(pe_info->
-                       switch_text[pe_info->switch_nesting - inum_this], buff,
-                       bp);
+              safe_str(pe_info->switch_text
+                       [pe_info->switch_nesting - inum_this], buff, bp);
             }
           } else {
             safe_str(T(e_argrange), buff, bp);
@@ -1649,6 +1691,8 @@
     pe_info->call_depth--;
   if (made_info)
     free_pe_info(pe_info);
+  else
+    pe_info->debugging = old_debugging;
   return retval;
 }
 
Index: src/atr_tab.c
===================================================================
--- src/atr_tab.c	(.../184p2)	(revision 828)
+++ src/atr_tab.c	(.../184p3)	(revision 828)
@@ -53,6 +53,7 @@
   {"prefixmatch", '\0', AF_PREFIXMATCH, AF_PREFIXMATCH},
   {"veiled", 'V', AF_VEILED, AF_VEILED},
   {"debug", 'b', AF_DEBUG, AF_DEBUG},
+  {"no_debug", 'B', AF_NODEBUG, AF_NODEBUG},
   {"public", 'p', AF_PUBLIC, AF_PUBLIC},
   {"nearby", 'n', AF_NEARBY, AF_NEARBY},
   {"noname", 'N', AF_NONAME, AF_NONAME},
@@ -80,6 +81,7 @@
   {"prefixmatch", '\0', AF_PREFIXMATCH, AF_PREFIXMATCH},
   {"veiled", 'V', AF_VEILED, AF_VEILED},
   {"debug", 'b', AF_DEBUG, AF_DEBUG},
+  {"no_debug", 'B', AF_NODEBUG, AF_NODEBUG},
   {"public", 'p', AF_PUBLIC, AF_PUBLIC},
   {"nearby", 'n', AF_NEARBY, AF_NEARBY},
   {"noname", 'N', AF_NONAME, AF_NONAME},
Index: src/command.c
===================================================================
--- src/command.c	(.../184p2)	(revision 828)
+++ src/command.c	(.../184p3)	(revision 828)
@@ -97,9 +97,9 @@
   {"@CEMIT", "NOEVAL NOISY SILENT SPOOF", cmd_cemit,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED, 0, 0},
   {"@CHANNEL",
-   "LIST ADD DELETE RENAME MOGRIFIER NAME PRIVS QUIET NOISY DECOMPILE DESCRIBE CHOWN WIPE MUTE UNMUTE GAG UNGAG HIDE UNHIDE WHAT TITLE BRIEF RECALL BUFFER SET COMBINE UNCOMBINE",
+   "LIST ADD DELETE RENAME MOGRIFIER NAME PRIVS QUIET DECOMPILE DESCRIBE CHOWN WIPE MUTE UNMUTE GAG UNGAG HIDE UNHIDE WHAT TITLE BRIEF RECALL BUFFER COMBINE UNCOMBINE ON JOIN OFF LEAVE WHO",
    cmd_channel,
-   CMD_T_ANY | CMD_T_SWITCHES | CMD_T_EQSPLIT | CMD_T_NOGAGGED | CMD_T_RS_ARGS,
+   CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED | CMD_T_RS_ARGS,
    0, 0},
   {"@CHAT", NULL, cmd_chat, CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED, 0, 0},
   {"@CHOWNALL", "PRESERVE", cmd_chownall, CMD_T_ANY | CMD_T_EQSPLIT, "WIZARD",
@@ -162,7 +162,8 @@
    cmd_flag,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_RS_ARGS | CMD_T_NOGAGGED, 0, 0},
 
-  {"@FORCE", "NOEVAL", cmd_force, CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED,
+  {"@FORCE", "NOEVAL INPLACE", cmd_force,
+   CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED,
    0, 0},
   {"@FUNCTION",
    "ALIAS BUILTIN CLONE DELETE ENABLE DISABLE PRESERVE RESTORE RESTRICT",
@@ -172,14 +173,14 @@
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_RS_NOPARSE | CMD_T_NOGAGGED, 0, 0},
   {"@HALT", "ALL PID", cmd_halt, CMD_T_ANY | CMD_T_EQSPLIT, 0, 0},
   {"@HIDE", "NO OFF YES ON", cmd_hide, CMD_T_ANY, 0, 0},
-  {"@HOOK", "LIST AFTER BEFORE IGNORE OVERRIDE", cmd_hook,
+  {"@HOOK", "LIST AFTER BEFORE IGNORE OVERRIDE INPLACE", cmd_hook,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_RS_ARGS,
    "WIZARD", "hook"},
   {"@INCLUDE", NULL, cmd_include,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_RS_ARGS | CMD_T_NOGAGGED, 0, 0},
   {"@KICK", NULL, cmd_kick, CMD_T_ANY, "WIZARD", 0},
 
-  {"@LEMIT", "NOEVAL SILENT SPOOF", cmd_lemit,
+  {"@LEMIT", "NOEVAL NOISY SILENT SPOOF", cmd_lemit,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED, 0, 0},
   {"@LINK", "PRESERVE", cmd_link, CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED, 0,
    0},
@@ -191,7 +192,7 @@
    CMD_T_ANY, 0, 0},
   {"@LOCK", NULL, cmd_lock,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_SWITCHES | CMD_T_NOGAGGED, 0, 0},
-  {"@LOG", "CHECK CMD CONN ERR TRACE WIZ", cmd_log,
+  {"@LOG", "CHECK CMD CONN ERR TRACE WIZ RECALL", cmd_log,
    CMD_T_ANY | CMD_T_NOGAGGED, "WIZARD", 0},
   {"@LOGWIPE", "CHECK CMD CONN ERR TRACE WIZ", cmd_logwipe,
    CMD_T_ANY | CMD_T_NOGAGGED | CMD_T_GOD, 0, 0},
@@ -200,11 +201,10 @@
   {"@MAIL",
    "NOEVAL NOSIG STATS DSTATS FSTATS DEBUG NUKE FOLDERS UNFOLDER LIST READ UNREAD CLEAR UNCLEAR STATUS PURGE FILE TAG UNTAG FWD FORWARD SEND SILENT URGENT",
    cmd_mail, CMD_T_ANY | CMD_T_EQSPLIT, 0, 0},
-
   {"@MALIAS",
    "SET CREATE DESTROY DESCRIBE RENAME STATS CHOWN NUKE ADD REMOVE LIST ALL WHO MEMBERS USEFLAG SEEFLAG",
    cmd_malias, CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED, 0, 0},
-
+  {"@MAPSQL", "NOTIFY COLNAMES", cmd_mapsql, CMD_T_ANY | CMD_T_EQSPLIT, 0, 0},
   {"@MESSAGE", "NOEVAL SPOOF", cmd_message,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_RS_ARGS, 0, 0},
   {"@MOTD", "CONNECT LIST WIZARD DOWN FULL", cmd_motd,
@@ -221,7 +221,7 @@
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED, 0, 0},
   {"@NSEMIT", "ROOM NOEVAL SILENT SPOOF", cmd_emit, CMD_T_ANY | CMD_T_NOGAGGED,
    0, 0},
-  {"@NSLEMIT", "NOEVAL SILENT SPOOF", cmd_lemit,
+  {"@NSLEMIT", "NOEVAL NOISY SILENT SPOOF", cmd_lemit,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED, 0, 0},
   {"@NSOEMIT", "NOEVAL SPOOF", cmd_oemit,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED, 0, 0},
@@ -231,7 +231,8 @@
    CMD_T_ANY | CMD_T_EQSPLIT, 0, 0},
   {"@NSREMIT", "LIST NOEVAL NOISY SILENT SPOOF", cmd_remit,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED, 0, 0},
-  {"@NSZEMIT", NULL, cmd_zemit, CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED,
+  {"@NSZEMIT", "NOISY SILENT", cmd_zemit,
+   CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED,
    0, 0},
   {"@NUKE", NULL, cmd_nuke, CMD_T_ANY | CMD_T_NOGAGGED, 0, 0},
 
@@ -268,7 +269,7 @@
    CMD_T_ANY | CMD_T_NOGAGGED, 0, 0},
   {"@SEARCH", NULL, cmd_search,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_RS_ARGS | CMD_T_RS_NOPARSE, 0, 0},
-  {"@SELECT", "NOTIFY REGEXP", cmd_select,
+  {"@SELECT", "NOTIFY REGEXP INPLACE", cmd_select,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_RS_ARGS | CMD_T_RS_NOPARSE, 0, 0},
   {"@SET", NULL, cmd_set, CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED, 0, 0},
   {"@SHUTDOWN", "PANIC REBOOT PARANOID", cmd_shutdown, CMD_T_ANY, "WIZARD", 0},
@@ -277,13 +278,13 @@
 #else
   {"@SQL", NULL, cmd_unimplemented, CMD_T_ANY, "WIZARD", "SQL_OK"},
 #endif
-  {"@SITELOCK", "BAN CHECK REGISTER REMOVE NAME", cmd_sitelock,
+  {"@SITELOCK", "BAN CHECK REGISTER REMOVE NAME PLAYER", cmd_sitelock,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_RS_ARGS, "WIZARD", 0},
   {"@STATS", "CHUNKS FREESPACE PAGING REGIONS TABLES", cmd_stats,
    CMD_T_ANY, 0, 0},
 
   {"@SWEEP", "CONNECTED HERE INVENTORY EXITS", cmd_sweep, CMD_T_ANY, 0, 0},
-  {"@SWITCH", "NOTIFY FIRST ALL REGEXP", cmd_switch,
+  {"@SWITCH", "NOTIFY FIRST ALL REGEXP INPLACE", cmd_switch,
    CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_RS_ARGS | CMD_T_RS_NOPARSE |
    CMD_T_NOGAGGED, 0, 0},
   {"@SQUOTA", NULL, cmd_squota, CMD_T_ANY | CMD_T_EQSPLIT, 0, 0},
@@ -314,7 +315,8 @@
   {"@WIPE", NULL, cmd_wipe, CMD_T_ANY, 0, 0},
   {"@WIZWALL", "NOEVAL EMIT", cmd_wizwall, CMD_T_ANY, "WIZARD", 0},
   {"@WIZMOTD", NULL, cmd_wizmotd, CMD_T_ANY, "WIZARD", 0},
-  {"@ZEMIT", NULL, cmd_zemit, CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED,
+  {"@ZEMIT", "NOISY SILENT", cmd_zemit,
+   CMD_T_ANY | CMD_T_EQSPLIT | CMD_T_NOGAGGED,
    0, 0},
 
   {"BUY", NULL, cmd_buy, CMD_T_ANY | CMD_T_NOGAGGED, 0, 0},
@@ -533,12 +535,16 @@
   }
   cmd->hooks.before.obj = NOTHING;
   cmd->hooks.before.attrname = NULL;
+  cmd->hooks.before.inplace = 0;
   cmd->hooks.after.obj = NOTHING;
   cmd->hooks.after.attrname = NULL;
+  cmd->hooks.after.inplace = 0;
   cmd->hooks.ignore.obj = NOTHING;
   cmd->hooks.ignore.attrname = NULL;
+  cmd->hooks.ignore.inplace = 0;
   cmd->hooks.override.obj = NOTHING;
   cmd->hooks.override.attrname = NULL;
+  cmd->hooks.override.inplace = 0;
   /* Restrict with no flags/powers, then manually parse flagstr and powerstr
      separately and add to restriction, to avoid issues with flags/powers with
      the same name (HALT flag and Halt power) */
@@ -897,7 +903,7 @@
  * \param forcenoparse if true, do no evaluation during parsing.
  */
 void
-command_argparse(dbref player, dbref cause, char **from, char *to,
+command_argparse(dbref player, dbref cause, dbref caller, char **from, char *to,
                  char *argv[], COMMAND_INFO *cmd, int right_side,
                  int forcenoparse)
 {
@@ -948,7 +954,7 @@
     aold = t;
     while (*f == ' ')
       f++;
-    if (process_expression(to, &t, (const char **) &f, player, cause, cause,
+    if (process_expression(to, &t, (const char **) &f, player, caller, cause,
                            parse, (split | args),
                            global_eval_context.pe_info)) {
       done = 1;
@@ -1039,12 +1045,13 @@
  * text to match against $-commands otherwise.
  * \param player the enactor.
  * \param cause dbref that caused the command to be executed.
+ * \param caller the caller (%@). Almost always the same as cause, differs for /inplace cmds
  * \param string the input to be parsed.
  * \param fromport if true, command was typed by a player at a socket.
  * \return NULL if a command was handled, otherwise the evaluated input.
  */
 char *
-command_parse(dbref player, dbref cause, char *string, int fromport)
+command_parse(dbref player, dbref cause, dbref caller, char *string, int fromport)
 {
   char *command, *swtch, *ls, *rs, *switches;
   static char commandraw[BUFFER_LEN];
@@ -1091,7 +1098,7 @@
   if (*p == '[') {
     if ((cmd = command_find("WARN_ON_MISSING"))) {
       if (!(cmd->type & CMD_T_DISABLED)) {
-        cmd->func(cmd, player, cause, sw, string, NULL, NULL, ls, lsa, rs, rsa);
+        cmd->func(cmd, player, cause, caller, sw, string, NULL, NULL, ls, lsa, rs, rsa);
         command_parse_free_args;
         return NULL;
       }
@@ -1169,7 +1176,7 @@
     c = command;
     while (*p == ' ')
       p++;
-    process_expression(command, &c, (const char **) &p, player, cause, cause,
+    process_expression(command, &c, (const char **) &p, player, caller, cause,
                        noevtoken ? PE_NOTHING :
                        ((PE_DEFAULT & ~PE_FUNCTION_CHECK) |
                         PE_COMMAND_BRACES), PT_SPACE,
@@ -1208,7 +1215,7 @@
         safe_chr(' ', commandraw, &c2);
         p++;
       }
-      process_expression(commandraw, &c2, (const char **) &p, player, cause,
+      process_expression(commandraw, &c2, (const char **) &p, player, caller,
                          cause, noevtoken ? PE_NOTHING :
                          ((PE_DEFAULT & ~PE_FUNCTION_CHECK) |
                           PE_COMMAND_BRACES), PT_DEFAULT,
@@ -1308,22 +1315,22 @@
 
   if ((cmd->func == command_atrset) && fromport) {
     /* Special case: eqsplit, noeval of rhs only */
-    command_argparse(player, cause, &p, ls, lsa, cmd, 0, 0);
-    command_argparse(player, cause, &p, rs, rsa, cmd, 1, 1);
+    command_argparse(player, cause, caller, &p, ls, lsa, cmd, 0, 0);
+    command_argparse(player, cause, caller, &p, rs, rsa, cmd, 1, 1);
     SW_SET(sw, SWITCH_NOEVAL);  /* Needed for ATTRIB_SET */
   } else {
     noeval = SW_ISSET(sw, SWITCH_NOEVAL) || noevtoken;
     if (cmd->type & CMD_T_EQSPLIT) {
       char *savep = p;
-      command_argparse(player, cause, &p, ls, lsa, cmd, 0, noeval);
+      command_argparse(player, cause, caller, &p, ls, lsa, cmd, 0, noeval);
       if (noeval && !noevtoken && *p) {
         /* oops, we have a right hand side, should have evaluated */
         p = savep;
-        command_argparse(player, cause, &p, ls, lsa, cmd, 0, 0);
+        command_argparse(player, cause, caller, &p, ls, lsa, cmd, 0, 0);
       }
-      command_argparse(player, cause, &p, rs, rsa, cmd, 1, noeval);
+      command_argparse(player, cause, caller, &p, rs, rsa, cmd, 1, noeval);
     } else {
-      command_argparse(player, cause, &p, ls, lsa, cmd, 0, noeval);
+      command_argparse(player, cause, caller, &p, ls, lsa, cmd, 0, noeval);
     }
   }
 
@@ -1372,7 +1379,7 @@
   }
 #ifdef NEVER
   /* We used to do this, but we're not sure why */
-  process_expression(commandraw, &c2, (const char **) &p, player, cause,
+  process_expression(commandraw, &c2, (const char **) &p, player, caller,
                      cause, noevtoken ? PE_NOTHING :
                      ((PE_DEFAULT & ~PE_EVALUATE) |
                       PE_COMMAND_BRACES), PT_DEFAULT, NULL);
@@ -1432,7 +1439,7 @@
       return 1;
     }
     run_hook(player, cause, &cmd->hooks.before, saveregs, 1);
-    cmd->func(cmd, player, cause, sw, string, swp, ap, ls, lsa, rs, rsa);
+    cmd->func(cmd, player, cause, cause, sw, string, swp, ap, ls, lsa, rs, rsa);
     run_hook(player, cause, &cmd->hooks.after, saveregs, 0);
   }
   /* Either way, we might log */
@@ -2182,10 +2189,11 @@
 
   if (cmd->hooks.override.attrname) {
     return one_comm_match(cmd->hooks.override.obj, player,
-                          cmd->hooks.override.attrname, commandraw);
+                          cmd->hooks.override.attrname, commandraw,
+                          cmd->hooks.override.inplace);
   } else {
     return atr_comm_match(cmd->hooks.override.obj, player, '$', ':', commandraw,
-                          0, 1, NULL, NULL, NULL);
+                          0, 1, NULL, NULL, NULL, cmd->hooks.override.inplace);
   }
 }
 
@@ -2198,6 +2206,7 @@
   enum hook_type flag;
   COMMAND_INFO *cmd;
   struct hook_data *h;
+  int inplace = 0;
 
   if (!opts || !*opts)
     return 0;
@@ -2216,6 +2225,10 @@
   } else if (string_prefix("after", one)) {
     flag = HOOK_AFTER;
     h = &cmd->hooks.after;
+  } else if (string_prefix("override/inplace", one)) {
+    flag = HOOK_OVERRIDE;
+    h = &cmd->hooks.override;
+    inplace = 1;
   } else if (string_prefix("override", one)) {
     flag = HOOK_OVERRIDE;
     h = &cmd->hooks.override;
@@ -2245,6 +2258,10 @@
     upcasestr(attrname);
   }
 
+  /* Account for #dbref */
+  if (*one == '#')
+    one++;
+
   if (!is_strict_integer(one))
     return 0;
 
@@ -2264,6 +2281,7 @@
     h->attrname = mush_strdup(attrname, "hook.attr");
   else
     h->attrname = NULL;
+  h->inplace = inplace;
   return 1;
 
 }
@@ -2278,10 +2296,11 @@
  * \param obj name of object containing the hook attribute.
  * \param attrname of hook attribute on obj.
  * \param flag type of hook
+ * \param inplace If override hook, whether to run it inplace.
  */
 void
 do_hook(dbref player, char *command, char *obj, char *attrname,
-        enum hook_type flag)
+        enum hook_type flag, int inplace)
 {
   COMMAND_INFO *cmd;
   struct hook_data *h;
@@ -2337,6 +2356,7 @@
     } else {
       h->attrname = mush_strdup(strupper(attrname), "hook.attr");
     }
+    h->inplace = inplace;
     notify_format(player, T("Hook set for %s"), cmd->name);
   }
 }
@@ -2405,7 +2425,8 @@
         notify_format(player, "@hook/ignore: #%d/%s",
                       cmd->hooks.ignore.obj, cmd->hooks.ignore.attrname);
       if (GoodObject(cmd->hooks.override.obj))
-        notify_format(player, "@hook/override: #%d/%s",
+        notify_format(player, "@hook/override%s: #%d/%s",
+                      cmd->hooks.override.inplace ? "/inplace" : "",
                       cmd->hooks.override.obj, cmd->hooks.override.attrname);
     }
   }
Index: src/timer.c
===================================================================
--- src/timer.c	(.../184p2)	(revision 828)
+++ src/timer.c	(.../184p3)	(revision 828)
@@ -48,8 +48,8 @@
 static sig_atomic_t hup_triggered = 0;
 static sig_atomic_t usr1_triggered = 0;
 
-extern void inactivity_check(void);
-extern void reopen_logs(void);
+bool inactivity_check(void);
+void reopen_logs(void);
 static void migrate_stuff(int amount);
 
 #ifndef WIN32
@@ -186,6 +186,93 @@
   chunk_migration(actual, refs);
 }
 
+static bool
+idle_event(void *data __attribute__ ((__unused__)))
+{
+  return inactivity_check();
+}
+
+static bool
+purge_event(void *data __attribute__ ((__unused__)))
+{
+  global_eval_context.cplr = NOTHING;
+  strcpy(global_eval_context.ccom, "purge");
+  purge();
+  strcpy(global_eval_context.ccom, "");
+  options.purge_counter = mudtime + PURGE_INTERVAL;
+  sq_register_in(PURGE_INTERVAL, purge_event, NULL, "DB`PURGE");
+  return true;
+}
+
+static bool
+dbck_event(void *data __attribute__ ((__unused__)))
+{
+  global_eval_context.cplr = NOTHING;
+  strcpy(global_eval_context.ccom, "dbck");
+  dbck();
+  strcpy(global_eval_context.ccom, "");
+  options.dbck_counter = mudtime + DBCK_INTERVAL;
+  sq_register_in(DBCK_INTERVAL, dbck_event, NULL, "DB`DBCK");
+  return true;
+}
+
+static bool
+warning_event(void *data __attribute__ ((__unused__)))
+{
+  options.warn_counter = options.warn_interval + mudtime;
+  strcpy(global_eval_context.ccom, "warnings");
+  run_topology();
+  strcpy(global_eval_context.ccom, "");
+  sq_register_in(options.warn_interval, warning_event, NULL, "DB`WCHECK");
+  return true;
+}
+
+struct dbsave_warn_data {
+  int secs;
+  const char *event;
+  char *msg;
+};
+
+struct dbsave_warn_data dbsave_5min =
+  { 300, "DUMP`5MIN", options.dump_warning_5min };
+struct dbsave_warn_data dbsave_1min =
+  { 60, "DUMP`1MIN", options.dump_warning_1min };
+
+static bool
+dbsave_warn_event(void *data)
+{
+  struct dbsave_warn_data *when = data;
+
+  queue_event(SYSEVENT, when->event, "%s,%d", when->msg, NO_FORK ? 0 : 1);
+  if (NO_FORK && *(when->msg))
+    flag_broadcast(0, 0, "%s", when->msg);
+  return false;
+}
+
+static void
+reg_dbsave_warnings(void)
+{
+  if (DUMP_INTERVAL > 300)
+    sq_register_in(DUMP_INTERVAL - 300, dbsave_warn_event, &dbsave_5min, NULL);
+  if (DUMP_INTERVAL > 60)
+    sq_register_in(DUMP_INTERVAL - 60, dbsave_warn_event, &dbsave_1min, NULL);
+}
+
+static bool
+dbsave_event(void *data __attribute__ ((__unused__)))
+{
+  log_mem_check();
+  options.dump_counter = options.dump_interval + mudtime;
+  strcpy(global_eval_context.ccom, "dump");
+  fork_and_dump(1);
+  strcpy(global_eval_context.ccom, "");
+  flag_broadcast(0, "ON-VACATION", "%s",
+                 T("Your ON-VACATION flag is set! If you're back, clear it."));
+  reg_dbsave_warnings();
+  sq_register_in(DUMP_INTERVAL, dbsave_event, NULL, NULL);
+  return false;
+}
+
 /** Handle events that may need handling.
  * This routine is polled from bsd.c. At any call, it can handle
  * the HUP and USR1 signals. At calls that are 'on the second',
@@ -193,10 +280,9 @@
  * check whether it's time to do other periodic processes like
  * purge, dump, or inactivity checks.
  */
-void
-dispatch(void)
+static bool
+on_every_second(void *data __attribute__ ((__unused__)))
 {
-  static int idle_counter = 0;
 
   /* A HUP reloads configuration and reopens logs */
   if (hup_triggered) {
@@ -211,71 +297,33 @@
   }
   /* A USR1 does a shutdown/reboot */
   if (usr1_triggered) {
-    do_rawlog(LT_ERR, "SIGUSR1 received. Rebooting.");
-    do_reboot(NOTHING, 0);      /* We don't return from this */
+    if (!queue_event(SYSEVENT, "SIGNAL`USR1", "%s", "")) {
+      do_rawlog(LT_ERR, "SIGUSR1 received. Rebooting.");
+      do_reboot(NOTHING, 0);    /* We don't return from this */
+    }
     usr1_triggered = 0;         /* But just in case */
   }
-  if (!globals.on_second)
-    return;
-  globals.on_second = 0;
 
   mudtime = time(NULL);
 
   do_second();
-
   migrate_stuff(CHUNK_MIGRATE_AMOUNT);
 
-  if (options.purge_counter <= mudtime) {
-    /* Free list reconstruction */
-    options.purge_counter = options.purge_interval + mudtime;
-    global_eval_context.cplr = NOTHING;
-    strcpy(global_eval_context.ccom, "purge");
-    purge();
-    strcpy(global_eval_context.ccom, "");
-  }
-
-  if (options.dbck_counter <= mudtime) {
-    /* Database consistency check */
-    options.dbck_counter = options.dbck_interval + mudtime;
-    global_eval_context.cplr = NOTHING;
-    strcpy(global_eval_context.ccom, "dbck");
-    dbck();
-    strcpy(global_eval_context.ccom, "");
-  }
-
-  if (idle_counter <= mudtime) {
-    /* Inactivity check */
-    idle_counter = 60 + mudtime;
-    inactivity_check();
-  }
-
-  /* Database dump routines */
-  if (options.dump_counter <= mudtime) {
-    log_mem_check();
-    options.dump_counter = options.dump_interval + mudtime;
-    strcpy(global_eval_context.ccom, "dump");
-    fork_and_dump(1);
-    strcpy(global_eval_context.ccom, "");
-    flag_broadcast(0, "ON-VACATION", "%s",
-                   T
-                   ("Your ON-VACATION flag is set! If you're back, clear it."));
-  } else if (NO_FORK &&
-             (options.dump_counter - 60 == mudtime) &&
-             *options.dump_warning_1min) {
-    flag_broadcast(0, 0, "%s", options.dump_warning_1min);
-  } else if (NO_FORK &&
-             (options.dump_counter - 300 == mudtime) &&
-             *options.dump_warning_5min) {
-    flag_broadcast(0, 0, "%s", options.dump_warning_5min);
-  }
-  if (options.warn_interval && (options.warn_counter <= mudtime)) {
-    options.warn_counter = options.warn_interval + mudtime;
-    strcpy(global_eval_context.ccom, "warnings");
-    run_topology();
-    strcpy(global_eval_context.ccom, "");
-  }
+  return false;
+}
 
-  local_timer();
+void
+init_sys_events(void)
+{
+  time(&mudtime);
+  sq_register_loop(60, idle_event, NULL, "PLAYER`INACTIVITY");
+  sq_register(mudtime + DBCK_INTERVAL, dbck_event, NULL, "DB`DBCK");
+  sq_register(mudtime + PURGE_INTERVAL, purge_event, NULL, "DB`PURGE");
+  sq_register(mudtime + options.warn_interval, warning_event, NULL,
+              "DB`WCHECK");
+  reg_dbsave_warnings();
+  sq_register(mudtime + DUMP_INTERVAL, dbsave_event, NULL, NULL);
+  sq_register_loop(1, on_every_second, NULL, NULL);
 }
 
 sig_atomic_t cpu_time_limit_hit = 0;  /** Was the cpu time limit hit? */
@@ -380,3 +428,156 @@
   timer_set = 0;
 #endif                          /* PROFILING */
 }
+
+
+/** System queue stuff. Timed events like dbcks and purges are handled
+ *  through this system. */
+
+struct squeue {
+  sq_func fun;
+  void *data;
+  time_t when;
+  char *event;
+  struct squeue *next;
+};
+
+struct squeue *sq_head = NULL;
+
+/** Register a callback function to be executed at a certain time.
+ *  \param w when to run the event
+ *  \param f the callback function
+ *  \param d data to pass to the callback
+ *  \param ev Softcode event to trigger at the same time.
+ */
+void
+sq_register(time_t w, sq_func f, void *d, const char *ev)
+{
+  struct squeue *sq;
+
+  sq = mush_malloc(sizeof *sq, "squeue.node");
+
+  sq->when = w;
+  sq->fun = f;
+  sq->data = d;
+  if (ev)
+    sq->event = mush_strdup(strupper(ev), "squeue.event");
+  else
+    sq->event = NULL;
+  sq->next = NULL;
+
+  if (!sq_head)
+    sq_head = sq;
+  else if (difftime(w, sq_head->when) <= 0) {
+    sq->next = sq_head;
+    sq_head = sq;
+  } else {
+    struct squeue *c, *prev = NULL;
+    for (prev = sq_head, c = sq_head->next; c; prev = c, c = c->next) {
+      if (difftime(w, c->when) <= 0) {
+        sq->next = c;
+        prev->next = sq;
+        return;
+      }
+    }
+    prev->next = sq;
+  }
+}
+
+/** Register a callback function to be executed in N seconds.
+ * \param n the number of seconds to run the callback after.
+ * \param f the callback function.
+ * \param d data to pass to the callback.
+ * \param ev softcode event to trigger at the same time.
+ */
+void
+sq_register_in(int n, sq_func f, void *d, const char *ev)
+{
+  time_t now;
+  time(&now);
+  sq_register(now + n, f, d, ev);
+}
+
+struct sq_loop {
+  sq_func fun;
+  void *data;
+  const char *event;
+  int secs;
+};
+
+static bool
+sq_loop_fun(void *arg)
+{
+  struct sq_loop *loop = arg;
+  bool res;
+
+  res = loop->fun(loop->data);
+  sq_register_in(loop->secs, sq_loop_fun, arg, loop->event);
+
+  return res;
+}
+
+/** Register a callback function to run every N seconds.
+ * \param n the number of seconds to wait between calls.
+ * \param f the callback function.
+ * \param d data to pass to the callback.
+ * \param ev softcode event to trigger at the same time.
+ */
+void
+sq_register_loop(int n, sq_func f, void *d, const char *ev)
+{
+  struct sq_loop *loop;
+
+  loop = mush_malloc(sizeof *loop, "squeue.node");
+  loop->fun = f;
+  loop->data = d;
+  if (ev)
+    loop->event = mush_strdup(strupper(ev), "squeue.event");
+  else
+    loop->event = NULL;
+  loop->secs = n;
+
+  sq_register_in(n, sq_loop_fun, loop, ev);
+}
+
+/** Execute a single pending system queue event.
+ * \return true if work was done, false otherwise.
+ */
+bool
+sq_run_one(void)
+{
+  time_t now;
+  struct squeue *n;
+
+  time(&now);
+
+  if (sq_head) {
+    if (difftime(sq_head->when, now) <= 0) {
+      bool r = sq_head->fun(sq_head->data);
+      if (r && sq_head->event)
+        queue_event(SYSEVENT, sq_head->event, "%s", "");
+      n = sq_head->next;
+      if (sq_head->event)
+        mush_free(sq_head->event, "squeue.event");
+      mush_free(sq_head, "squeue.node");
+      sq_head = n;
+      return true;
+    }
+  }
+  return false;
+}
+
+/** Run all pending system queue events.
+ * \return true if work was done, false otherwise.
+ */
+bool
+sq_run_all(void)
+{
+  bool r, any = false;
+
+  do {
+    r = sq_run_one();
+    if (r)
+      any = true;
+  } while (r);
+  return any;
+}
Index: src/log.c
===================================================================
--- src/log.c	(.../184p2)	(revision 828)
+++ src/log.c	(.../184p3)	(revision 828)
@@ -16,6 +16,7 @@
 #include <string.h>
 #include <stdarg.h>
 #include <stdlib.h>
+#include <limits.h>
 #ifdef I_SYS_TIME
 #include <sys/time.h>
 #ifdef TIME_WITH_SYS_TIME
@@ -36,20 +37,40 @@
 #include "log.h"
 #include "confmagic.h"
 
+struct log_stream;
+
+#define LOG_BUFFER_SIZE 1
+
 static char *quick_unparse(dbref object);
-static void start_log(FILE ** fp, const char *filename);
-static void end_log(const char *filename);
+static void start_log(struct log_stream *);
+static void end_log(struct log_stream *);
 
 BUFFERQ *activity_bq = NULL;
 
 HASHTAB htab_logfiles;  /**< Hash table of logfile names and descriptors */
 
-/* log file pointers */
-FILE *connlog_fp;  /**< Connect log */
-FILE *checklog_fp; /**< Checkpoint log */
-FILE *wizlog_fp;   /**< Wizard log */
-FILE *tracelog_fp; /**< Trace log */
-FILE *cmdlog_fp;   /**< Command log */
+#define NLOGS 7
+
+struct log_stream logs[NLOGS] = {
+  {LT_ERR, "error", ERRLOG, NULL, NULL},
+  {LT_CMD, "command", CMDLOG, NULL, NULL},
+  {LT_WIZ, "wizard", WIZLOG, NULL, NULL},
+  {LT_CONN, "connection", CONNLOG, NULL, NULL},
+  {LT_TRACE, "trace", TRACELOG, NULL, NULL},
+  {LT_CHECK, "checkpoint", CHECKLOG, NULL, NULL},
+  {LT_HUH, "huh", CMDLOG, NULL, NULL},
+};
+
+struct log_stream *
+lookup_log(enum log_type type)
+{
+  int n;
+  for (n = 0; n < NLOGS; n++)
+    if (logs[n].type == type)
+      return logs + n;
+  return NULL;
+}
+
 
 /* From wait.c */
 int lock_file(FILE *);
@@ -81,34 +102,35 @@
 }
 
 static void
-start_log(FILE ** fp, const char *filename)
+start_log(struct log_stream *log)
 {
   static int ht_initialized = 0;
   FILE *f;
 
-  if (!filename || !*filename) {
-    *fp = stderr;
+  if (!log->filename || !log->filename) {
+    log->fp = stderr;
   } else {
     if (!ht_initialized) {
       hashinit(&htab_logfiles, 8);
       ht_initialized = 1;
     }
-    if ((f = (FILE *) hashfind(strupper(filename), &htab_logfiles))) {
-      /* We've already opened this file, so just use that pointer */
-      *fp = f;
+    if ((f = hashfind(strupper(log->filename), &htab_logfiles))) {
+      /* We've already opened this file for another log, so just use that pointer */
+      log->fp = f;
     } else {
-
-      *fp = fopen(filename, "a");
-      if (*fp == NULL) {
-        fprintf(stderr, "WARNING: cannot open log %s\n", filename);
-        *fp = stderr;
+      log->fp = fopen(log->filename, "a");
+      if (log->fp == NULL) {
+        fprintf(stderr, "WARNING: cannot open log %s: %s\n", log->filename,
+                strerror(errno));
+        log->fp = stderr;
       } else {
-        hashadd(strupper(filename), (void *) *fp, &htab_logfiles);
-        fprintf(*fp, "START OF LOG.\n");
-        fflush(*fp);
+        hashadd(strupper(log->filename), log->fp, &htab_logfiles);
+        fprintf(log->fp, "START OF LOG.\n");
+        fflush(log->fp);
       }
     }
   }
+  log->buffer = allocate_bufferq(LOG_BUFFER_SIZE);
 }
 
 /** Open all logfiles.
@@ -116,11 +138,10 @@
 void
 start_all_logs(void)
 {
-  start_log(&connlog_fp, CONNLOG);
-  start_log(&checklog_fp, CHECKLOG);
-  start_log(&wizlog_fp, WIZLOG);
-  start_log(&tracelog_fp, TRACELOG);
-  start_log(&cmdlog_fp, CMDLOG);
+  int n;
+
+  for (n = 0; n < NLOGS; n++)
+    start_log(logs + n);
 }
 
 /** Redirect stderr to a error log file and close stdout and stdin. 
@@ -130,14 +151,14 @@
 void
 redirect_streams(void)
 {
-  FILE *errlog_fp;
+  FILE *fp;
 
   fprintf(stderr, "Redirecting stderr to %s\n", ERRLOG);
-  errlog_fp = fopen(ERRLOG, "a");
-  if (!errlog_fp) {
+  fp = fopen(ERRLOG, "a");
+  if (!fp) {
     fprintf(stderr, "Unable to open %s. Error output to stderr.\n", ERRLOG);
   } else {
-    fclose(errlog_fp);
+    fclose(fp);
     if (!freopen(ERRLOG, "a", stderr)) {
       printf(T("Ack!  Failed reopening stderr!"));
       exit(1);
@@ -152,17 +173,26 @@
 
 
 static void
-end_log(const char *filename)
+end_log(struct log_stream *log)
 {
   FILE *fp;
-  if (!filename || !*filename)
+
+  if (!log->filename || !*log->filename || !log->fp)
     return;
-  if ((fp = (FILE *) hashfind(strupper(filename), &htab_logfiles))) {
+  if ((fp = hashfind(strupper(log->filename), &htab_logfiles))) {
+    int n;
+
     lock_file(fp);
     fprintf(fp, "END OF LOG.\n");
     fflush(fp);
+    for (n = 0; n < NLOGS; n++)
+      if (log->fp == fp)
+        log->fp = NULL;
     fclose(fp);                 /* Implicit lock removal */
-    hashdelete(strupper(filename), &htab_logfiles);
+    free_bufferq(log->buffer);
+    log->fp = NULL;
+    log->buffer = NULL;
+    hashdelete(strupper(log->filename), &htab_logfiles);
   }
 }
 
@@ -171,13 +201,9 @@
 void
 end_all_logs(void)
 {
-  const char *name, *next;
-  name = hash_firstentry_key(&htab_logfiles);
-  while (name) {
-    next = hash_nextentry_key(&htab_logfiles);
-    end_log(name);
-    name = next;
-  }
+  int n;
+  for (n = 0; n < NLOGS; n++)
+    end_log(logs + n);
 }
 
 
@@ -188,13 +214,13 @@
  * \param fmt format string for message.
  */
 void WIN32_CDECL
-do_rawlog(int logtype, const char *fmt, ...)
+do_rawlog(enum log_type logtype, const char *fmt, ...)
 {
+  struct log_stream *log;
   struct tm *ttm;
   char timebuf[18];
   char tbuf1[BUFFER_LEN + 50];
   va_list args;
-  FILE *f = NULL;
   va_start(args, fmt);
 
 #ifdef HAS_VSNPRINTF
@@ -209,39 +235,19 @@
 
   strftime(timebuf, sizeof timebuf, "[%m/%d %H:%M:%S]", ttm);
 
-  switch (logtype) {
-  case LT_ERR:
-    f = stderr;
-    break;
-  case LT_HUH:
-  case LT_CMD:
-    start_log(&cmdlog_fp, CMDLOG);
-    f = cmdlog_fp;
-    break;
-  case LT_WIZ:
-    start_log(&wizlog_fp, WIZLOG);
-    f = wizlog_fp;
-    break;
-  case LT_CONN:
-    start_log(&connlog_fp, CONNLOG);
-    f = connlog_fp;
-    break;
-  case LT_TRACE:
-    start_log(&tracelog_fp, TRACELOG);
-    f = tracelog_fp;
-    break;
-  case LT_CHECK:
-    start_log(&checklog_fp, CHECKLOG);
-    f = checklog_fp;
-    break;
-  default:
-    f = stderr;
-    break;
+  log = lookup_log(logtype);
+
+  if (!log->fp) {
+    fprintf(stderr, "Attempt to write to %s log before it was started!\n",
+            log->name);
+    start_log(log);
   }
-  lock_file(f);
-  fprintf(f, "%s %s\n", timebuf, tbuf1);
-  fflush(f);
-  unlock_file(f);
+
+  lock_file(log->fp);
+  fprintf(log->fp, "%s %s\n", timebuf, tbuf1);
+  fflush(log->fp);
+  unlock_file(log->fp);
+  add_to_bufferq(log->buffer, logtype, GOD, tbuf1);
 }
 
 /** Log a message, with useful information.
@@ -254,7 +260,7 @@
  * \param fmt mesage format string.
  */
 void WIN32_CDECL
-do_log(int logtype, dbref player, dbref object, const char *fmt, ...)
+do_log(enum log_type logtype, dbref player, dbref object, const char *fmt, ...)
 {
   /* tbuf1 had 50 extra chars because we might pass this function
    * both a label string and a command which could be up to BUFFER_LEN
@@ -324,6 +330,45 @@
   }
 }
 
+/** Recall lines from a log.
+ *
+ * \param player the enactor.
+ * \param type the log to recall from.
+ * \param lines the number of lines to recall. 0 for all.
+ */
+void
+do_log_recall(dbref player, enum log_type type, int lines)
+{
+  dbref dummy_dbref = NOTHING;
+  int dummy_type = 0, nlines = 0;
+  time_t dummy_ts;
+  char *line, *p;
+  struct log_stream *log;
+
+  if (lines <= 0)
+    lines = INT_MAX;
+
+  log = lookup_log(type);
+
+  if (lines != INT_MAX) {
+    p = NULL;
+    while (iter_bufferq(log->buffer, &p, &dummy_dbref, &dummy_type, &dummy_ts))
+      nlines += 1;
+  } else
+    nlines = INT_MAX;
+
+  notify(player, T("Begin log recall."));
+  p = NULL;
+  while ((line =
+          iter_bufferq(log->buffer, &p, &dummy_dbref, &dummy_type,
+                       &dummy_ts))) {
+    if (nlines <= lines)
+      notify(player, line);
+    nlines -= 1;
+  }
+  notify(player, T("End log recall."));
+}
+
 /** Wipe out a game log. This is intended for those emergencies where
  * the log has grown out of bounds, overflowing the disk quota, etc.
  * Because someone with the god password can use this command to wipe
@@ -334,67 +379,31 @@
  * \param str password for wiping logs.
  */
 void
-do_logwipe(dbref player, int logtype, char *str)
+do_logwipe(dbref player, enum log_type logtype, char *str)
 {
+  struct log_stream *log;
+
+  log = lookup_log(logtype);
+
   if (strcmp(str, LOG_WIPE_PASSWD)) {
-    const char *lname;
-    switch (logtype) {
-    case LT_CONN:
-      lname = "connection";
-      break;
-    case LT_CHECK:
-      lname = "checkpoint";
-      break;
-    case LT_CMD:
-      lname = "command";
-      break;
-    case LT_TRACE:
-      lname = "trace";
-      break;
-    case LT_WIZ:
-      lname = "wizard";
-      break;
-    default:
-      lname = "unspecified";
-    }
     notify(player, T("Wrong password."));
     do_log(LT_WIZ, player, NOTHING,
-           "Invalid attempt to wipe the %s log, password %s", lname, str);
+           "Invalid attempt to wipe the %s log, password %s", log->name, str);
     return;
   }
   switch (logtype) {
   case LT_CONN:
-    end_log(CONNLOG);
-    unlink(CONNLOG);
-    start_log(&connlog_fp, CONNLOG);
-    do_log(LT_ERR, player, NOTHING, "Connect log wiped.");
-    break;
   case LT_CHECK:
-    end_log(CHECKLOG);
-    unlink(CHECKLOG);
-    start_log(&checklog_fp, CHECKLOG);
-    do_log(LT_ERR, player, NOTHING, "Checkpoint log wiped.");
-    break;
   case LT_CMD:
-    end_log(CMDLOG);
-    unlink(CMDLOG);
-    start_log(&cmdlog_fp, CMDLOG);
-    do_log(LT_ERR, player, NOTHING, "Command log wiped.");
-    break;
   case LT_TRACE:
-    end_log(TRACELOG);
-    unlink(TRACELOG);
-    start_log(&tracelog_fp, TRACELOG);
-    do_log(LT_ERR, player, NOTHING, "Trace log wiped.");
-    break;
   case LT_WIZ:
-    end_log(WIZLOG);
-    unlink(WIZLOG);
-    start_log(&wizlog_fp, WIZLOG);
-    do_log(LT_ERR, player, NOTHING, "Wizard log wiped.");
+    end_log(log);
+    unlink(log->filename);
+    start_log(log);
+    do_log(LT_ERR, player, NOTHING, "%s log wiped.", log->name);
     break;
   default:
-    notify(player, T("That is not a valid log."));
+    notify(player, T("That is not a clearable log."));
     return;
   }
   notify(player, T("Log wiped."));
@@ -407,7 +416,7 @@
  * \param action message to log.
  */
 void
-log_activity(int type, dbref player, const char *action)
+log_activity(enum log_act_type type, dbref player, const char *action)
 {
   if (!activity_bq)
     activity_bq = allocate_bufferq(ACTIVITY_LOG_SIZE);
Index: src/help.c
===================================================================
--- src/help.c	(.../184p2)	(revision 828)
+++ src/help.c	(.../184p3)	(revision 828)
@@ -36,7 +36,8 @@
 static const char *string_spitfile(help_file *help_dat, char *arg1);
 static help_indx *help_find_entry(help_file *help_dat, const char *the_topic);
 static char **list_matching_entries(const char *pattern,
-                                    help_file *help_dat, int *len);
+                                    help_file *help_dat, int *len,
+                                    bool nospace);
 static void free_entry_list(char **);
 static const char *normalize_entry(help_file *help_dat, const char *arg1);
 
@@ -56,9 +57,12 @@
 
 static void write_topic(long int p);
 
+extern bool help_wild(const char *restrict tstr, const char *restrict dstr);
+
 COMMAND(cmd_helpcmd)
 {
   help_file *h;
+  char save[BUFFER_LEN];
 
   h = hashfind(cmd->name, &help_files);
 
@@ -72,11 +76,12 @@
     return;
   }
 
+  strcpy(save, arg_left);
   if (wildcard_count(arg_left, 1) == -1) {
     int len = 0;
     char **entries;
 
-    entries = list_matching_entries(arg_left, h, &len);
+    entries = list_matching_entries(arg_left, h, &len, 0);
     if (len == 0)
       notify_format(player, T("No entries matching '%s' were found."),
                     arg_left);
@@ -93,8 +98,66 @@
                     arg_left, buff);
     }
     free_entry_list(entries);
-  } else
-    do_new_spitfile(player, arg_left, h);
+  } else {
+    help_indx *entry = NULL;
+    entry = help_find_entry(h, arg_left);
+    if (entry) {
+      do_new_spitfile(player, arg_left, h);
+    } else {
+      char pattern[BUFFER_LEN], *pp, *sp;
+      char **entries;
+      int len = 0;
+      int type = 0;
+      pp = pattern;
+      sp = save;
+      for (sp = save; *sp; sp++) {
+        if (isspace((unsigned char) *sp)) {
+          if (type) {
+            type = 0;
+            *pp = '*';
+            pp++;
+            if (pp >= (pattern + BUFFER_LEN)) {
+              notify_format(player, T("No entry for '%s'"), arg_left);
+              return;
+            }
+          }
+        } else if (strchr("0123456789", *sp)) {
+          if (type == 1) {
+            type = 2;
+            *pp = '*';
+            pp++;
+            if (pp >= (pattern + BUFFER_LEN)) {
+              notify_format(player, T("No entry for '%s'"), arg_left);
+              return;
+            }
+          }
+        } else if (type != 1) {
+          type = 1;
+        }
+        *pp = *sp;
+        pp++;
+        if (pp >= (pattern + BUFFER_LEN)) {
+          notify_format(player, T("No entry for '%s'"), arg_left);
+          return;
+        }
+      }
+      *pp = '\0';
+      entries = list_matching_entries(pattern, h, &len, 1);
+      if (len == 0)
+        notify_format(player, T("No entry for '%s'"), arg_left);
+      else if (len == 1)
+        do_new_spitfile(player, *entries, h);
+      else {
+        char buff[BUFFER_LEN];
+        char *bp;
+        bp = buff;
+        arr2list(entries, len, buff, &bp, ", ");
+        *bp = '\0';
+        notify_format(player, T("Here are the entries which match '%s':\n%s"),
+                      arg_left, buff);
+      }
+    }
+  }
 }
 
 /** Initialize the helpfile hashtable, which contains the names of thes
@@ -482,7 +545,7 @@
   if (wildcard_count(args[1], 1) == -1) {
     char **entries;
     int len = 0;
-    entries = list_matching_entries(args[1], h, &len);
+    entries = list_matching_entries(args[1], h, &len, 0);
     if (len == 0)
       safe_str(T("No matching help topics."), buff, bp);
     else
@@ -512,7 +575,7 @@
   if (nargs > 2)
     sep = args[2];
 
-  entries = list_matching_entries(args[1], h, &len);
+  entries = list_matching_entries(args[1], h, &len, 0);
   if (entries) {
     arr2list(entries, len, buff, bp, sep);
     free_entry_list(entries);
@@ -577,7 +640,8 @@
 
 /** Return a string with all help entries that match a pattern */
 static char **
-list_matching_entries(const char *pattern, help_file *help_dat, int *len)
+list_matching_entries(const char *pattern, help_file *help_dat, int *len,
+                      bool nospace)
 {
   char **buff;
   int offset;
@@ -613,7 +677,8 @@
   *len = 0;
 
   for (n = 0; n < help_dat->entries; n++)
-    if (quick_wild(pattern, help_dat->indx[n].topic + offset)) {
+    if ((nospace ? help_wild(pattern, help_dat->indx[n].topic + offset)
+         : quick_wild(pattern, help_dat->indx[n].topic + offset))) {
       buff[*len] = help_dat->indx[n].topic + offset;
       *len += 1;
     }
Index: src/pcre.c
===================================================================
--- src/pcre.c	(.../184p2)	(revision 828)
+++ src/pcre.c	(.../184p3)	(revision 828)
@@ -1272,6 +1272,7 @@
 
 
 
+
 pcre_get_substring_list(const char *subject, int *ovector, int stringcount,
                         const char ***listptr);
 
@@ -1371,6 +1372,7 @@
 
 
 
+
 pcre_get_substring(const char *subject, int *ovector, int stringcount,
                    int stringnumber, const char **stringptr);
 
@@ -1437,6 +1439,7 @@
 
 
 
+
 pcre_get_named_substring(const pcre * code, const char *subject, int *ovector,
                          int stringcount, const char *stringname,
                          const char **stringptr);
@@ -2321,6 +2324,7 @@
 
 
 
+
 
 
 
Index: src/predicat.c
===================================================================
--- src/predicat.c	(.../184p2)	(revision 828)
+++ src/predicat.c	(.../184p3)	(revision 828)
@@ -42,7 +42,7 @@
 
 int forbidden_name(const char *name);
 void do_switch(dbref player, char *expression, char **argv,
-               dbref cause, int first, int notifyme, int regexp);
+               dbref cause, int first, int notifyme, int regexp, int inplace);
 void do_verb(dbref player, dbref cause, char *arg1, char **argv);
 static void grep_add_attr(char *buff, char **bp, dbref player, int count,
                           ATTR *attr, char *atrval);
@@ -691,13 +691,14 @@
  *   Names may not have leading or trailing spaces.
  *   Names must be only printable characters.
  *   Names may not exceed the length limit.
- *   Names may not start with certain tokens, or be "me", "home", "here"
+ *   Names may not start with certain tokens, or be "home", "here", or (for non-exits) "me"
  * \param n name to check.
+ * \param is_exit is the name for an exit/exit alias?
  * \retval 1 name is valid.
  * \retval 0 name is not valid.
  */
 int
-ok_name(const char *n)
+ok_name(const char *n, int is_exit)
 {
   const unsigned char *p, *name = (const unsigned char *) n;
 
@@ -732,7 +733,7 @@
           && *name
           && *name != LOOKUP_TOKEN
           && *name != NUMBER_TOKEN
-          && *name != NOT_TOKEN && strcasecmp((char *) name, "me")
+          && *name != NOT_TOKEN && (is_exit || strcasecmp((char *) name, "me"))
           && strcasecmp((char *) name, "home")
           && strcasecmp((char *) name, "here"));
 }
@@ -755,7 +756,7 @@
   const unsigned char *scan, *good;
   dbref lookup;
 
-  if (!ok_name(name) || strlen(name) >= (size_t) PLAYER_NAME_LIMIT)
+  if (!ok_name(name, 0) || strlen(name) >= (size_t) PLAYER_NAME_LIMIT)
     return 0;
 
   good = (unsigned char *) (PLAYER_NAME_SPACES ? " `$_-.,'" : "`$_-.,'");
@@ -779,6 +780,131 @@
   return ((lookup == NOTHING) || (lookup == thing));
 }
 
+/** Is name a valid new name for thing, when set by player?
+ * Parses names and aliases for players/exits, validating each. If everything is valid,
+ * the new name and alias are set into newname and newalias, with memory malloc'd as necessary.
+ * For things/rooms, no parsing is done, and ok_name is called on the entire string to validate.
+ * For players and exits, if name takes the format <name>; then newname is set to <name> and
+ * newalias to ";", to signify that the existing alias should be cleared. If name contains a name and
+ * valid aliases, newname and newalias are set accordingly.
+ * \param name the new name to set
+ * \param player the player setting the name, for permission checks
+ * \param thing object getting the name, or NOTHING for new objects
+ * \param type type of object getting the name (necessary for new exits)
+ * \param newname pointer to place the new name, once validated
+ * \param newalias pointer to place the alias in, if any
+ * \retval 1 name and any given aliases are valid
+ * \retval 0 invalid name
+ * \retval OPAE_INVALID invalid aliases
+ * \retval OPAE_TOOMANY too many aliases for player
+ */
+int
+ok_object_name(char *name, dbref player, dbref thing, int type, char **newname,
+               char **newalias)
+{
+  char *bon, *eon;
+  char nbuff[BUFFER_LEN], abuff[BUFFER_LEN];
+  char *ap = abuff;
+  int aliases = 0;
+  int empty = 0;
+
+  strncpy(nbuff, name, BUFFER_LEN - 1);
+  nbuff[BUFFER_LEN - 1] = '\0';
+  memset(abuff, 0, BUFFER_LEN);
+
+  /* First, check for a quoted player name */
+  if (type == TYPE_PLAYER && *name == '"') {
+    /* Quoted player name, no aliases allowed */
+    bon = nbuff;
+    bon++;
+    eon = bon;
+    while (*eon && *eon != '"')
+      eon++;
+    if (*eon)
+      *eon = '\0';
+    if (!ok_player_name(bon, player, thing))
+      return 0;
+    *newname = mush_strdup(bon, "name.newname");
+    return 1;
+  }
+
+  if (type & (TYPE_THING | TYPE_ROOM)) {
+    /* No aliases in the name */
+    if (!ok_name(nbuff, 0))
+      return 0;
+    *newname = mush_strdup(nbuff, "name.newname");
+    return 1;
+  }
+
+  /* A player or exit name, with aliases allowed.
+   * Possible things to parse:
+   * <name>  - just a new name
+   * <name>; - new name with trailing ; to clear alias
+   * <name>;<alias1>[;<aliasN>] - name with one or more aliases, separated by ;
+   */
+
+  /* Validate name first */
+  bon = nbuff;
+  if ((eon = strchr(bon, ALIAS_DELIMITER))) {
+    *eon++ = '\0';
+    aliases++;
+  }
+  if (!
+      (type ==
+       TYPE_PLAYER ? ok_player_name(bon, player, thing) : ok_name(bon, 1)))
+    return 0;
+
+  *newname = mush_strdup(bon, "name.newname");
+
+  if (aliases) {
+    /* We had aliases, so parse them */
+    while (eon) {
+      if (empty)
+        return OPAE_NULL;       /* Null alias only valid as a single, final alias */
+      bon = eon;
+      if ((eon = strchr(bon, ALIAS_DELIMITER))) {
+        *eon++ = '\0';
+      }
+      while (*bon && *bon == ' ')
+        bon++;
+      if (!*bon) {
+        empty = 1;              /* empty alias, should only happen if we have no proper aliases */
+        continue;
+      }
+      if (!
+          (type ==
+           TYPE_PLAYER ? ok_player_name(bon, player, thing) : ok_name(bon,
+                                                                      1))) {
+        *newalias = mush_strdup(bon, "name.newname");   /* So we can report the invalid alias */
+        return OPAE_INVALID;
+      }
+      if (aliases > 1) {
+        safe_chr(ALIAS_DELIMITER, abuff, &ap);
+      }
+      safe_str(bon, abuff, &ap);
+      aliases++;
+    }
+  }
+  *ap = '\0';
+
+  if (aliases) {
+    if (!Wizard(player) && type == TYPE_PLAYER && aliases > MAX_ALIASES)
+      return OPAE_TOOMANY;
+    if (*abuff) {
+      /* We have actual aliases */
+      *newalias = mush_strdup(abuff, "name.newname");
+    } else {
+      ap = abuff;
+      safe_chr(ALIAS_DELIMITER, abuff, &ap);
+      *ap = '\0';
+      /* We just want to clear the existing alias */
+      *newalias = mush_strdup(abuff, "name.newname");
+    }
+  }
+
+  return 1;
+}
+
 
 /** Is a alias a valid player alias-list for thing?
  * It must be a semicolon-separated list of valid player names
@@ -991,7 +1117,7 @@
  */
 void
 do_switch(dbref player, char *expression, char **argv, dbref cause,
-          int first, int notifyme, int regexp)
+          int first, int notifyme, int regexp, int inplace)
 {
   int any = 0, a;
   char buff[BUFFER_LEN], *bp;
@@ -999,6 +1125,9 @@
   char *tbuf1;
   PE_Info *pe_info;
   int i = 0;
+  char ibuff[BUFFER_LEN], *ibp;
+
+  ibp = ibuff;
 
   if (!argv[1])
     return;
@@ -1023,8 +1152,37 @@
     /* check for a match */
     if (regexp ? quick_regexp_match(buff, expression, 0)
         : local_wild_match(buff, expression)) {
-      any = 1;
       tbuf1 = replace_string("#$", expression, argv[a + 1]);
+      if (inplace) {
+        if (any) {
+          safe_chr(';', ibuff, &ibp);
+        }
+        safe_str(tbuf1, ibuff, &ibp);
+      } else {
+        pe_info = make_pe_info();
+        if (global_eval_context.pe_info->switch_nesting >= 0) {
+          for (i = 0; i <= global_eval_context.pe_info->switch_nesting; i++) {
+            pe_info->switch_text[i] =
+              mush_strdup(global_eval_context.pe_info->switch_text[i],
+                          "switch_arg");
+          }
+        }
+        pe_info->switch_text[i] = mush_strdup(expression, "switch_arg");
+        pe_info->switch_nesting = i;
+        pe_info->local_switch_nesting = i;
+        parse_que(player, tbuf1, cause, pe_info);
+      }
+      mush_free(tbuf1, "replace_string.buff");
+      any = 1;
+    }
+  }
+
+  /* do default if nothing has been matched */
+  if ((a < MAX_ARG) && !any && argv[a]) {
+    tbuf1 = replace_string("#$", expression, argv[a]);
+    if (inplace) {
+      safe_str(tbuf1, ibuff, &ibp);
+    } else {
       pe_info = make_pe_info();
       if (global_eval_context.pe_info->switch_nesting >= 0) {
         for (i = 0; i <= global_eval_context.pe_info->switch_nesting; i++) {
@@ -1037,30 +1195,23 @@
       pe_info->switch_nesting = i;
       pe_info->local_switch_nesting = i;
       parse_que(player, tbuf1, cause, pe_info);
-      mush_free(tbuf1, "replace_string.buff");
     }
+    mush_free(tbuf1, "replace_string.buff");
   }
 
-  /* do default if nothing has been matched */
-  if ((a < MAX_ARG) && !any && argv[a]) {
-    tbuf1 = replace_string("#$", expression, argv[a]);
-    pe_info = make_pe_info();
-    if (global_eval_context.pe_info->switch_nesting >= 0) {
-      for (i = 0; i <= global_eval_context.pe_info->switch_nesting; i++) {
-        pe_info->switch_text[i] =
-          mush_strdup(global_eval_context.pe_info->switch_text[i],
-                      "switch_arg");
-      }
-    }
-    pe_info->switch_text[i] = mush_strdup(expression, "switch_arg");
-    pe_info->switch_nesting = i;
-    pe_info->local_switch_nesting = i;
-    parse_que(player, tbuf1, cause, pe_info);
-    mush_free(tbuf1, "replace_string.buff");
+  if (inplace && (ibp > ibuff)) {
+    /* Set up %$* / stext() */
+    global_eval_context.pe_info->switch_nesting++;
+    global_eval_context.pe_info->local_switch_nesting++;
+    global_eval_context.pe_info->switch_text[global_eval_context.pe_info->switch_nesting] =
+      mush_strdup(expression, "switch_arg");
+    
+    *ibp = '\0';
+    inplace_queue_actionlist(player, cause, cause, ibuff, global_eval_context.wnxt, QUEUE_INPLACE);
   }
 
   /* Pop on @notify me, if requested */
-  if (notifyme)
+  if (notifyme && !inplace)
     parse_que(player, "@notify me", cause, NULL);
 }
 
@@ -1097,9 +1248,7 @@
 
   /* we already have a terminating null, so we're okay to just do matches */
   return match_result(player, box, NOTYPE,
-                      MAT_NEIGHBOR | MAT_POSSESSION | MAT_ENGLISH | (exits ?
-                                                                     MAT_EXIT :
-                                                                     0));
+                      MAT_NEAR_THINGS | MAT_ENGLISH | (exits ? MAT_EXIT : 0));
 }
 
 
Index: src/switchinc.c
===================================================================
--- src/switchinc.c	(.../184p2)	(revision 828)
+++ src/switchinc.c	(.../184p3)	(revision 828)
@@ -20,6 +20,7 @@
   {"CLEAR", SWITCH_CLEAR},
   {"CLONE", SWITCH_CLONE},
   {"CMD", SWITCH_CMD},
+  {"COLNAMES", SWITCH_COLNAMES},
   {"COMBINE", SWITCH_COMBINE},
   {"COMMANDS", SWITCH_COMMANDS},
   {"CONN", SWITCH_CONN},
@@ -64,10 +65,12 @@
   {"HIDE", SWITCH_HIDE},
   {"IGNORE", SWITCH_IGNORE},
   {"ILIST", SWITCH_ILIST},
+  {"INPLACE", SWITCH_INPLACE},
   {"INSIDE", SWITCH_INSIDE},
   {"INVENTORY", SWITCH_INVENTORY},
   {"IPRINT", SWITCH_IPRINT},
   {"JOIN", SWITCH_JOIN},
+  {"LEAVE", SWITCH_LEAVE},
   {"LETTER", SWITCH_LETTER},
   {"LIMIT", SWITCH_LIMIT},
   {"LIST", SWITCH_LIST},
@@ -101,6 +104,7 @@
   {"PANIC", SWITCH_PANIC},
   {"PARANOID", SWITCH_PARANOID},
   {"PARENT", SWITCH_PARENT},
+  {"PLAYER", SWITCH_PLAYER},
   {"PLAYERS", SWITCH_PLAYERS},
   {"PORT", SWITCH_PORT},
   {"POWERS", SWITCH_POWERS},
Index: src/set.c
===================================================================
--- src/set.c	(.../184p2)	(revision 828)
+++ src/set.c	(.../184p3)	(revision 828)
@@ -52,6 +52,7 @@
 
 extern int rhs_present;         /* from command.c */
 
+
 /** Rename something.
  * \verbatim
  * This implements @name.
@@ -64,73 +65,93 @@
 do_name(dbref player, const char *name, char *newname_)
 {
   dbref thing;
-  char *eon;                    /* End Of Name */
-  char *bon;                    /* Beginning of name */
   char *myenv[10];
   int i;
   char *newname;
+  char *alias = NULL;
 
   if ((thing = match_controlled(player, name)) == NOTHING)
     return;
 
-  newname = mush_strdup(trim_space_sep(newname_, ' '), "name.newname");
-  bon = newname;
-
   /* check for bad name */
-  if ((*newname == '\0') || strchr(newname, '[')) {
+  if ((*newname_ == '\0') || strchr(newname_, '[')) {
     notify(player, T("Give it what new name?"));
-    mush_free(newname, "name.newname");
     return;
   }
-  /* check for renaming a player */
-  if (IsPlayer(thing)) {
-    // If it has "s, it's surrounding a spaced name, likely. So bon
-    // is beginning of name.
-    // I'm going to cheat here and make it so
-    // @name me="foo"bar names somebody foo, since " is an invalid name.
-    if (*bon == '"') {
-      bon++;
-      eon = bon;
-      while (*eon && *eon != '"') {
-        eon++;
-      }
-      if (*eon) {
-        *eon = '\0';
-      }
-    }
-    if (!ok_player_name(bon, player, thing)) {
+  switch Typeof
+    (thing) {
+  case TYPE_PLAYER:
+    switch (ok_object_name
+            (newname_, player, thing, TYPE_PLAYER, &newname, &alias)) {
+    case 0:
       notify(player, T("You can't give a player that name."));
+      return;
+    case OPAE_TOOMANY:
+      notify(player, T("Too many aliases."));
+      mush_free(newname, "name.newname");
+      return;
+    case OPAE_INVALID:
+      notify_format(player, T("'%s' is not a valid alias."), alias);
       mush_free(newname, "name.newname");
+      mush_free(alias, "name.newname");
       return;
     }
-    /* everything ok, notify */
-    do_log(LT_CONN, 0, 0, "Name change by %s(#%d) to %s",
-           Name(thing), thing, bon);
-    if (Suspect(thing))
-      flag_broadcast("WIZARD", 0,
-                     T("Broadcast: Suspect %s changed name to %s."),
-                     Name(thing), bon);
-    /* everything ok, we can fall through to change the name */
-  } else {
-    bon = newname;
-    if (!ok_name(newname)) {
+    break;
+  case TYPE_EXIT:
+    if (ok_object_name(newname_, player, thing, TYPE_EXIT, &newname, &alias) <
+        1) {
       notify(player, T("That is not a reasonable name."));
-      mush_free(newname, "name.newname");
+      if (newname)
+        mush_free(newname, "name.newname");
+      if (alias)
+        mush_free(alias, "name.newname");
       return;
     }
-  }
+    break;
+  case TYPE_THING:
+  case TYPE_ROOM:
+    if (!ok_name(newname_, 0)) {
+      notify(player, T("That is not a reasonable name."));
+      return;
+    }
+    newname = mush_strdup(trim_space_sep(newname_, ' '), "name.newname");
+    break;
+  default:
+    /* Should never occur */
+    notify(player, T("I don't see that here."));
+    return;
+    }
 
-  /* everything ok, change the name */
+  /* Actually change it */
   myenv[0] = (char *) mush_malloc(BUFFER_LEN, "string");
   myenv[1] = (char *) mush_malloc(BUFFER_LEN, "string");
   mush_strncpy(myenv[0], Name(thing), BUFFER_LEN);
-  strcpy(myenv[1], bon);
+  strcpy(myenv[1], newname);
   for (i = 2; i < 10; i++)
     myenv[i] = NULL;
 
-  if (IsPlayer(thing))
-    reset_player_list(thing, Name(thing), NULL, bon, NULL);
-  set_name(thing, bon);
+  if (IsPlayer(thing)) {
+    do_log(LT_CONN, 0, 0, "Name change by %s(#%d) to %s",
+           Name(thing), thing, newname);
+    if (Suspect(thing))
+      flag_broadcast("WIZARD", 0,
+                     T("Broadcast: Suspect %s changed name to %s."),
+                     Name(thing), newname);
+    reset_player_list(thing, Name(thing), NULL, newname, NULL);
+  }
+  set_name(thing, newname);
+  if (alias) {
+    if (*alias == ALIAS_DELIMITER) {
+      do_set_atr(thing, "ALIAS", NULL, player, 0);
+    } else {
+      /* New alias to set */
+      do_set_atr(thing, "ALIAS", alias, player, 0);
+    }
+    mush_free(alias, "name.newname");
+  }
+
+  queue_event(player, "OBJECT`RENAME", "%s,%s,%s",
+              unparse_objid(thing), myenv[1], myenv[0]);
 
   if (!AreQuiet(player, thing))
     notify(player, T("Name set."));
@@ -139,6 +160,7 @@
   mush_free(newname, "name.newname");
   mush_free(myenv[0], "string");
   mush_free(myenv[1], "string");
+
 }
 
 /** Change an object's owner.
@@ -349,6 +371,7 @@
 {
   dbref thing;
   dbref zone;
+  int has_lock;
 
   if ((thing = noisy_match_result(player, name, NOTYPE, MAT_NEARBY)) == NOTHING)
     return 0;
@@ -382,11 +405,17 @@
    * 3.  an object with a chzone-lock that the player passes.
    * Note that an object with no chzone-lock isn't valid
    */
+  has_lock = (getlock(zone, Chzone_Lock) != TRUE_BOOLEXP);
   if (!(Wizard(player) || (zone == NOTHING) || Owns(player, zone) ||
-        ((getlock(zone, Chzone_Lock) != TRUE_BOOLEXP) &&
-         eval_lock(player, zone, Chzone_Lock)))) {
-    if (noisy)
-      notify(player, T("You cannot move that object to that zone."));
+        (has_lock && eval_lock(player, zone, Chzone_Lock)))) {
+    if (noisy) {
+      if (has_lock) {
+        fail_lock(player, zone, Chzone_Lock,
+                  T("You cannot move that object to that zone."), NOTHING);
+      } else {
+        notify(player, T("You cannot move that object to that zone."));
+      }
+    }
     return 0;
   }
   /* Don't chzone object to itself for mortals! */
@@ -711,12 +740,13 @@
       newobj = noisy_match_result(player, tbuf1, NOTYPE, MAT_EVERYTHING);
       if (GoodObject(newobj) &&
           ((newobj != oldobj) || strcasecmp(AL_NAME(a), q)) &&
-          do_set_atr(newobj, q, text, player, 1))
+          (do_set_atr(newobj, q, text, player, 1) == 1)) {
         copies++;
-      /* copy the attribute flags too */
-      if (!noflagcopy)
-        copy_attrib_flags(player, newobj,
-                          atr_get_noparent(newobj, strupper(q)), a->flags);
+        /* copy the attribute flags too */
+        if (!noflagcopy)
+          copy_attrib_flags(player, newobj,
+                            atr_get_noparent(newobj, strupper(q)), a->flags);
+      }
 
     }
   }
@@ -873,7 +903,7 @@
   *tbufap = '\0';
 
   if (gargs->doit) {
-    if (do_set_atr(thing, AL_NAME(a), tbuf1, player, 0) &&
+    if ((do_set_atr(thing, AL_NAME(a), tbuf1, player, 0) == 1) &&
         !AreQuiet(player, thing)) {
       if (!ansi_long_flag && ShowAnsi(player))
         notify_format(player, T("%s - Set: %s"), AL_NAME(a), tbuf_ansi);
@@ -993,14 +1023,14 @@
  * This implements @include obj/attribute
  * \endverbatim
  * \param player the enactor.
+ * \param cause the cause.
  * \param object the object/attribute pair.
- * \param argv array of arguments. (not yet used)
+ * \param argv array of arguments.
  */
 void
-do_include(dbref player, char *object, char **argv)
+do_include(dbref player, dbref cause, char *object, char **argv)
 {
   dbref thing;
-  int a;
   char *s;
   char tbuf1[BUFFER_LEN];
 
@@ -1022,17 +1052,16 @@
     return;
   }
   /* include modifies the stack, but only if arguments are given */
-  for (a = 0; a < 10; a++) {
-    if (rhs_present && argv[a + 1])
-      global_eval_context.include_wenv[a] =
-        mush_strdup(argv[a + 1], "include_wenv");
-    else
-      global_eval_context.include_wenv[a] = NULL;
-  }
-  if (!inplace_queue_attribute(thing, upcasestr(s), player, rhs_present)) {
-    notify(player, T("No such attribute."));
+  if (rhs_present) {
+    if (!queue_include_attribute(thing, upcasestr(s), player, cause, cause, argv + 1)) {
+      notify(player, T("No such attribute."));
+    }
+  } else {
+    if (!queue_include_attribute(thing, upcasestr(s), player,
+                                 cause, cause, global_eval_context.wenv)) {
+      notify(player, T("No such attribute."));
+    }
   }
-
 }
 
 /** The use command.
Index: src/cque.c
===================================================================
--- src/cque.c	(.../184p2)	(revision 828)
+++ src/cque.c	(.../184p3)	(revision 828)
@@ -14,6 +14,7 @@
 #include <limits.h>
 #include <signal.h>
 #include <string.h>
+#include <stdarg.h>
 #ifdef I_SYS_TIME
 #include <sys/time.h>
 #ifdef TIME_WITH_SYS_TIME
@@ -52,10 +53,11 @@
  * entries (a queue). It is used for all of the queues.
  */
 typedef struct bque {
-  struct bque *next;                    /**< pointer to next entry on queue */
+  struct bque *next;            /**< pointer to next entry on queue */
   dbref player;                 /**< player who will do command */
   dbref queued;                 /**< object whose QUEUE gets incremented for this command */
   dbref cause;                  /**< player causing command (for %N) */
+  dbref caller;                 /**< object who will be the initial caller (%@). Identical to cause, except for /inplace cmds */
   dbref sem;                    /**< semaphore object to block on */
   char *semattr;                /**< semaphore attribute to block on */
   time_t left;                  /**< seconds left until execution */
@@ -63,6 +65,7 @@
   char *rval[NUMQ];             /**< environment, from setq() */
   char *comm;                   /**< command to be executed */
   uint32_t pid;                 /**< Process id of this entry */
+  int quetype;                  /**< Type of the queue entry. */
   PE_Info *pe_info;             /**< pe_info for evaluating queue, or NULL */
 } BQUE;
 
@@ -208,7 +211,8 @@
     mush_free(point->comm, "cqueue.comm");
   if (point->pe_info)
     free_pe_info(point->pe_info);
-  im_delete(queue_map, point->pid);
+  if (point->pid) /* INPLACE queue entries have no pid */
+    im_delete(queue_map, point->pid);
   mush_free(point, "cqueue");
 }
 
@@ -285,7 +289,167 @@
   }
 }
 
-/** Add a new entry onto the player or object command queues.
+#define DELIM_CHAR '\x11'
+/** If EVENT_HANDLER config option is set to a valid dbref, try triggering
+ * its handler attribute
+ * \param event The event. No spaces, only alphanumerics and dashes.
+ * \param enactor The enactor who caused it.
+ * \param argstring A comma-deliminated string defining printf-style args.
+ * \param ... The args passed to argstring.
+ * \retval 1 The event had a handler attribute.
+ * \retval 0 No event handler or no attribute for the given event.
+ */
+bool
+queue_event(dbref enactor, const char *event, const char *fmt, ...)
+{
+  char myfmt[BUFFER_LEN];
+  char buff[BUFFER_LEN * 4];
+  va_list args;
+  char *s, *snext;
+  ATTR *a;
+  char *aval;
+  int argcount = 0;
+  char *wenv[10];
+  int i, len;
+  BQUE *tmp;
+  int pid;
+
+  /* Make sure we have an event to call, first. */
+  if (!GoodObject(EVENT_HANDLER) || IsGarbage(EVENT_HANDLER) ||
+      Halted(EVENT_HANDLER)) {
+    return 0;
+  }
+
+  /* <0 means system event, -1. Just in case, this also covers
+   * Garbage and !GoodObject enactors. */
+  if (!GoodObject(enactor) || IsGarbage(enactor)) {
+    enactor = -1;
+  }
+
+  a = atr_get_noparent(EVENT_HANDLER, event);
+  if (!(a && AL_STR(a) && *AL_STR(a))) {
+    /* Nonexistant or empty attrib. */
+    return 0;
+  }
+
+  /* Because Event is so easy to run away. */
+  if (!pay_queue(EVENT_HANDLER, event)) {
+    return 0;
+  }
+
+  /* Fetch the next available pid. */
+  pid = next_pid();
+  if (pid == 0) {
+    /* Too many queue entries */
+    notify(Owner(EVENT_HANDLER), T("Queue entry table full. Try again later."));
+    return 0;
+  }
+
+  /* We have an event to call. Yay! */
+  for (i = 0; i < 10; i++)
+    wenv[i] = NULL;
+
+  /* Prep myfmt: Replace all commas with delim chars. */
+  snprintf(myfmt, BUFFER_LEN, "%s", fmt);
+  s = myfmt;
+
+  if (*s)
+    argcount++;                 /* At least one arg. */
+  while ((s = strchr(s, ',')) != NULL) {
+    *(s++) = DELIM_CHAR;
+    argcount++;
+  }
+
+  /* Maximum number of args available is 10: %0-%9 */
+  if (argcount > 10)
+    argcount = 10;
+
+  if (argcount > 0) {
+    /* Build the arguments. */
+    va_start(args, fmt);
+#ifdef HAS_VSNPRINTF
+    vsnprintf(buff, sizeof buff, myfmt, args);
+#else
+    /* Danger! Danger, Will Robinson! */
+    vsprintf(buff, myfmt, args);
+#endif
+    buff[(BUFFER_LEN * 4) - 1] = '\0';
+    va_end(args);
+
+    len = strlen(buff);
+    for (i = 0, s = buff; i < argcount && s; i++, s = snext) {
+      snext = strchr(s, DELIM_CHAR);
+      if ((snext ? (snext - s) : (len - (s - buff))) > BUFFER_LEN) {
+        /* It's theoretically possible to have an arg that's longer than
+         * BUFFER_LEN */
+        s[BUFFER_LEN - 1] = '\0';
+      }
+      if (snext) {
+        *(snext++) = '\0';
+      }
+      wenv[i] = s;
+    }
+
+  }
+
+  /* Let's queue this mother. */
+
+
+  /* Build tmp. */
+  tmp = mush_malloc(sizeof *tmp, "cqueue");
+  tmp->pid = pid;
+  tmp->semattr = NULL;
+  tmp->player = EVENT_HANDLER;
+  tmp->queued = QUEUE_PER_OWNER ? Owner(EVENT_HANDLER) : EVENT_HANDLER;
+  tmp->next = NULL;
+  tmp->left = 0;
+  tmp->cause = enactor;
+  tmp->caller = enactor;
+  tmp->pe_info = NULL;
+
+  aval = safe_atr_value(a);
+  tmp->comm = mush_strdup(aval, "cqueue.comm");
+  free(aval);
+
+  /* Set up %0-%9 */
+  for (i = 0; i < 10; i++) {
+    if (wenv[i]) {
+      tmp->env[i] = mush_strdup(wenv[i], "cqueue.env");
+    } else {
+      tmp->env[i] = NULL;
+    }
+  }
+
+  /* All Q-registers cleared */
+  for (i = 0; i < NUMQ; i++) {
+    tmp->rval[i] = NULL;
+  }
+
+  /* Hmm, should events queue ahead of anything else?
+   * For now, yes, but leaving code here anyway.
+   */
+  if (1) {
+    if (qlast) {
+      qlast->next = tmp;
+      qlast = tmp;
+    } else {
+      qlast = qfirst = tmp;
+    }
+  } else {
+    if (qllast) {
+      qllast->next = tmp;
+      qllast = tmp;
+    } else {
+      qllast = qlfirst = tmp;
+    }
+  }
+
+  /* All good! */
+  im_insert(queue_map, tmp->pid, tmp);
+  return 1;
+}
+
+/** Add a new queue entry: Either in place, or onto the player/object queues
  * This function adds a new entry to the back of the player or
  * object command queues (depending on whether the call was
  * caused by a player or an object).
@@ -295,27 +459,31 @@
  * \param pe_info the pe_info to use for evaluating the queue, or NULL
  */
 void
-parse_que(dbref player, const char *command, dbref cause, PE_Info *pe_info)
+insert_que(dbref player, const char *command, dbref cause, dbref caller, PE_Info *pe_info,
+           char **env, char **rval, int quetype)
 {
   int a;
   BQUE *tmp;
-  int pid;
+  int pid = 0;
   if (!IsPlayer(player) && (Halted(player))) {
     free_pe_info(pe_info);
     return;
   }
-  if (!pay_queue(player, command)) {
-    /* make sure player can afford to do it */
-    free_pe_info(pe_info);
-    return;
-  }
-  pid = next_pid();
-  if (pid == 0) {
-    /* Too many queue entries */
-    notify(player, T("Queue entry table full. Try again later."));
-    free_pe_info(pe_info);
-    return;
+  if (quetype != QUEUE_INPLACE && quetype != QUEUE_RECURSE) {
+    if (!pay_queue(player, command)) {
+      /* make sure player can afford to do it */
+      free_pe_info(pe_info);
+      return;
+    }
+    pid = next_pid();
+    if (pid == 0) {
+      /* Too many queue entries */
+      notify(player, T("Queue entry table full. Try again later."));
+      free_pe_info(pe_info);
+      return;
+    }
   }
+
   tmp = mush_malloc(sizeof *tmp, "cqueue");
   tmp->pid = pid;
   tmp->comm = mush_strdup(command, "cqueue.comm");
@@ -325,51 +493,98 @@
   tmp->next = NULL;
   tmp->left = 0;
   tmp->cause = cause;
+  tmp->caller = caller;
   tmp->pe_info = pe_info;
-  for (a = 0; a < 10; a++)
-    if (!global_eval_context.wnxt[a])
+  tmp->quetype = quetype;
+
+  /* Copy over env vars and rvals. */
+  for (a = 0; a < 10; a++) {
+    if (!env || !env[a]) {
       tmp->env[a] = NULL;
-    else {
-      tmp->env[a] = mush_strdup(global_eval_context.wnxt[a], "cqueue.env");
+    } else {
+      tmp->env[a] = mush_strdup(env[a], "cqueue.env");
     }
-  for (a = 0; a < NUMQ; a++)
-    if (!global_eval_context.rnxt[a] || !global_eval_context.rnxt[a][0])
+  }
+  for (a = 0; a < NUMQ; a++) {
+    if (!rval || !rval[a] || !rval[a][0]) {
       tmp->rval[a] = NULL;
-    else {
-      tmp->rval[a] = mush_strdup(global_eval_context.rnxt[a], "cqueue.rval");
+    } else {
+      tmp->rval[a] = mush_strdup(rval[a], "cqueue.rval");
     }
-  if (IsPlayer(cause)) {
+  }
+  switch (quetype) {
+  case QUEUE_PLAYER:
     if (qlast) {
       qlast->next = tmp;
       qlast = tmp;
-    } else
+    } else {
       qlast = qfirst = tmp;
-  } else {
+    }
+    break;
+  case QUEUE_OBJECT:
     if (qllast) {
       qllast->next = tmp;
       qllast = tmp;
-    } else
+    } else {
       qllast = qlfirst = tmp;
+    }
+    break;
+  case QUEUE_INPLACE:
+  case QUEUE_RECURSE:
+    tmp->next = global_eval_context.inplace_queue;
+    global_eval_context.inplace_queue = tmp;
+    break;
   }
-  im_insert(queue_map, tmp->pid, tmp);
+  if (pid)
+    im_insert(queue_map, tmp->pid, tmp);
+}
+
+/** Add a new entry onto the player or object command queues.
+ * This function adds a new entry to the back of the player or
+ * object command queues (depending on whether the call was
+ * caused by a player or an object).
+ * \param player the enactor for the queued command.
+ * \param command the command to enqueue.
+ * \param cause the player or object causing the command to be queued.
+ * \param pe_info the pe_info to use for evaluating the queue, or NULL
+ */
+void
+parse_que(dbref player, const char *command, dbref cause, PE_Info *pe_info)
+{
+  if (IsPlayer(cause)) {
+    insert_que(player, command, cause, cause, pe_info,
+               global_eval_context.wnxt, global_eval_context.rnxt,
+               QUEUE_PLAYER);
+  } else {
+    insert_que(player, command, cause, cause, pe_info,
+               global_eval_context.wnxt, global_eval_context.rnxt,
+               QUEUE_OBJECT);
+  }
+}
+
+void
+inplace_queue_actionlist(dbref executor, dbref cause, dbref caller,
+                         const char *command, char **args, int quetype)
+{
+  insert_que(executor, command, cause, caller, NULL,
+             (args != NULL) ? args : global_eval_context.wnxt,
+             global_eval_context.rnxt, quetype);
 }
 
 int
-inplace_queue_attribute(dbref thing, const char *atrname, dbref enactor,
-                        int rsargs)
+queue_include_attribute(dbref thing, const char *atrname,
+                        dbref executor, dbref cause, dbref caller, char **args)
 {
   ATTR *a;
   char *start, *command;
   int noparent = 0;
-  char *bp;
 
   a = queue_attribute_getatr(thing, atrname, noparent);
   if (!a)
     return 0;
-  if (!Can_Read_Attr(enactor, thing, a))
+  if (!Can_Read_Attr(executor, thing, a))
     return 0;
 
-  global_eval_context.include_called = 1 + rsargs;
   start = safe_atr_value(a);
   command = start;
   /* Trim off $-command or ^-command prefix */
@@ -384,9 +599,9 @@
       /* Skip the ':' */
       command++;
   }
-  bp = global_eval_context.include_replace;
-  safe_str(command, global_eval_context.include_replace, &bp);
-  *bp = '\0';
+
+  inplace_queue_actionlist(executor, cause, caller, command, args, QUEUE_INPLACE);
+
   free(start);
   return 1;
 }
@@ -484,6 +699,7 @@
   tmp->player = player;
   tmp->queued = QUEUE_PER_OWNER ? Owner(player) : player;
   tmp->cause = cause;
+  tmp->caller = cause;
   tmp->semattr = NULL;
   tmp->next = NULL;
   tmp->pe_info = NULL;
@@ -658,6 +874,7 @@
   entry->player = player;
   entry->queued = player;
   entry->cause = player;
+  entry->caller = player;
   entry->sem = NOTHING;
   entry->semattr = NULL;
   entry->next = NULL;
@@ -680,11 +897,20 @@
   int a;
   char tbuf[BUFFER_LEN];
   int break_count;
+  int switch_nest;
   int save_player;
   int local_break_called = 0;
+  int inplace_break_called = 0;
   char *r;
   char const *s;
+  BQUE *tmp;
+  BQUE *includes;
   int pt_flag = PT_SEMI;
+  char *preserves[10];
+  char *preserveq[NUMQ];
+
+  includes = global_eval_context.inplace_queue;
+  global_eval_context.inplace_queue = NULL;
 
   if (include_recurses == -1) {
     include_recurses = 0;
@@ -693,7 +919,7 @@
 
   if (GoodObject(entry->player) && !IsGarbage(entry->player)) {
     save_player = global_eval_context.cplr = entry->player;
-    if (!global_eval_context.include_called && pt_flag != PT_NOTHING) {
+    if (!include_recurses && pt_flag != PT_NOTHING) {
       giveto(global_eval_context.cplr, QUEUE_COST);
       add_to(entry->queued, -1);
     }
@@ -723,17 +949,18 @@
           global_eval_context.pe_info = make_pe_info();
         }
       }
-      while (!cpu_time_limit_hit && *s) {
+      switch_nest = global_eval_context.pe_info->switch_nesting;
+      while (!cpu_time_limit_hit && *s && !inplace_break_called) {
         r = global_eval_context.ccom;
         process_expression(global_eval_context.ccom, &r, &s,
-                           global_eval_context.cplr, entry->cause,
+                           global_eval_context.cplr, entry->caller,
                            entry->cause, PE_NOTHING, pt_flag,
                            global_eval_context.pe_info);
         *r = '\0';
         if (*s == ';')
           s++;
         strcpy(tbuf, global_eval_context.ccom);
-        process_command(global_eval_context.cplr, tbuf, entry->cause,
+        process_command(global_eval_context.cplr, tbuf, entry->cause, entry->caller,
                         (pt_flag == PT_NOTHING));
         if (global_eval_context.break_called) {
           /* Make sure we process semicolons in @break arg, even from socket */
@@ -749,61 +976,48 @@
             break;
           }
         }
-        if (global_eval_context.include_called) {
-          BQUE *tmp;
-          /* @include was called. Check for recursion limit */
-          if (include_recurses > 20) {
-            notify(global_eval_context.cplr, T("@include recursion exceeded."));
-            break;
+        if (include_recurses > 20) {
+          while (global_eval_context.inplace_queue) {
+            tmp = global_eval_context.inplace_queue;
+            global_eval_context.inplace_queue = tmp->next;
+            free_qentry(tmp);
           }
-          if (!*global_eval_context.include_replace)
-            break;
-          /* Clone qentry */
-          tmp = mush_malloc(sizeof *tmp, "cqueue");
-          tmp->pid = entry->pid;
-          tmp->semattr = NULL;
-          tmp->player = save_player;
-          tmp->queued = entry->queued;
-          tmp->next = NULL;
-          tmp->left = 0;
-          tmp->cause = entry->cause;
-          tmp->pe_info = NULL;
-          for (a = 0; a < 10; a++) {
-            if (global_eval_context.include_called == 1) {
-              tmp->env[a] =
-                entry->env[a] ? mush_strdup(entry->env[a], "cqueue.env") : NULL;
-            } else {
-              if (global_eval_context.include_wenv[a]) {
-                tmp->env[a] =
-                  mush_strdup(global_eval_context.include_wenv[a],
-                              "cqueue.env");
-              } else {
-                tmp->env[a] = NULL;
-              }
+        } else {
+          while (global_eval_context.inplace_queue && !inplace_break_called) {
+            /* Pop tmp off the stack. */
+            tmp = global_eval_context.inplace_queue;
+            global_eval_context.inplace_queue = tmp->next;
+            tmp->next = NULL;
+
+            /* RECURSE queue entries have their own Q-registers, and we
+             * need to re-set our current one. */
+            if (tmp->quetype == QUEUE_RECURSE) {
+              save_global_regs("recurse_queue_save", preserveq);
+              save_global_env("recurse_queue_save", preserves);
             }
-            if (global_eval_context.include_wenv[a]) {
-              mush_free(global_eval_context.include_wenv[a], "include_wenv");
-              global_eval_context.include_wenv[a] = NULL;
+
+            /* Run the queue entry. */
+            inplace_break_called = do_entry(tmp, include_recurses + 1);
+
+            if (tmp->quetype == QUEUE_RECURSE) {
+              /* Recursion causes breaks to be not propagate up. */
+              inplace_break_called = 0;
+              restore_global_regs("recurse_queue_save", preserveq);
+              restore_global_env("recurse_queue_save", preserves);
             }
-          }
-          for (a = 0; a < NUMQ; a++)
-            if (!global_eval_context.renv[a] || !*global_eval_context.renv[a])
-              tmp->rval[a] = NULL;
-            else {
-              tmp->rval[a] =
-                mush_strdup(global_eval_context.renv[a], "cqueue.rval");
+
+            /* Cleanup. */
+            for (a = 0; a < 10; a++) {
+              global_eval_context.wenv[a] = entry->env[a];
+            }
+            global_eval_context.cplr = save_player;
+            free_qentry(tmp);
+            if (global_eval_context.pe_info->switch_nesting > switch_nest) {
+              mush_free(global_eval_context.pe_info->switch_text[global_eval_context.pe_info->switch_nesting],
+                        "switch_arg");
+              global_eval_context.pe_info->switch_nesting--;
+              global_eval_context.pe_info->local_switch_nesting--;
             }
-          global_eval_context.include_called = 0;
-          /* Put the included actions in the clone */
-          tmp->comm =
-            mush_strdup(global_eval_context.include_replace, "cqueue.comm");
-          local_break_called = do_entry(tmp, include_recurses + 1);
-          for (a = 0; a < 10; a++)
-            global_eval_context.wenv[a] = entry->env[a];
-          free_qentry(tmp);
-          if (local_break_called) {
-            /* Propagate break */
-            break;
           }
         }
       }
@@ -816,7 +1030,13 @@
       }
     }
   }
-  return local_break_called;
+  while (global_eval_context.inplace_queue) {
+    tmp = global_eval_context.inplace_queue;
+    global_eval_context.inplace_queue = tmp->next;
+    free_qentry(global_eval_context.inplace_queue);
+  }
+  global_eval_context.inplace_queue = includes;
+  return local_break_called || inplace_break_called;
 }
 
 /** Determine whether it's time to run a queued command.
Index: game/restrictcnf.dst
===================================================================
--- game/restrictcnf.dst	(.../184p2)	(revision 828)
+++ game/restrictcnf.dst	(.../184p3)	(revision 828)
@@ -94,6 +94,7 @@
 
 # And some of the more dangerous side-effect functions.
 #restrict_function set nobody
+#restrict_function attrib_set nobody
 #restrict_function wipe nobody
 #restrict_function create nobody
 #restrict_function clone nobody
@@ -118,6 +119,19 @@
 #restrict_function cwho nobody
 #restrict_function channels nobody
 #restrict_function cflags nobody
+#restrict_function cbuffer nobody
+#restrict_function cbufferadd nobody
+#restrict_function cdesc nobody
+#restrict_function cemit nobody
+#restrict_function clflags nobody
+#restrict_function clock nobody
+#restrict_function cmsgs nobody
+#restrict_function cowner nobody
+#restrict_function crecall nobody
+#restrict_function cstatus nobody
+#restrict_function cusers nobody
+#restrict_function cmogrifier nobody
+
 
 # Remove the hardcode mail system by uncommenting these
 #restrict_command @mail nobody
@@ -132,3 +146,5 @@
 #restrict_function mailtime nobody
 #restrict_function malias nobody
 #restrict_function folderstats nobody
+#restrict_function maillist nobody
+#restrict_function mailsend nobody
Index: game/txt/hlp/pennchat.hlp
===================================================================
--- game/txt/hlp/pennchat.hlp	(.../184p2)	(revision 828)
+++ game/txt/hlp/pennchat.hlp	(.../184p3)	(revision 828)
@@ -106,12 +106,12 @@
 & CHAN_USEFIRSTMATCH
   Flag:  CHAN_USEFIRSTMATCH  (any type)
 
-  When this flag is set on an object that uses the chat system, channel name
-  matching will default to the first matching channel in cases of ambiguity.
-  Without this flag, attempting to use an ambiguous partial channel name
-  will produce an error.
+  Normally, when an object attempts to speak on the channel system with
+  @chat, using an ambiguous channel name produces an error message. With
+  this flag set, it will instead speak on the first channel whose name is
+  a match. Other commands in the chat system are not affected by the flag.
 
-See also: CHAT
+See also: CHAT, @chat, @cemit
 & @CEMIT
 & @NSCEMIT
 & CEMIT()
@@ -126,9 +126,12 @@
   /silent is given - if neither is given, the default behaviour is controlled
   by the noisy_cemit @config option. The /noeval switch prevents <message> 
   from being evaluated.
+  
+  You must be able to speak on the channel, or have the See_All and Pemit_All
+  @powers, to @cemit on the channel.
 
   @nscemit is exactly the same, but does not produce nospoof information when
-  used by players with the Can_nspemit @power.
+  used by players with the Can_spoof @power.
 
   cemit() and nscemit() work the same as @cemit/silent and @nscemit/silent,
   respectively. If <noisy> is given as a true value, they work like
@@ -142,9 +145,9 @@
   The @channel command is used to add, join, list and modify channels in the
   chat system. It takes many different switches.
 
-  Help for @channel system is split into a number of topics. Please see 'help 
-  @channel <topic>' for more, where <topic> is one of the words below. You
-  can also use 'help @channel/<switch>' for help on a particular switch.
+  Help for @channel is split into a number of topics. Please see 'help 
+  @channel <topic>' for more, where <topic> is one of the words below. For
+  help on a specific switch to @command, use 'help @channel/<switch>'.
 
   Joining    - How to find, join, and leave channels
   Other      - Setting channel titles, recalling previous chat messages
@@ -158,7 +161,7 @@
 & @channel/on
 & @channel/join
 & @channel/off
-& @channel/unjoin
+& @channel/leave
   @channel/list [<prefix>]
   @channel/what [<prefix>]
   @channel/who <channel>
@@ -178,7 +181,7 @@
 
   @channel/on and @channel/off add or remove you from the given <channel>.
   You only hear messages for channels you're on, and most channels require you
-  to join them before you can speak on them. /join and /unjoin are aliases for
+  to join them before you can speak on them. /join and /leave are aliases for
   /on and /off.
 
   Continued in 'help @channel joining2'.
@@ -226,6 +229,7 @@
   @channel/title lets you set a channel title, which is shown before your name
   whenever you speak on a channel. If =<message> is omitted, your current
   title on the channel is shown. Use an empty <message> to clear your title.
+  The maximum length of titles is set in the 'chan_title_len' @config option.
 
   @channel/recall shows you the most recent messages on the channel, if it has
   been given a recall buffer with @channel/buffer. With no extra arguments,
@@ -321,6 +325,7 @@
 
   See 'help mogrify2' for info on specific mogrifiers, and 'help mogrify3'
   for some examples.
+See also: cmogrifier()
 & mogrify2
 
   There are mogrify attributes for each individual piece of the channel
@@ -441,10 +446,9 @@
   @clock/hide <channel>[=<key>]
   @clock/mod <channel>[=<key>]
 
-  The @clock command modifies the a lock on a chat channel. If no <key> is
-  specified, the lock is removed. Evaluation locks will not work with @clock,
-  but you can use an indirect lock which uses evaluation locks. For an
-  explaination of the <key> argument, see 'help @lock'.
+  The @clock command modifies the @lock-style lock on a chat channel. If no 
+  <key> is specified, the lock is removed. See "help lockkeys" for an
+  explaination of <key>.
 
   The "join" lock restricts who can join the channel.
   The "speak" lock restricts who can speak on the channel.
@@ -453,18 +457,25 @@
   The "mod" lock restricts who can modify the channel. If you pass the
   mod lock on the channel, you can do anything short of deleting it.
 
-  When new channels are added, the mod lock is set to the
-  creator/owner, and all other locks are unlocked.
-
+  When new channels are added, the mod lock is set to the creator/owner
+  (=<creator>), and all other locks are unlocked.
+  
   Continued in 'help @clock2'.
 & @clock2
-  You can use indirect @clocks to lock a channel to a lock of any type
-  (including evaluation locks) on a VISUAL object. This channel can only
-  be joined by an UNFINDABLE player:
+  Locks are checked as if they were set on the object attemping to pass
+  them - for example, in the channel lock:
+    > @clock/join Public=test/1
+  the attribute "test" will be evaluated on the object trying to join the
+  Public channel.
+
+  You can use indirect @clocks to lock a channel to an @lock on an object.
+  Objects attempting to pass the lock must be able to see the indirect lock,
+  so it's recommended you set either the lock or the object VISUAL. This
+  channel can only be joined by objects which aren't set UNFINDABLE:
 
   > @clock/join unfindchannel=@#10
   > @lock/user:ChanJoinLock #10=!flag^unfindable
-  > @set #10=VISUAL
+  > @lset #10/ChanJoinLock=VISUAL   OR   @set #10=VISUAL
 
   @clock                  Corresponding default user: lock for object
   join                    ChanJoinLock
@@ -473,25 +484,29 @@
   hide                    ChanHideLock
   mod                     ChanModLock
 
-  You can lock multiple channels to the same object by specfiying a
-  specific indirect lock instead of the default one:
+  If you want to store different locks for different channels on the same
+  object, you can use a specific indirect lock instead of the default one:
 
   > @lock/user:onechanneljoin #10=flag^foo
   > @clock/join onechannel=@#10/onechanneljoin
   > @lock/user:anotherchanneljoin #10=flag^bar
   > @clock/join anotherchannel=@#10/anotherchanneljoin
 
-See also: clock()
+See also: clock(), @lock
 & COWNER()
   cowner(<channel>)
 
   Returns the dbref of the owner of a channel.
+  
+See also: @channel/chown
 & CTITLE()
   ctitle(<channel>, <object>)
 
   Returns <object>'s @channel/title on <channel>. You must either be able
   to examine the object, or it must be visibly on <channel>, and you must
   either be on <channel> on able to join it.
+  
+See also: @channel/title
 & CSTATUS()
   cstatus(<channel>, <object>)
 
@@ -500,7 +515,7 @@
   object, or it must visible be on the channel; "Off" is returned for
   objects that you cannot see on the channel.
   
-See also: cwho(), cflags()
+See also: cwho(), cflags(), @channel/on, @channel/gag
 & CDESC()
 & CUSERS()
 & CMSGS()
@@ -537,7 +552,7 @@
   If <skip gagged?> is given, and is true, gagged objects will not be
   included in the results.
 
-See also: cstatus()
+See also: cstatus(), @channel/who
 & CFLAGS()
 & CLFLAGS()
   cflags(<channel>)
@@ -550,8 +565,8 @@
   for the list. You must be able to see the channel to use this function.
 
   With two arguments, cflags() returns a list of flags for that object on 
-  that channel, currently a string consisting of zero or more of 
-  "G" (gagging), "Q" (muted), and "H" (hidden). You must be able to see that
+  that channel, currently a string consisting of zero or more of "G" (Gag),
+  "Q" (Quiet), "H" (Hide) and "C" (Combine). You must be able to see that
   channel and to examine the object to use this function. If the object is
   not on the channel, an error is returned.
 
@@ -575,6 +590,8 @@
   If you don't have permission to examine the object, you only see those
   channels to which the object belong for which you have permission to join
   (or are joined to).
+  
+See also: @channel/list
 & CLOCK()
   clock(<channel>[/<locktype>][, <new lock>])
 
@@ -592,11 +609,18 @@
   include their timestamps; otherwise, they will not.
 
 See also: @channel/recall, cbufferadd()
+& CMOGRIFIER()
+  cmogrifier(<channel>)
+
+  Returns the dbref of the mogrifier of a channel.
+  
+See also: @channel/mogrifier, @chatformat
 & Channel functions
   Channel functions work with the channel system.
 
   cbuffer()     cbufferadd()  cdesc()       cemit()       cflags()
-  channels()    clflags()     clock()       cmsgs()       cowner()
-  crecall()     cstatus()     ctitle()      cusers()      cwho()
+  channels()    clflags()     clock()       cmogrifier()  cmsgs()
+  cowner()      crecall()     cstatus()     ctitle()      cusers()
+  cwho()
 
 See also: CHAT, @channel, @cemit, @clock
Index: game/txt/hlp/pennconf.hlp
===================================================================
--- game/txt/hlp/pennconf.hlp	(.../184p2)	(revision 828)
+++ game/txt/hlp/pennconf.hlp	(.../184p3)	(revision 828)
@@ -40,6 +40,7 @@
   max_player_chans=<number>: How many channels can each non-admin
    player create? If 0, mortals cannot create channels.
   noisy_cemit=<boolean>: Is @cemit/noisy the default?
+  chan_title_len=<number>: How long can @channel/title's be?
 & @config cmds
  These options affect command behavior.
 
@@ -202,7 +203,7 @@
   queue_entry_cpu_time=<number>: The maximum number of milliseconds a
    queue entry can take to run.
   use_quota=<boolean>: Controls if quotas are used to limit the number
-	   of objects a player can own.
+   of objects a player can own.
 
 Continued in help @config limits4
 & @config limits4
Index: game/txt/hlp/index.hlp
===================================================================
--- game/txt/hlp/index.hlp	(.../184p2)	(revision 828)
+++ game/txt/hlp/index.hlp	(.../184p3)	(revision 828)
@@ -1,7 +1,8 @@
 
 & Entries
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- "                         #lambda                   $-commands               
+ "                         #lambda                   #lambda2                 
+ #lambda3                  #lambda4                  $-commands               
  $-commands2               %                         %!                       
  %#                        %$                        %$0                      
  %2                        %3                        %4                       
@@ -16,12 +17,12 @@
  1.6.0p4                   1.6.0p5                   1.6.1p0                  
  1.6.1p1                   1.6.10p0                  1.6.10p1                 
  1.6.10p2                  1.6.10p3                  1.6.10p4                 
- 1.6.10p5                  1.6.10p6                  1.6.2p0                  
 
 For more, see Entries-2
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-2
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+ 1.6.10p5                  1.6.10p6                  1.6.2p0                  
  1.6.2p1                   1.6.3p0                   1.6.3p1                  
  1.6.3p2                   1.6.3p3                   1.6.3p4                  
  1.6.3p5                   1.6.3p6                   1.6.3p7                  
@@ -37,12 +38,12 @@
  1.6.9p9                   1.7.0p0                   1.7.0p1                  
  1.7.0p2                   1.7.0p3                   1.7.0p4                  
  1.7.0p5                   1.7.0p6                   1.7.0p7                  
- 1.7.0p8                   1.7.0p9                   1.7.0p10                 
 
 For more, see Entries-3
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-3
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+ 1.7.0p8                   1.7.0p9                   1.7.0p10                 
  1.7.0p11                  1.7.1p0                   1.7.1p1                  
  1.7.1p2                   1.7.1p3                   1.7.2p0                  
  1.7.2p1                   1.7.2p2                   1.7.2p3                  
@@ -58,12 +59,12 @@
  1.7.2p31                  1.7.2p32                  1.7.2p33                 
  1.7.2p34                  1.7.2p35                  1.7.3p0                  
  1.7.3p1                   1.7.3p2                   1.7.3p3                  
- 1.7.3p4                   1.7.3p5                   1.7.3p6                  
 
 For more, see Entries-4
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-4
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+ 1.7.3p4                   1.7.3p5                   1.7.3p6                  
  1.7.3p7                   1.7.3p8                   1.7.3p9                  
  1.7.3p10                  1.7.3p11                  1.7.3p12                 
  1.7.3p13                  1.7.3p14                  1.7.4p0                  
@@ -79,12 +80,12 @@
  1.7.5p7                   1.7.5p8                   1.7.5p9                  
  1.7.5p10                  1.7.5p11                  1.7.5p12                 
  1.7.6p0                   1.7.6p1                   1.7.6p2                  
- 1.7.6p3                   1.7.6p4                   1.7.6p5                  
 
 For more, see Entries-5
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-5
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+ 1.7.6p3                   1.7.6p4                   1.7.6p5                  
  1.7.6p6                   1.7.6p7                   1.7.6p8                  
  1.7.6p9                   1.7.6p10                  1.7.6p11                 
  1.7.6p12                  1.7.6p13                  1.7.6p14                 
@@ -100,12 +101,12 @@
  1.7.7p25                  1.7.7p26                  1.7.7p27                 
  1.7.7p28                  1.7.7p29                  1.7.7p30                 
  1.7.7p31                  1.7.7p32                  1.7.7p33                 
- 1.7.7p34                  1.7.7p35                  1.7.7p36                 
 
 For more, see Entries-6
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-6
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+ 1.7.7p34                  1.7.7p35                  1.7.7p36                 
  1.7.7p37                  1.7.7p38                  1.7.7p39                 
  1.7.7p40                  1.8.0p0                   1.8.0p1                  
  1.8.0p2                   1.8.0p3                   1.8.0p4                  
@@ -121,96 +122,97 @@
  1.8.2p7                   1.8.2p8                   1.8.3p0                  
  1.8.3p1                   1.8.3p2                   1.8.3p3                  
  1.8.3p4                   1.8.3p5                   1.8.3p6                  
- 1.8.3p7                   1.8.3p8                   1.8.3p9                  
 
 For more, see Entries-7
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-7
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+ 1.8.3p7                   1.8.3p8                   1.8.3p9                  
  1.8.3p10                  1.8.3p11                  1.8.3p12                 
  1.8.3p13                  1.8.4p0                   1.8.4p1                  
- 1.8.4p2                   :                         ;                        
- @-attributes              @-building                @-general                
- @-wizard                  @@                        @@()                     
- @aahear                   @abuy                     @aclone                  
- @aconnect                 @adeath                   @adescribe               
- @adestroy                 @adisconnect              @adrop                   
- @aefail                   @aenter                   @afailure                
- @afollow                  @agive                    @ahear                   
- @aidescribe               @aleave                   @alfail                  
- @alias                    @allhalt                  @allquota                
- @amail                    @amhear                   @amove                   
- @aname                    @apayment                 @areceive                
- @assert                   @asuccess                 @atport                  
- @atrchown                 @atrlock                  @attribute               
+ 1.8.4p2                   1.8.4p3                   :                        
+ ;                         @-attributes              @-building               
+ @-general                 @-wizard                  @@                       
+ @@()                      @aahear                   @abuy                    
+ @aclone                   @aconnect                 @adeath                  
+ @adescribe                @adestroy                 @adisconnect             
+ @adrop                    @aefail                   @aenter                  
+ @afailure                 @afollow                  @agive                   
+ @ahear                    @aidescribe               @aleave                  
+ @alfail                   @alias                    @allhalt                 
+ @allquota                 @amail                    @amhear                  
+ @amove                    @aname                    @apayment                
+ @areceive                 @assert                   @asuccess                
 
 For more, see Entries-8
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-8
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- @attribute2               @attribute3               @aufail                  
- @aunfollow                @ause                     @away                    
- @azenter                  @azleave                  @boot                    
- @break                    @buy                      @cemit                   
- @channel                  @channel admin            @channel admin2          
- @channel admin3           @channel joining          @channel joining2        
- @channel list             @channel other            @channel privs           
- @channel/add              @channel/buffer           @channel/chown           
- @channel/combine          @channel/decompile        @channel/delete          
- @channel/describe         @channel/gag              @channel/hide            
- @channel/join             @channel/list             @channel/mogrifier       
- @channel/mute             @channel/name             @channel/off             
- @channel/on               @channel/privs            @channel/recall          
- @channel/rename           @channel/title            @channel/uncombine       
- @channel/ungag            @channel/unhide           @channel/unjoin          
- @channel/what             @channel/who              @channel/wipe            
+ @atport                   @atrchown                 @atrlock                 
+ @attribute                @attribute2               @attribute3              
+ @aufail                   @aunfollow                @ause                    
+ @away                     @azenter                  @azleave                 
+ @boot                     @break                    @buy                     
+ @cemit                    @channel                  @channel admin           
+ @channel admin2           @channel admin3           @channel joining         
+ @channel joining2         @channel list             @channel other           
+ @channel privs            @channel/add              @channel/buffer          
+ @channel/chown            @channel/combine          @channel/decompile       
+ @channel/delete           @channel/describe         @channel/gag             
+ @channel/hide             @channel/join             @channel/leave           
+ @channel/list             @channel/mogrifier        @channel/mute            
+ @channel/name             @channel/off              @channel/on              
+ @channel/privs            @channel/recall           @channel/rename          
+ @channel/title            @channel/uncombine        @channel/ungag           
 
 For more, see Entries-9
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-9
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- @charges                  @chat                     @chat mogrifying         
- @chatformat               @chatformat2              @chatformat3             
- @chown                    @chownall                 @chzone                  
- @chzone2                  @chzoneall                @clock                   
- @clock2                   @clone                    @command                 
- @command2                 @command3                 @comment                 
- @config                   @config attribs           @config chat             
- @config cmds              @config cosmetic          @config cosmetic2        
- @config costs             @config db                @config dump             
- @config flags             @config funcs             @config limits           
- @config limits2           @config limits3           @config limits4          
- @config log               @config net               @config parameters       
- @config tiny              @conformat                @cost                    
- @cpattr                   @create                   @dbck                    
- @death                    @debugforwardlist         @decompile               
- @decompile2               @decompile3               @desc                    
+ @channel/unhide           @channel/what             @channel/who             
+ @channel/wipe             @charges                  @chat                    
+ @chat mogrifying          @chatformat               @chatformat2             
+ @chatformat3              @chown                    @chownall                
+ @chzone                   @chzone2                  @chzoneall               
+ @clock                    @clock2                   @clone                   
+ @command                  @command2                 @command3                
+ @comment                  @config                   @config attribs          
+ @config chat              @config cmds              @config cosmetic         
+ @config cosmetic2         @config costs             @config db               
+ @config dump              @config flags             @config funcs            
+ @config limits            @config limits2           @config limits3          
+ @config limits4           @config log               @config net              
+ @config parameters        @config tiny              @conformat               
+ @cost                     @cpattr                   @create                  
+ @dbck                     @death                    @debugforwardlist        
 
 For more, see Entries-10
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-10
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- @descformat               @describe                 @destroy                 
- @destroy2                 @dig                      @dig2                    
- @disable                  @doing                    @dolist                  
- @drain                    @drop                     @dump                    
- @ealias                   @edit                     @efail                   
- @elock                    @emit                     @enable                  
- @enter                    @entrances                @eunlock                 
- @exitformat               @failure                  @filter                  
- @filter2                  @find                     @firstexit               
- @flag                     @flag2                    @follow                  
- @force                    @force2                   @forwardlist             
- @function                 @function2                @function3               
- @function4                @gedit                    @give                    
- @grep2                    @grep                     @halt                    
- @haven                    @hide                     @hook                    
- @hook2                    @idescformat              @idescribe               
+ @decompile                @decompile2               @decompile3              
+ @desc                     @descformat               @describe                
+ @destroy                  @destroy2                 @dig                     
+ @dig2                     @disable                  @doing                   
+ @dolist                   @drain                    @drop                    
+ @dump                     @ealias                   @edit                    
+ @efail                    @elock                    @emit                    
+ @enable                   @enter                    @entrances               
+ @eunlock                  @exitformat               @failure                 
+ @filter                   @filter2                  @find                    
+ @firstexit                @flag                     @flag2                   
+ @follow                   @force                    @force2                  
+ @force3                   @forwardlist              @function                
+ @function2                @function3                @function4               
+ @gedit                    @give                     @grep2                   
+ @grep                     @halt                     @haven                   
 
 For more, see Entries-11
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-11
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+ @hide                     @hook                     @hook2                   
+ @hook3                    @idescformat              @idescribe               
  @idle                     @include                  @infilter                
  @inprefix                 @invformat                @kick                    
  @lalias                   @leave                    @lemit                   
@@ -220,39 +222,40 @@
  @lock-carry               @lock-channel             @lock-complex            
  @lock-eval2               @lock-evaluation          @lock-evaluation2        
  @lock-flag                @lock-host                @lock-indirect           
- @lock-list                @lock-objid               @lock-owner              
- @lock-power               @lock-simple              @lock-type               
- @log                      @logwipe                  @lset                    
- @mail                     @mailfilter               @mailforwardlist         
- @mailsignature            @malias                   @malias2                 
- @malias3                  @malias4                  @malias5                 
- @message                  @message2                 @motd                    
+ @lock-list                @lock-name                @lock-objid              
+ @lock-owner               @lock-power               @lock-simple             
+ @lock-type                @log                      @logwipe                 
+ @lset                     @mail                     @mailfilter              
+ @mailforwardlist          @mailsignature            @malias                  
 
 For more, see Entries-12
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-12
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- @move                     @mvattr                   @name                    
- @nameaccent               @nameformat               @newpassword             
- @notify                   @nscemit                  @nsemit                  
- @nslemit                  @nsoemit                  @nspemit                 
- @nsprompt                 @nsremit                  @nszemit                 
- @nuke                     @obuy                     @odeath                  
- @odescribe                @odrop                    @oefail                  
- @oemit                    @oenter                   @ofailure                
+ @malias2                  @malias3                  @malias4                 
+ @malias5                  @mapsql                   @message                 
+ @message2                 @motd                     @move                    
+ @mvattr                   @name                     @nameaccent              
+ @nameformat               @newpassword              @notify                  
+ @nscemit                  @nsemit                   @nslemit                 
+ @nsoemit                  @nspemit                  @nsprompt                
+ @nsremit                  @nszemit                  @nuke                    
+ @obuy                     @odeath                   @odescribe               
+ @odrop                    @oefail                   @oemit                   
+ @oemit2                   @oenter                   @ofailure                
  @ofollow                  @ogive                    @oidescribe              
  @oleave                   @olfail                   @omove                   
  @oname                    @opayment                 @open                    
  @oreceive                 @osuccess                 @otport                  
  @oufail                   @ounfollow                @ouse                    
- @outpageformat            @outpageformat2           @oxenter                 
- @oxleave                  @oxmove                   @oxtport                 
- @ozenter                  @ozleave                  @pageformat              
 
 For more, see Entries-13
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-13
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+ @outpageformat            @outpageformat2           @oxenter                 
+ @oxleave                  @oxmove                   @oxtport                 
+ @ozenter                  @ozleave                  @pageformat              
  @pageformat2              @parent                   @password                
  @payment                  @pcreate                  @pemit                   
  @pemit2                   @poll                     @poor                    
@@ -263,212 +266,224 @@
  @rejectmotd               @remit                    @restart                 
  @runout                   @rwall                    @scan                    
  @search                   @search2                  @search3                 
- @search4                  @search5                  @set                     
- @sex                      @shutdown                 @sitelock                
- @sitelock2                @sitelock3                @speechmod               
- @sql                      @squota                   @startup                 
- @stats                    @success                  @sweep                   
- @switch                   @switch2                  @teleport                
+ @search4                  @search5                  @select                  
+ @set                      @sex                      @shutdown                
+ @sitelock                 @sitelock2                @sitelock3               
 
 For more, see Entries-14
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-14
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- @tport                    @trigger                  @trigger2                
- @tz                       @ufail                    @ulock                   
- @undestroy                @unfollow                 @unlink                  
- @unlock                   @unrecycle                @uptime                  
- @uptime2                  @use                      @uunlock                 
- @verb                     @verb2                    @verb3                   
- @verb4                    @version                  @vrml_url                
- @wait                     @wait2                    @wait3                   
- @wall                     @warnings                 @warnings2               
- @warnings3                @wcheck                   @whereis                 
- @wipe                     @wizmotd                  @wizwall                 
- @zemit                    @zenter                   @zleave                  
- \                         ]                         ^                        
- ^-listens                 `                         `2                       
- `3                        `4                        abode                    
- abs()                     accent()                  accent2                  
+ @speechmod                @sql                      @squota                  
+ @startup                  @stats                    @success                 
+ @sweep                    @switch                   @switch2                 
+ @switch3                  @teleport                 @tport                   
+ @trigger                  @trigger2                 @tz                      
+ @ufail                    @ulock                    @undestroy               
+ @unfollow                 @unlink                   @unlock                  
+ @unrecycle                @uptime                   @uptime2                 
+ @use                      @uunlock                  @verb                    
+ @verb2                    @verb3                    @verb4                   
+ @version                  @vrml_url                 @wait                    
+ @wait2                    @wait3                    @wall                    
+ @warnings                 @warnings2                @warnings3               
+ @wcheck                   @whereis                  @wipe                    
+ @wizmotd                  @wizwall                  @zemit                   
+ @zenter                   @zleave                   \                        
 
 For more, see Entries-15
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-15
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- accent3                   accent4                   accname()                
- acos()                    action lists              action2                  
- add()                     after()                   ahelp                    
- alias()                   align()                   align2                   
- align3                    align4                    allof()                  
- alphamax()                alphamin()                ancestors                
- and()                     andflags()                andlflags()              
- andlpowers()              anews                     angles                   
- anonymous attributes      anonymous2                anonymous3               
- anonymous4                ansi                      ansi()                   
- aposs()                   art()                     asin()                   
- atan()                    atan2()                   atrlock()                
- attr trees                attr trees2               attr trees3              
- attr trees4               attrcnt()                 attrib trees             
- attrib trees2             attrib trees3             attrib trees4            
- attrib-ownership          attrib_set()              attribute flags          
+ ]                         ^                         ^-listens                
+ `                         `2                        `3                       
+ `4                        abode                     abs()                    
+ accent()                  accent2                   accent3                  
+ accent4                   accname()                 acos()                   
+ action lists              action2                   add()                    
+ after()                   ahelp                     alias()                  
+ align()                   align2                    align3                   
+ align4                    allof()                   alphamax()               
+ alphamin()                ancestors                 and()                    
+ andflags()                andlflags()               andlpowers()             
+ anews                     angles                    anonymous attributes     
+ anonymous2                anonymous3                anonymous4               
+ ansi                      ansi()                    aposs()                  
+ art()                     asin()                    atan()                   
+ atan2()                   atrlock()                 attr trees               
 
 For more, see Entries-16
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-16
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- attribute flags2          attribute flags3          attribute functions      
- attribute list            attribute trees           attribute trees2         
- attribute trees3          attribute trees4          attributes               
- attributes list           attributes2               attributes3              
- attributes4               attrpcnt()                audible                  
- band()                    baseconv()                beep()                   
- before()                  being killed              benchmark()              
- bitwise functions         bnand()                   bnot()                   
- boolean functions         boolean values            boolean2                 
- boolean3                  bor()                     bound()                  
- brackets()                brief                     builder                  
- buy                       bxor()                    caller                   
- cand()                    capstr()                  case()                   
- caseall()                 cat()                     cbuffer()                
- cbufferadd()              cd                        cdesc()                  
- ceil()                    cemit()                   center()                 
+ attr trees2               attr trees3               attr trees4              
+ attrcnt()                 attrib trees              attrib trees2            
+ attrib trees3             attrib trees4             attrib-ownership         
+ attrib_set()              attribute flags           attribute flags2         
+ attribute flags3          attribute functions       attribute list           
+ attribute trees           attribute trees2          attribute trees3         
+ attribute trees4          attributes                attributes list          
+ attributes2               attributes3               attributes4              
+ attrpcnt()                audible                   band()                   
+ baseconv()                beep()                    before()                 
+ being killed              benchmark()               bitwise functions        
+ bnand()                   bnot()                    boolean functions        
+ boolean values            boolean2                  boolean3                 
+ bor()                     bound()                   brackets()               
+ brief                     builder                   buy                      
+ bxor()                    caller                    cand()                   
 
 For more, see Entries-17
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-17
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- cflags()                  ch                        chan_usefirstmatch       
- changes                   channel functions         channel-list             
- channel-privs             channels()                charges2                 
- chat                      chat mogrifying           chat system              
- checkpass()               children()                chown_ok                 
- chr()                     clflags()                 clients                  
- clock()                   clone()                   cloudy                   
- cmds()                    cmsgs()                   code                     
+ capstr()                  case()                    caseall()                
+ cat()                     cbuffer()                 cbufferadd()             
+ cd                        cdesc()                   ceil()                   
+ cemit()                   center()                  cflags()                 
+ ch                        chan_usefirstmatch        changes                  
+ channel functions         channel-list              channel-privs            
+ channels()                charges2                  chat                     
+ chat mogrifying           chat system               checkpass()              
+ children()                chown_ok                  chr()                    
+ clflags()                 clients                   clock()                  
+ clone()                   cloudy                    cmds()                   
+ cmogrifier()              cmsgs()                   code                     
  color                     commands                  communication functions  
  comp()                    comsys                    con()                    
  cond()                    condall()                 config()                 
  conn()                    connected                 connection functions     
- contact                   control                   controls()               
- convsecs()                convtime()                convutcsecs()            
- copyright                 copyrite                  cor()                    
- cos()                     costs                     cowner()                 
 
 For more, see Entries-18
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-18
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- create()                  crecall()                 credits                  
- csecs()                   cstatus()                 ctime()                  
- ctitle()                  ctu()                     cusers()                 
- cv                        cwho()                    dark                     
- database                  dbref #                   dbref functions          
- dbref number              dbref2                    dbrefs                   
- debug                     debug2                    debugforwardlist         
- dec()                     decode64()                decompose()              
- decrypt()                 default()                 delete()                 
- desert                    destroy_ok                die()                    
- dig()                     digest()                  dismiss                  
- dist2d()                  dist3d()                  div()                    
- doing                     doing()                   download                 
- drop                      drop-tos                  droptos                  
- dynhelp()                 e()                       edefault()               
- edit()                    element()                 elements()               
+ contact                   control                   controls()               
+ convsecs()                convtime()                convutcsecs()            
+ convutctime()             copyright                 copyrite                 
+ cor()                     cos()                     costs                    
+ cowner()                  create()                  crecall()                
+ credits                   csecs()                   cstatus()                
+ ctime()                   ctitle()                  ctu()                    
+ cusers()                  cv                        cwho()                   
+ dark                      database                  dbref #                  
+ dbref functions           dbref number              dbref2                   
+ dbrefs                    debug                     debug2                   
+ debugforwardlist          dec()                     decode64()               
+ decompose()               decrypt()                 default()                
+ delete()                  desert                    destroy_ok               
+ die()                     dig()                     digest()                 
+ dismiss                   dist2d()                  dist3d()                 
 
 For more, see Entries-19
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-19
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- elist()                   elock()                   emit()                   
- empty                     enactor                   encode64()               
- encrypt()                 endtag()                  enter                    
- enter_ok                  entrances()               eq()                     
- escape()                  etimefmt()                etimefmt2                
- etimefmt3                 eval()                    evaluation order         
- evaluation2               events                    examine                  
+ div()                     doing                     doing()                  
+ download                  drop                      drop-tos                 
+ droptos                   dynhelp()                 e()                      
+ edefault()                edit()                    element()                
+ elements()                elist()                   elock()                  
+ emit()                    empty                     enactor                  
+ encode64()                encrypt()                 endtag()                 
+ enter                     enter_ok                  entrances()              
+ eq()                      escape()                  etimefmt()               
+ etimefmt2                 etimefmt3                 eval()                   
+ evaluation order          evaluation2               event                    
+ event db                  event dump                event examples           
+ event examples2           event list                event object             
+ event player              event signal              event socket             
+ event sql                 events                    examine                  
  executor                  exit()                    exits                    
- exp()                     extract()                 failure                  
- fdiv()                    filter()                  filterbool()             
- findable()                first()                   firstof()                
- fixed                     flag list                 flag permissions         
- flags                     flags list                flags()                  
- flags2                    flip()                    floating                 
- floor()                   floordiv()                fmod()                   
- fn()                      fold()                    fold2                    
 
 For more, see Entries-20
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-20
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- folderstats()             follow                    followers()              
- following()               foreach()                 foreach2                 
- forwardlist               fraction()                fullalias()              
- fullname()                function list             functions                
- functions()               functions2                gagged                   
- gender                    get                       get()                    
- get_eval()                getpids()                 give                     
- global commands           globals                   go                       
- going                     going_twice               goto                     
- grab()                    graball()                 grep()                   
- grepi()                   gt()                      gte()                    
- halt                      hasattr()                 hasattrp()               
- hasattrpval()             hasattrval()              hasflag()                
- haspower()                hastype()                 haven                    
- hear_connect              heavy                     height()                 
- here                      hidden()                  home                     
+ exp()                     extract()                 failure                  
+ failure2                  fdiv()                    filter()                 
+ filterbool()              findable()                first()                  
+ firstof()                 fixed                     flag list                
+ flag permissions          flags                     flags list               
+ flags()                   flags2                    flip()                   
+ floating                  floor()                   floordiv()               
+ fmod()                    fn()                      fold()                   
+ fold2                     folderstats()             follow                   
+ followers()               following()               foreach()                
+ foreach2                  forwardlist               fraction()               
+ fullalias()               fullname()                function list            
+ functions                 functions()               functions2               
+ gagged                    gender                    get                      
+ get()                     get_eval()                getpids()                
+ give                      global commands           globals                  
 
 For more, see Entries-21
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-21
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- home()                    homes                     host()                   
- hostname()                html                      html functions           
- html()                    huh_command               i18n                     
- ibreak()                  idle                      idle()                   
- idlesecs()                if()                      ifelse()                 
- ilev()                    iname()                   inc()                    
- index                     index()                   info                     
- information functions     inherit                   insert()                 
- interiors                 interiors2                internationalization     
- inum()                    inventory                 ipaddr()                 
- isdaylight()              isdbref()                 isint()                  
- isnum()                   isobjid()                 isword()                 
- itemize()                 items()                   iter()                   
- iter2                     itext()                   itext2                   
- judge                     jump_ok                   jury_ok                  
- keepalive                 kill                      lalign()                 
+ go                        going                     going_twice              
+ goto                      grab()                    graball()                
+ grep()                    grepi()                   gt()                     
+ gte()                     halt                      hasattr()                
+ hasattrp()                hasattrpval()             hasattrval()             
+ hasflag()                 haspower()                hastype()                
+ haven                     hear_connect              heavy                    
+ height()                  help                      here                     
+ hidden()                  home                      home()                   
+ homes                     host()                    hostname()               
+ html                      html functions            html()                   
+ huh_command               i18n                      ibreak()                 
+ idle                      idle()                    idlesecs()               
+ if()                      ifelse()                  ilev()                   
+ iname()                   inc()                     index                    
+ index()                   info                      information functions    
 
 For more, see Entries-22
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-22
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- lambda                    last                      last & lastlogout        
- last()                    lastip                    lastlogout               
- lastsite                  lattr()                   lattrp()                 
- lcon()                    lcstr()                   ldelete()                
- leave                     left()                    lemit()                  
- letq()                    lexits()                  lflags()                 
- license                   light                     link()                   
- link_ok                   linking                   list functions           
- list()                    listen_parent             listening                
- listening2                listening3                lists                    
- lit()                     ljust()                   llockflags()             
- llocks()                  lmath()                   ln()                     
- lnum()                    loc()                     locale                   
- localize()                locate()                  locate2                  
- locate3                   lock keys                 lock list                
- lock types                lock types2               lock()                   
+ inherit                   insert()                  interiors                
+ interiors2                internationalization      inum()                   
+ inventory                 ipaddr()                  isdaylight()             
+ isdbref()                 isint()                   isnum()                  
+ isobjid()                 isword()                  itemize()                
+ items()                   iter()                    iter2                    
+ itext()                   itext2                    judge                    
+ jump_ok                   jury_ok                   keepalive                
+ kill                      lalign()                  lambda                   
+ lambda2                   lambda3                   lambda4                  
+ last                      last & lastlogout         last()                   
+ lastip                    lastlogout                lastsite                 
+ lattr()                   lattrp()                  lcon()                   
+ lcstr()                   ldelete()                 leave                    
+ left()                    lemit()                   letq()                   
+ lexits()                  lflags()                  license                  
 
 For more, see Entries-23
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-23
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+ light                     link()                    link_ok                  
+ linking                   list functions            list()                   
+ listen_parent             listening                 listening2               
+ listening3                lists                     lit()                    
+ ljust()                   llockflags()              llocks()                 
+ lmath()                   ln()                      lnum()                   
+ loc()                     locale                    localize()               
+ locate()                  locate2                   locate3                  
+ lock keys                 lock list                 lock types               
+ lock types2               lock()                    lockfilter()             
  lockflags()               locking                   lockkeys                 
  locklist                  lockowner()               locks                    
  locks()                   locktypes                 locktypes2               
  log()                     logout                    look                     
  look2                     looping                   loud                     
  lparent()                 lpids()                   lplayers()               
+
+For more, see Entries-24
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+& Entries-24
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  lports()                  lpos()                    lsearch()                
  lsearch2                  lsearch3                  lsearchr()               
  lset()                    lstats()                  lt()                     
@@ -479,17 +494,17 @@
  mail()                    mail-admin                mail-folders             
  mail-forward              mail-other                mail-reading             
  mail-sending              maildstats()              mailfilter               
-
-For more, see Entries-24
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-& Entries-24
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  mailfrom()                mailfstats()              maillist()               
  mailsend()                mailsignature             mailstats()              
  mailstatus()              mailsubject()             mailtime()               
  malias()                  map()                     mapsql()                 
  master room               match()                   matchall()               
  matching                  math functions            max()                    
+
+For more, see Entries-25
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+& Entries-25
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  me                        mean()                    median()                 
  member()                  merge()                   message()                
  mid()                     min()                     mistrust                 
@@ -500,17 +515,17 @@
  monitor                   move                      msecs()                  
  mssp-request              mtime()                   mudname()                
  mudurl()                  mul()                     munge()                  
-
-For more, see Entries-25
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-& Entries-25
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  munge2                    munge3                    mushcode                 
  mushcode2                 mwho()                    mwhoid()                 
  myopic                    name()                    namegrab()               
  namegraball()             namelist()                nand()                   
  nattr()                   nattrp()                  ncand()                  
  nchildren()               ncon()                    ncond()                  
+
+For more, see Entries-26
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+& Entries-26
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  ncondall()                ncor()                    nearby()                 
  neq()                     newbie                    newbie2                  
  newbie3                   news                      nexits()                 
@@ -521,164 +536,164 @@
  noname                    nor()                     nospace                  
  nospoof                   not()                     nowarn                   
  nplayers()                nscemit()                 nsearch()                
-
-For more, see Entries-26
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-& Entries-26
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  nsemit()                  nslemit()                 nsoemit()                
  nspemit()                 nsprompt()                nsremit()                
  nszemit()                 nthings()                 null()                   
  num()                     numversion()              nvcon()                  
  nvexits()                 nvplayers()               nvthings()               
- nwho()                    obj()                     object parents           
- objects                   objeval()                 objid()                  
- objmem()                  oemit()                   on-vacation              
- opaque                    open()                    open_ok                  
- or()                      ord()                     ordinal()                
- orflags()                 orlflags()                orlpowers()              
- orphan                    outputprefix              outputsuffix             
- owner()                   page                      page2                    
- paranoid                  parent                    parent()                 
- parents                   parents2                  parents3                 
- parents4                  parents5                  parse()                  
+ nwho()                    obj()                     object ids               
 
 For more, see Entries-27
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-27
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- patchlevels               pcreate()                 pemit()                  
- pfun()                    pfun2                     pfun3                    
- pi()                      pickrand()                pidinfo()                
- player()                  playermem()               players                  
- pmatch()                  poll()                    ports()                  
- pos()                     pose                      pose2                    
- poss()                    power()                   powers list              
- powers list2              powers()                  powers2                  
- prompt()                  prompt_newlines           pueblo                   
- pueblo features           pueblo()                  puppet                   
- puppets                   puppets2                  queue                    
- quiet                     quit                      quota()                  
- r()                       r-function                rand()                   
- randword()                read                      recv()                   
- regedit()                 regeditall()              regeditalli()            
- regediti()                regexp                    regexp classes           
+ object parents            objects                   objeval()                
+ objid()                   objids                    objmem()                 
+ oemit()                   on-vacation               opaque                   
+ open()                    open_ok                   or()                     
+ ord()                     ordinal()                 orflags()                
+ orlflags()                orlpowers()               orphan                   
+ outputprefix              outputsuffix              owner()                  
+ page                      page2                     paranoid                 
+ parent                    parent()                  parents                  
+ parents2                  parents3                  parents4                 
+ parents5                  parse()                   patchlevels              
+ pcreate()                 pemit()                   pfun()                   
+ pfun2                     pfun3                     pi()                     
+ pickrand()                pidinfo()                 player()                 
+ playermem()               players                   pmatch()                 
+ poll()                    ports()                   pos()                    
 
 For more, see Entries-28
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-28
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- regexp classes2           regexp examples           regexp syntax            
- regexp syntax2            regexp syntax3            regexp syntax4           
- regexp syntax5            regexp syntax6            regexp syntax7           
- regexp syntax8            regexps                   regexps2                 
- registers                 registers2                reglattr()               
- reglattrp()               regmatch()                regmatchi()              
- regnattr()                regnattrp()               regrab()                 
- regraball()               regraballi()              regrabi()                
- regrep()                  regrepi()                                          
- regular expression functions                        regxattr()               
- regxattrp()               remainder()               remit()                  
- remove()                  repeat()                  replace()                
- rest()                    restarts()                restarttime()            
- restrict                  restrict2                 restrict3                
- reswitch()                reswitchall()             reswitchalli()           
- reswitchi()               reverse()                 revwords()               
+ pose                      pose2                     poss()                   
+ power()                   powers list               powers list2             
+ powers()                  powers2                   prompt()                 
+ prompt_newlines           pueblo                    pueblo features          
+ pueblo()                  puppet                    puppets                  
+ puppets2                  queue                     quiet                    
+ quit                      quota()                   r()                      
+ r-function                rand()                    randword()               
+ read                      recv()                    regedit()                
+ regeditall()              regeditalli()             regediti()               
+ regexp                    regexp classes            regexp classes2          
+ regexp examples           regexp syntax             regexp syntax2           
+ regexp syntax3            regexp syntax4            regexp syntax5           
+ regexp syntax6            regexp syntax7            regexp syntax8           
+ regexps                   regexps2                  registers                
+ registers2                reglattr()                reglattrp()              
 
 For more, see Entries-29
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-29
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- right()                   rjust()                   rloc()                   
- rnum()                    room()                    rooms                    
- root()                    round()                   royalty                  
- rquota                    rules                     runout2                  
- s()                       s-function                safe                     
- say                       scan()                    score                    
- scramble()                screenheight              screenwidth              
- search()                  search2                   search3                  
- secs()                    secure()                  semaphores               
- semaphores2               semaphores3               semaphores4              
- semaphores5               semaphores6               semipose                 
- sent()                    session                   set()                    
- setdiff()                 setinter()                setq()                   
- setq2                     setq3                     setr()                   
- setting-attributes        setunion()                sex                      
- sha0()                    shared                    shared players           
+ regmatch()                regmatchi()               regnattr()               
+ regnattrp()               regrab()                  regraball()              
+ regraballi()              regrabi()                 regrep()                 
+ regrepi()                 regular expression functions                       
+ regxattr()                regxattrp()               remainder()              
+ remit()                   remove()                  repeat()                 
+ replace()                 rest()                    restarts()               
+ restarttime()             restrict                  restrict2                
+ restrict3                 reswitch()                reswitchall()            
+ reswitchalli()            reswitchi()               reverse()                
+ revwords()                right()                   rjust()                  
+ rloc()                    rnum()                    room()                   
+ rooms                     root()                    round()                  
+ royalty                   rquota                    rules                    
+ runout2                   s()                       s-function               
+ safe                      say                       scan()                   
 
 For more, see Entries-30
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-30
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- shared players2           shl()                     shr()                    
- shuffle()                 sign()                    sin()                    
- slay                      slev()                    socket commands          
- softcode                  sort()                    sortby()                 
- sorting                   sortkey()                 soundex()                
- soundex2                  soundlike()               soundslike()             
- space()                   speak()                   speak2                   
- speak3                    speak4                    speak5                   
- speak6                    speak7                    speakpenn()              
- spellnum()                splice()                  spoofing                 
- sql examples              sql functions             sql()                    
- sqlescape()               sqrt()                    squish()                 
- ssl()                     stack                     starttime()              
- stats()                   stddev()                  step()                   
- stext()                   sticky                    strallof()               
- strcat()                  strfirstof()              string functions         
+ score                     scramble()                screenheight             
+ screenwidth               search()                  search2                  
+ search3                   secs()                    secure()                 
+ semaphores                semaphores2               semaphores3              
+ semaphores4               semaphores5               semaphores6              
+ semipose                  sent()                    session                  
+ set()                     setdiff()                 setinter()               
+ setq()                    setq2                     setq3                    
+ setr()                    setting-attributes        setunion()               
+ sex                       sha0()                    shared                   
+ shared players            shared players2           shl()                    
+ shr()                     shuffle()                 sign()                   
+ sin()                     slay                      slev()                   
+ socket commands           softcode                  sort()                   
+ sortby()                  sorting                   sortkey()                
+ soundex()                 soundex2                  soundlike()              
 
 For more, see Entries-31
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-31
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- strings                   stringsecs()              strinsert()              
- stripaccents()            stripansi()               strlen()                 
- strmatch()                strreplace()              sub()                    
- subj()                    substitutions             substitutions2           
- substitutions3            substitutions4            success                  
- suspect                   switch wildcards          switch()                 
- switch2                   switchall()               switches                 
- t()                       table()                   tag()                    
- tagwrap()                 take                      tan()                    
- teach                     tel()                     tel_ok                   
- terminfo()                terse                     testlock()               
- textentries()             textfile()                things                   
- think                     time functions            time()                   
- timefmt()                 timefmt2                  timestring()             
- topics                    topics2                   tr()                     
- track_money               translation               transparent              
+ soundslike()              space()                   speak()                  
+ speak2                    speak3                    speak4                   
+ speak5                    speak6                    speak7                   
+ speakpenn()               spellnum()                splice()                 
+ spoofing                  sql examples              sql functions            
+ sql()                     sqlescape()               sqrt()                   
+ squish()                  ssl()                     stack                    
+ starttime()               stats()                   stddev()                 
+ step()                    stext()                   sticky                   
+ strallof()                strcat()                  strfirstof()             
+ string functions          strings                   stringsecs()             
+ strinsert()               stripaccents()            stripansi()              
+ strlen()                  strmatch()                strreplace()             
+ sub()                     subj()                    substitutions            
+ substitutions2            substitutions3            substitutions4           
+ success                   suspect                   switch wildcards         
 
 For more, see Entries-32
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-32
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- trim()                    trimpenn()                trimtiny()               
- trunc()                   trust                     type()                   
- types                     types of objects          u()                      
- u2                        u3                        ucstr()                  
- udefault()                ufun()                    ufun2                    
- ufun3                     ulambda()                 uldefault()              
- ulocal()                  ulocal2                   unfindable               
- unfollow                  uninspected               unique()                 
- unregistered              unsetq()                  use                      
- user-defined commands     user-defined2             utctime()                
- utility functions         v()                       v-function               
- vadd()                    val()                     valid()                  
- vcross()                  vdim()                    vdot()                   
- vector functions          verbose                   verbs                    
- verbs2                    version()                 visible()                
- visual                    vmag()                    vmax()                   
+ switch()                  switch2                   switchall()              
+ switches                  t()                       table()                  
+ tag()                     tagwrap()                 take                     
+ tan()                     teach                     tel()                    
+ tel_ok                    terminfo()                terse                    
+ testlock()                textentries()             textfile()               
+ things                    think                     time functions           
+ time()                    timefmt()                 timefmt2                 
+ timestring()              topics                    topics2                  
+ tr()                      track_money               translation              
+ transparent               trim()                    trimpenn()               
+ trimtiny()                trunc()                   trust                    
+ type()                    types                     types of objects         
+ u()                       u2                        u3                       
+ ucstr()                   udefault()                ufun()                   
+ ufun2                     ufun3                     ulambda()                
 
 For more, see Entries-33
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 & Entries-33
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
- vmin()                    vmul()                    vrml                     
- vsub()                    vunit()                   warnings                 
- warnings list             warnings list2            where()                  
- whisper                   whisper2                  who                      
+ uldefault()               ulocal()                  ulocal2                  
+ unfindable                unfollow                  uninspected              
+ unique()                  unregistered              unsetq()                 
+ use                       user-defined commands     user-defined2            
+ utctime()                 utility functions         v()                      
+ v-function                vadd()                    val()                    
+ valid()                   vcross()                  vdim()                   
+ vdot()                    vector functions          verbose                  
+ verbs                     verbs2                    version()                
+ visible()                 visual                    vmag()                   
+ vmax()                    vmin()                    vmul()                   
+ vrml                      vsub()                    vunit()                  
+ warnings                  warnings list             warnings list2           
+ where()                   whisper                   who                      
  who2                      width()                   wildcards                
  wildgrep()                wildgrepi()               wipe()                   
+
+For more, see Entries-34
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+& Entries-34
+-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  with                      wizard                    wordpos()                
  words()                   wrap()                    xattr()                  
  xattrp()                  xcon()                    xexits()                 
@@ -689,11 +704,6 @@
  z_tel                     zemit()                   zfun()                   
  zmo                       zmp                       zmr                      
  zmt                       zmwho()                   zone                     
-
-For more, see Entries-34
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-& Entries-34
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  zone master objects       zone master rooms         zone masters             
  zone objects              zone()                    zones                    
  zones2                    zwho()                                             
Index: game/txt/hlp/pennfunc.hlp
===================================================================
--- game/txt/hlp/pennfunc.hlp	(.../184p2)	(revision 828)
+++ game/txt/hlp/pennfunc.hlp	(.../184p3)	(revision 828)
@@ -220,9 +220,10 @@
 & Time functions
   These functions return times or format times.
 
-  convsecs()    convutcsecs() convtime()    ctime()       etimefmt()
-  isdaylight()  mtime()       restarttime() secs()        starttime()
-  stringsecs()  time()        timefmt()     timestring()  utctime()
+  convsecs()    convutcsecs() convtime()    convutctime() ctime()
+  etimefmt()    isdaylight()  mtime()       restarttime() secs()
+  starttime()   stringsecs()  time()        timefmt()     timestring()
+  utctime()
 
 & Utility functions
   These functions don't quite fit into any other category.
@@ -401,12 +402,13 @@
     < Left-justify       - Center-justify        > Right-justify
     _ Full-justify.      = Paragraph-justify.
  
-  Runout: Placing one of these characters after the width alters what
-  happens when the column runs out of text before the other columns.
-  (e.g: 30`)
-    . Repeat
-    ` Merge with the column on the left.
-    ' Merge with the column on the right.
+  Other options: Adding these after the width will alter the column's
+    behaviour in some situtations
+    . Repeat for as long as there is non-repeating text in another column.
+    ` Merge with the column on the left when it runs out of text.
+    ' Merge with the column on the right when it runs out of text.
+    $ nofill: Don't use filler after the text. If this is combined with
+      merge-left, the column to its left inherits the 'nofill' when merged.
 
   Ansi: Place ansi characters (as defined in 'help ansi()') within ()s to
   define a column's ansi markup.
@@ -433,9 +435,8 @@
          +                  Luke                  +
          +----------------------------------------+
 
-  See 'help align4' for another example.
+  See 'help align4' for more examples.
 & ALIGN4
-
   > &dropcap me=%b_______%r|__%b%b%b__|%r%b%b%b|%b|%r%b%b%b|_|
   > &story me=%r'was the night before Christmas, when all through the house%r
               Not a creature was stirring, not even a mouse.%r
@@ -451,7 +452,11 @@
   
   The dropcap 'T' will be in ANSI cyan-highlight, and merges with the 'story'
   column.
-  
+
+  > th align(>15 60,Walker,Staff & Developer,x,x)
+  xxxxxxxxxWalkerxStaff & Developerxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
+  > th align(>15 60$,Walker,Staff & Developer,x,x)
+  xxxxxxxxxWalkerxStaff & Developer
 & ALLOF()
   allof(<expr>[, ... , <exprN>], <osep>)
 
@@ -603,14 +608,16 @@
 
 See also: acos(), asin(), cos(), ctu(), sin(), tan()
 & ATRLOCK()
-  atrlock(<object>/<attrib>[, <on|off>])
+  atrlock(<object>/<attrib>[, [on|off]])
 
   When given a single <object>/<attribute> pair as an argument, returns 1
   if the attribute is locked, 0 if unlocked, and #-1 if the attribute
   doesn't exist or can't be read by the function's caller.
 
   When given a second argument of "on" (or "off"), attempts to lock
-  (unlock) the specified attribute, as per @atrlock.
+  (or unlock) the specified attribute, as per @atrlock.
+  
+See also: @atrlock, @atrchown, hasflag()
 & ATTRIB_SET()
   attrib_set(<object>/<attrib>[, <value>])
 
@@ -627,7 +634,7 @@
   space. This means that attrib_set(me/foo,%0) will _always_
   create an attribute.
 
-See also: set()
+See also: set(), @set
 & BAND()
   band(<integer>, <integer>[, ... , <integerN>])
 
@@ -977,7 +984,9 @@
 
 See also: convtime(), time()
 & CONVTIME()
-  convtime(<time string>)
+& CONVUTCTIME()
+  convtime(<time string>,[utc])
+  convutctime(<time string>)
 
   This functions converts a time string (in the server's time zone) to
   the number of seconds since Jan 1, 1970 GMT. A time string is of the
@@ -987,6 +996,9 @@
   year.  If you supply an incorrectly formatted string, it will return
   -1.
 
+  convutctime() and convtime() with a second argument of 'utc' assume
+  the timestring is based on UTC time.
+
   If the extended convtime() is supported (See @config compile), more
   formats for the date are enabled, including ones missing the day of
   week and year, and a 'Month Day Year' format.
@@ -1181,11 +1193,14 @@
     > think die(3, 6, 1)
     5 2 1  
 & DIG()
-  dig(<name>[, <exit to>[, <exit from>]])
+  dig(<name>[, <exit to>[, <exit from>[, <dbref>]]])
  
   This function digs a room called <name>, and optionally opens and
   links <exit to> and <exit from>, like the normal @dig command. It
   returns the dbref number of the new room.
+  
+  Wizards can supply an optional fourth argument to specify a garbage
+  object to use for the new room.
 
   This is a side-effect function and may not be enabled on some MUSHes.
 & DIGEST()
@@ -1238,9 +1253,9 @@
 & DOING()
   doing(<player|descriptor>)
 
-	When given the name of a connected player or descriptor, doing()
-	returns the player's @doing. If <player> is offline, (or dark, and the
-	caller is mortal), doing() returns #-1.
+  When given the name of a connected player or descriptor, doing()
+  returns the player's @doing. If <player> is offline, (or dark, and the
+  caller is mortal), doing() returns #-1.
 
 See also: @poll, @doing, poll()
 & E()
@@ -1333,7 +1348,7 @@
     > think elock(map/test,*Snape)
     0
 
-See also: @lock, locktypes, testlock()
+See also: @lock, locktypes, testlock(), lockfilter()
 & EMIT()
 & NSEMIT()
   emit(<message>)
@@ -1486,7 +1501,7 @@
     > say filter(test/is_odd, 1 2 3 4 5 6)
     You say, "1 3 5"
 
-See also: anonymous attributes, firstof(), allof()
+See also: anonymous attributes, firstof(), allof(), lockfilter()
 & FINDABLE()
   findable(<object>, <victim>)
  
@@ -2005,7 +2020,7 @@
   
   If a <delim> is not given, a space is assumed. Null items are counted
   when determining position, as in 'items()'.
-	  
+
   Examples:
     > say insert(This is a string,4,test)
     You say, "This is a test string"
@@ -2105,10 +2120,10 @@
   
   Prior to each evaluation, every occurrence of the string "##" in <pattern>
   is replaced with the current word from <list>. However, because this 
-  replacement occurs before substitution, it cannot be used well in nested
+  replacement occurs before evaluation, it cannot be used well in nested
   iter()s, and should not be used on user input or untrusted <list>s, as the
   word will be evaluated. Instead, you can use the %iX substitution, or the 
-  itext() function. The substitution '%il' refers to the outermost iter
+  itext() function. The substitution '%iL' refers to the outermost iter
   of the current expression, and is intended to replace ##.
   
   The string "#@" will be replaced with the position of the current word
@@ -2202,7 +2217,7 @@
     
     > @dolist red blue green=say iter(fish shoe, %i1:%i0)
     You say, "red:fish red:shoe"
-		You say, "blue:fish blue:shoe"
+    You say, "blue:fish blue:shoe"
     You say, "green:fish green:shoe"
     
 See also: iter(), @dolist
@@ -2531,19 +2546,20 @@
 & LOCATE()
   locate(<looker>, <name>, <parameters>)
  
-  This function attemps to find an object called <name>, relative to
-  the object <looker>. It's similar to the num() function, but you can
-  be more specific about which type of object to find, and where to look
-  for it. You must control <looker> or have the See_All power to use this
-  function.
+  This function attemps to find an object called <name>, relative to the
+  object <looker>. It's similar to the num() function, but you can be more
+  specific about which type of object to find, and where to look for it. 
+  When attempting to match objects near to <looker> (anything but absolute,
+  player name or "me" matches), you must control <looker>, have the See_All
+  power or be nearby.
   
   <parameters> is a string of characters which control the type of the object
   to find, and where (relative to <looker>) to look for it.
   
-  You can control the preferred type of the match with:
-    E - Exits
-    L - Unlocked exits preferred over locked exits
+  You can control the preferred types of the match with:
     N - No type (this is the default)
+    E - Exits
+    L - Prefer an object whose Basic @lock <looker> passes
     P - Players
     R - Rooms
     T - Things
@@ -2569,12 +2585,12 @@
     m - If <name> is "me", return <looker>'s dbref
     n - Match <name> against the names of objects in <looker>'s location
     p - If <name> begins with a *, match the rest against player names
-    x - Only match objects with the exact name <name>, no partial matches
     y - Match <name> against player names whether it begins with a * or not
     z - English-style matching (my 2nd book) of <name> (see 'help matching')
     * - All of the above (try a complete match). Default when no match
         parameters are given.
- 
+    x - Only match objects with the exact name <name>, no partial matches
+
   Just string all the parameters together. Spaces are ignored, so you can
   use spaces between paramaters for clarity if you wish.
   
@@ -2609,7 +2625,7 @@
   would. You must control the object..
  
 See also: @lock, locktypes, elock(), lockflags(), llockflags(), lset(),
-  llocks(), lockowner()
+  llocks(), lockowner(), lockfilter()
 & LLOCKS()
 & LOCKS()
   llocks([<object>])
@@ -2629,6 +2645,31 @@
     Basic USER:ITSME Use
 
 See also: lock(), lset(), lockflags(), llockflags(), lockowner()
+& LOCKFILTER()
+  lockfilter(<key>, <dbrefs>[, <delim>])
+
+  lockfilter() goes through <dbrefs> and tests them all against the lock 
+  <key>, returning a list of all dbrefs that pass the <key>.
+  
+  <key> is evaluated from the caller's perspective.
+  
+  This is equivilent to filter(#lambda/testlock(<key>, %%0), <dbrefs>) but
+  much more efficient, as the lock <key> is only parsed/compiled once.
+
+  Example:
+    Get all male players with a name starting with 'W'.
+    > think iter(lockfilter(NAME^W*&SEX:M*,lwho()),name(##))
+    Walker WalkerBot Wilco
+
+    List all wizroys online:
+    > think iter(lockfilter(FLAG^WIZARD|FLAG^ROYALTY,lwho()),name(##))
+    Sketch Viila Tanaku Raevnos Zebranky Cheetah Walker
+
+    List all players with an IC age > 20.
+    > think lockfilter(age:>20,lwho())
+    #123 #456 #789
+  
+See also: @lock, lock(), elock(), locktypes, filter(), testlock()
 & LOCKFLAGS()
   lockflags(<object>[/<locktype>])
   lockflags()
@@ -3190,7 +3231,7 @@
   
   alias() returns the first of <object>'s aliases. fullalias() returns all
   the aliases set for <object>. Note that, while any object can have an alias
-  set, they are only meaningful for players.
+  set, they are only meaningful for players and exits.
   
   With two arguments, alias() attempts to change the alias for <object> to
   <new alias>, as per @alias.
@@ -3200,7 +3241,7 @@
     ALIAS [#7$v]: $;No;Nol;Noli;Nolt
     > say alias(*Noltar)
     You say, "$"
-    > say fullalias(Noltar)
+    > say fullalias(*Noltar)
     You say, "$;No;Nol;Noli;Nolt"
 
 See also: fullname()
@@ -3659,15 +3700,18 @@
 
 See also: root()
 & POWERS()
+  powers()
   powers(<object>)
   powers(<object>, <power>)
 
-  The first form returns a space-separate list of powers possessed by
-  the object.  If the object does not exist, #-1 will be returned.
-
-  The second form attempts to set <power> on <object>, as per @power.
+  With no arguments, powers() returns a space-separated list of all defined
+  @powers on the MUSH. With one argument, it returns a list of the powers
+  possessed by <object>. 
   
-See also: andlpowers(), orlpowers()
+  With two arguments, it attempts to set <power> on <object>, as per
+  @power <object>=<power>.
+  
+See also: andlpowers(), orlpowers(), @power, POWERS LIST
 & QUOTA()
   quota(<player>)  
   
@@ -4582,7 +4626,7 @@
 
   See 'help sql examples' for examples.
 
-See also: anonymous attributes, sqlescape(), sql(), @sql
+See also: anonymous attributes, sqlescape(), sql(), @sql, @mapsql
 & SQL()
   sql(<query>[, <row separator>[, <field separator>[, <register>]]])
 
@@ -4608,7 +4652,7 @@
   
   See 'help sql examples' for examples.
 
-See also: sqlescape(), mapsql(), @sql, setq(), r()
+See also: sqlescape(), mapsql(), @sql, setq(), r(), @mapsql
 & SQL Examples
 
   Example of using sqlescape() to prevent injection attacks:
@@ -4657,7 +4701,7 @@
 
   You must be a WIZARD or have the Sql_Ok power to use this function.
 
-See also: sql(), mapsql(), @sql
+See also: sql(), mapsql(), @sql, @mapsql
 & SQRT()
   sqrt(<number>)
  
@@ -4833,9 +4877,11 @@
 
 See also: delete(), strinsert(), ldelete(), replace()
 & SUB()
-  sub(<number1>, <number2>)
- 
-  sub() subtracts <number2> from <number1> and returns the result.
+  sub(<number1>, <number>[, ... , <number>])
+
+  sub() subtracts <number> from <number1>. If more than one <number> argument
+  is given, each is subtracted from the result of the previous subtraction
+  in turn. The result of the final subtraction is returned.
   
 See also: add(), dec(), lmath(), vsub()
 & SUBJ()
@@ -5053,7 +5099,7 @@
     > think testlock(TYPE^PLAYER&FLAG^WIZARD, *Bilbo)
     0
   
-See also: @lock, lock(), elock(), locktypes
+See also: @lock, lock(), elock(), lockfilter(), locktypes
 & TEXTFILE()
 & TEXTENTRIES()
 & DYNHELP()
@@ -5229,14 +5275,14 @@
 & TRIM()
 & TRIMPENN()
 & TRIMTINY()
-  trim(<string>[, <character to trim>[, <trim style>]])
-  trimpenn(<string>[, <character to trim>[, <trim style>]])
-  trimtiny(<string>[, <trim style>[, <character to trim>]])
+  trim(<string>[, <characters to trim>[, <trim style>]])
+  trimpenn(<string>[, <characters to trim>[, <trim style>]])
+  trimtiny(<string>[, <trim style>[, <characters to trim>]])
  
-  trim() strips leading and/or trailing occurances of <character to trim>
-  from <string>.
+  trim() strips leading and/or trailing occurances of each of the 
+  <characters to trim> from <string>.
 
-  <character to trim> defaults to a space.
+  <characters to trim> defaults to a space.
   
   If no <trim style> is specified, characters are trimmed from both the
   left and right sides of the string. If the 'l' trim style is specified, 
@@ -5246,7 +5292,7 @@
   off of both sides of the string.
 
   Normally, the arguments for trim() are in the same order as trimpenn().
-  However, if the tiny_trim_fun @config option is on, the <character to trim>
+  However, if the tiny_trim_fun @config option is on, the <characters to trim>
   and <trim style> arguments are reversed. Use trimpenn() or trimtiny() if
   you want to specify a particular argument sequence no matter how the option
   is set.
@@ -5258,6 +5304,8 @@
       You say, "BLAM"
       > say trim(-----> WOW <---,-,r)
       You say, "-----> WOW <"
+      > say trim(=~=~=~= Trim Test =~=~=~=,= ~)
+      You say "Trim Test"
 
 See also: squish(), edit()
 & TRUNC()
Index: game/txt/hlp/pennpueb.hlp
===================================================================
--- game/txt/hlp/pennpueb.hlp	(.../184p2)	(revision 828)
+++ game/txt/hlp/pennpueb.hlp	(.../184p3)	(revision 828)
@@ -84,48 +84,53 @@
 This wizard-only function will output string as a HTML Tag.
 
 Example:
-  think [html(B)]
+  html(b)
 
 Will output (in HTML):
-  <B>
+  <b>
 
 Non-wizards should see the tag(), endtag(), and tagwrap() functions.
 & TAG()
-Function: tag(<name>,[param1[,param2...]])
+  tag(<name>[, <param1>[, ... , <paramN>]])
 
-This will output the tag 'name' with values from it's parameters.
+  This function outputs the named HTML/Pueblo tag with the given paramaters.
 
-Example:
- [tag(IMG,SRC=http://www.pennmush.org/someimage.jpg,ALIGN=LEFT,WIDTH=300)]
+  Example:
+   tag(img,src="http://www.pennmush.org/image.jpg",align="left",width="300")
 
 Will output (in HTML):
- <IMG SRC=http://www.pennmush.org/someimage.jpg ALIGN=LEFT WIDTH=300>
+  <img src="http://www.pennmush.org/image.jpg" align="left" width="300">
 
+See also: endtag(), tagwrap(), html()
 & ENDTAG()
-Function: endtag(<name>)
+  endtag(<name>)
 
-This will output an end tag 'name'.
 
-Example:
- [endtag(IMG)]
+  Outputs a closing HTML/Pueblo tag for the named tag.
+
+  Example:
+   endtag(img)
 
 Will output (in HTML):
- </IMG>
+ </img>
 
+See also: tag(), tagwrap(), html()
 & TAGWRAP()
-Function: tagwrap(<tag>[,<parameters>],<string>)
+Function: tagwrap(<name>[,<parameters>],<string>)
 
-This will output 'tag' with parameters, followed by 'string', and then
-a closing tag for 'tag'. 
+  This function outputs <string>, wrapped in the <name> HTML/Pueblo tag
+  with the specified paramaters.
 
-Example:
- [tagwrap(A,HREF=http://lists.pennmush.org,PennMUSH Lists)]
+  Example:
+   tagwrap(a,href="http://download.pennmush.org",PennMUSH Downloads)]
 Will output (in HTML):
- <A HREF=http://lists.pennmush.org>PennMUSH Lists</A>
+ <a href="http://download.pennmush.org">PennMUSH Downloads</a>
 
-A particularly important use of this function is tagwrap(PRE,<string>).
-Because Pueblo works like an html browser, spaces and tabs are compressed
-to a single space. If you have code (a +who function, for example) that
-relies on exact spacing, surround its output with a tagwrap(PRE,...)
-so that Pueblo will render it as "preformatted" text.
+  A particularly important use of this function is tagwrap(pre, <string>).
+  Because Pueblo works like an html browser, spaces and tabs are compressed
+  to a single space. If you have code (a +who function, for example) that
+  relies on exact spacing, surround its output with a tagwrap(pre,...)
+  so that Pueblo will render it as "preformatted" text.
+  
+See also: tag(), endtag(), html()
 
Index: game/txt/hlp/pennv184.hlp
===================================================================
--- game/txt/hlp/pennv184.hlp	(.../184p2)	(revision 828)
+++ game/txt/hlp/pennv184.hlp	(.../184p3)	(revision 828)
@@ -1,4 +1,4 @@
-& 1.8.4p2
+& 1.8.4p3
 & changes
 This is a list of changes in this patchlevel which are probably of
 interest to players. More information about new commands and functions
@@ -11,6 +11,138 @@
 A list of the patchlevels associated with each release can
 be read in 'help patchlevels'.
 
+Version 1.8.4 patchlevel 3                                 Mar 18,  2011
+
+Events:
+ * Event system added. Certain things can now trigger events using @config
+   event_handler. See "help events" and "help event <type>". [GM]
+ * dump events: dump`5min, dump`1min, dump`complete.
+ * object events: object`create, object`destroy, object`move,
+   object`rename, object`kill.
+ * sql events: sql`connect, sql`disconnect.
+ * signal events: signal`usr1, signal`usr2.
+ * player events: player`create, player`fail, player`connect,
+   player`disconnect, player`inactivity.
+ * socket events: socket`connect, socket`disconnect
+ * database events: db`dbck, db`purge, db`wcheck
+ * Periodic system events like warnings checks and db consistency
+   checks are now handled by a timed queue and integrated with
+   softcode events. Local hackers: This involves changes to
+   local.c. If you have no changes in local.c, just delete the file.
+   Otherwise, see HACKING.184 for more info. [SW]
+
+Commands:
+ * @hook/override/inplace - You can now run softcode with the same priority
+   as hardcode! [GM]
+ * @lock (and all lock keys) now accepts NAME^<pattern> for matching against
+   an object's name. [GM]
+ * @mapsql passes row results to attributes. Suggested by Mercutio. [GM]
+ * @dig now takes an optional garbage dbref argument to specify the new
+   dbref. Suggested by Paige. [GM]
+ * The help command now does some auto-expansion of topics. For example,
+   'help @chan ad2' will be expanded to match 'help @channel admin2'. [MG]
+ * @force/inplace, @switch/inplace and @select/inplace now run their commands
+   without queueing new events. These are limited by the @include limit. [GM]
+ * @hide without a switch now toggles hide status, rather than defaulting to
+   @hide/on. [MG]
+ * @log now takes a /recall switch for showing wizards the most recent activity
+   in a log file. [SW]
+ * @lemit and @zemit both have /noisy and /silent switches to suppress/show
+   confirmation messages. With no switch, silent_pemit determines whether
+   the message is shown. Suggested by Paige for consistancy. [MG]
+   
+Attributes:
+ * New no_debug flag, which prevents debug info being shown for an attribute
+   when the object is set DEBUG. [MG]
+   
+Config:
+ * New @config option chan_title_len controls the length of @channel/title's.
+   Suggested by Paige. [MG]
+
+Locks:
+ * New @lock/pay, controls who can "give" an object pennies or "buy" items
+   from an object. Based on patch by Covenent. [MG]
+
+Functions:
+ * lockfilter() lets you filter a list of dbrefs using a lock key. [GM]
+ * align() now has '$' (nofill) as an option. Ideal for rightmost columns.
+   Suggested by Minion. [GM]
+ * dig() now takes an optional garbage dbref argument to specify the new
+   dbref. Suggested by Paige. [GM]
+ * convutctime() and convtime(<time>, utc) to convert a timestring to
+   # of seconds since UTC. Patch by Minion.
+ * powers() with no arguments now returns a list of powers, similar to
+   lflags() with no args. [MG]
+ * trim() can now trim multiple characters. [MG] [GM]
+ * In some cases, privs are no longer needed to use locate(). [MG]
+ * cmogrifier(), returns the mogrifier object for a channel. Suggested by
+   Trinsec, patch by Minion.
+
+Minor Changes:
+ * The Can_Nspemit @power has been renamed to Can_Spoof, to better reflect
+   its uses. Can_Nspemit is still an alias. [MG]
+ * Considerable improvement in the speed of functions that sort
+   case-insensitively, particularly using 'm' sort (Now default). [GM]
+ * Combined fun_setinter, fun_setdiff and fun_setunion into fun_setmanip. [GM]
+ * For hardcoders: list2arr and list2arr_ansi now take a third argument
+   on whether to include empty items. [GM]
+ * page and @mail will report to you if your recipient(s) cannot reply
+   to you. Suggested by Paige. [GM]
+ * The debug attribute flag now shows more debug info. [MG]
+ * @oemit now does better object matching, can match names with spaces when
+   enclosed in double quotes, and, when given a <room> but no matching
+   objects, shows the message to everyone in the room, instead of noone.
+   From a bug reported by Paige. [MG]
+ * Paranoid objects now see nospoof messages for their emits. [MG]
+ * ANSI is now ignored when checking the length of channel titles. Suggested
+   by Paige. [MG]
+ * @decompile with a <prefix> now shows cmds for setting attribute flags.
+   @decompile/tf still omits cmds for attr flags. [MG]
+ * @mail <msg-lists> which don't specify a folder now act on your current
+   folder, instead of Folder 0. Suggested by Paige, patch by Minion.
+ * @dig, @open and @name now set exit aliases into the @alias attribute,
+   instead of including them in the exit name. Also, @name can now set/clear
+   the @alias of players/exits while changing the name. See help @name for
+   details. Suggested by Minion. [MG]
+ * The logging code has been rewritten to make extending it with further
+   log files easier. [SW]
+ * When used by a non-player, @search and related functions now search from
+   the perspective of the object's owner. Suggested by Covenent. [MG]
+ * The LASTPAGED attribute now stores objids instead of names, allowing you
+   to repage even when the target changes their name. [MG]
+ * When zwho() or @chzone fail because you don't pass the @lock/zone, zone
+   failure verbs are triggered (as per 'help failure'). Based on a patch by
+   Covenent. [MG]
+ * sub() can now take more than two arguments. Suggested by Paige. [MG]
+ * In the hardcode, disconnected players in the DESC struct are shown as -1
+   instead of 0, to avoid conflicts with #0. Based on patch by Paige. [MG]
+ * It was sometimes possible to "buy" items from yourself. [MG]
+
+Fixes:
+ * Fixing list type autodetect. [GM]
+ * Help fixes by Daniel Powell, AnneLions, Minion and others. [MG]
+ * Connect/disconnect messages for combined channels incorrectly showed
+   NOSPOOF data. Reported by Sketch. [MG]
+ * The delimiter between combined channel names in @chatformat is now '|'
+   instead of ' | ', as documented. Reported by Trinsec. [MG]
+ * ansi(h,) now returns absolutely nothing, instead of an ansi-highlighted
+   nothing. Fixes a few minor/obscure bugs. [MG]
+ * @edit sometimes displayed a success message even when it failed. [MG]
+ * @cpattr/@mvattr would sometimes copy attribute flags, even when the
+   attribute value couldn't be copied. [MG]
+ * Bug in attribute comparisons added in p2 could cause attributes to
+   not be found at times. [MG]
+ * sortby()s results would sometimes be reversed by mistake. [GM]
+ * Minor bugfix in @include. [MG]
+ * round() sometimes returned numbers with more decimal digits than
+   desired. 
+ * The '*' option in locate() didn't actually include all match types. [MG]
+ * @include incorrectly refunded the queue_cost, giving people free pennies.
+   Reported by Covenent. [MG]
+ * lnum() didn't handle negative <step>s well. Reported by Minion. [MG]
+ * comp()s results was sometimes negated. Reported by Covenent. [MG]
+
+& 1.8.4p2
 Version 1.8.4 patchlevel 2                                 Dec 06,  2010
 
 Major Changes:
Index: game/txt/hlp/penntop.hlp
===================================================================
--- game/txt/hlp/penntop.hlp	(.../184p2)	(revision 828)
+++ game/txt/hlp/penntop.hlp	(.../184p3)	(revision 828)
@@ -38,8 +38,7 @@
   
   You should not type the [] or <> brackets when entering a command.
   
-(continued in help newbie2 -- type 'help newbie2' without the single
-quotes)
+  Continued in 'help newbie2' -- type 'help newbie2' without the quotes.
   
 & newbie2
 
@@ -54,11 +53,11 @@
   
   Some common commands that you should look at help for are:
   
-    look   say    go    page    pose    take     give    home
+    look   say    go    page    pose    get     give    home
   
   Just type help <command> for help. Example: help page
   
-(continued in help newbie3)
+  Continued in 'help newbie3'.
 & newbie3
 
   There is help available on every standard MUSH command. If you see a
@@ -95,7 +94,7 @@
   LINKING                  LISTENING                LISTS                    
   LOOPING                  MASTER ROOM              MATCHING
 
-(continued in help topics2)
+  Continued in 'help topics2'.
 & topics2
   ME                       MONEY                    MUSHCODE
   NON-STANDARD ATTRIBUTES  PARENTS                  POWERS
@@ -109,28 +108,26 @@
   
 Type "help <topic name>" for help.
 & ACTION LISTS
-  Action lists are simply lists of actions that are all executed at
-  once.  You can have an action list in a user-defined command, in one
-  of the a-attributes, or in many other commands. Action lists may not
-  be executed directly from a client, except in the case of a command
-  which forces a re-insertion into the queue such as @switch or
-  @dolist.
+  An "action list" is simply a list of MUSH commands which are run together,
+  one after the other. Each command in the list is separated by a semicolon.
+  Action lists appear in many places: in user-defined commands, triggered in
+  @a-attributes by the MUSH, and even as arguments to other commands, like
+  @switch and @dolist.
 
-  Actions in an action list are separated by semicolons. Each action
-  is simply a separate MUSH command. If part of the action (such as
-  the text in an @emit, for example) contains a semi-colon or comma,
-  you may need to enclose that part in curly braces {}. You can also
-  nest action lists inside each other by enclosing each action list in
+  If part of the command (such as the text in an @emit, for example) contains
+  a semi-colon, you may need to enclose that part in curly braces {}. You can
+  also nest action lists inside each other by enclosing each action list in
   braces {}.
 
   Substitution will be performed on the contents of action lists before
   they are executed.
 
-(continued in help action2)
+  See 'help action2' for some examples.
+See also: @-ATTRIBUTES, VERBS, $-COMMANDS
 & ACTION2
   Example 1:
-    > @asuccess Gift = @pemit %#={The box pops open; surprise!} ; 
-        @name me=New Toy ; @desc me={A shiny new toy, just for %N!}
+    > @asuccess Gift=@pemit %#={The box pops open; surprise!} ; 
+        @name me=New Toy ; @desc me=A shiny new toy, just for %n!
     > take gift
     The box pops open; surprise!
     > look new toy
@@ -139,7 +136,7 @@
             
   Example 2:
     > &TEST me=$test:@emit {Testing; testing; one, two.} ; 
-        @dolist 1 2 3={think {Test ##, success.} }
+        @dolist 1 2 3={think Test ##, success.}
     > test
     Testing; testing; one, two.
     Test 1, success.
@@ -150,29 +147,27 @@
 & ANCESTORS
   ANCESTORS
 
-  Objects can inherit attributes from other objects through the use of
-  parents. An object's parent, its parent's parent, its parent's
-  parent's parent, etc. constitute the object's "parent chain" and
-  lookups work the way up the chain until an inheritance occurs.
+  Objects can inherit attributes and locks from other objects through the use
+  of parents. An object's parent, its parent's parent, its parent's parent's
+  parent, etc. constitute the object's "parent chain" and lookups work the 
+  way up the chain until an inheritance occurs.
 
-  Ancestors are "virtual parents" that are assumed to be last on every
-  parent chain. There is one ancestor for each object type (room,
-  exit, thing, player), and @config lists the dbref of each ancestor
-  object (@config ancestor_room, etc.) Under normal circumstances, if
-  an attribute can't be retrieved from an object or any of its
-  explicit parents, the attribute will be looked for on the
-  appropriate ancestor.  The ORPHAN flag may be set on an object to
-  cause lookups on that object to ignore ancestors (like the
+  Ancestors are "virtual parents" that are assumed to be last on every parent
+  chain. There is one ancestor for each object type (room, exit, thing,
+  player), and @config lists the dbref of each ancestor object (@config 
+  ancestor_room, etc). Under normal circumstances, if an attribute/lock can't
+  be retrieved from an object or any of its explicit parents, the attribute
+  will be looked for on the appropriate ancestor.  The ORPHAN flag may be set
+  on an object to cause lookups on that object to ignore ancestors (like the
   pre-ancestor behavior).
 
-  Ancestors may themselves have parent chains, but these are
-  (obviously) not virtually terminated by ancestors.
+  Ancestors may themselves have parent chains, but these are (obviously) not 
+  virtually terminated by ancestors.
 
-  Note that the choice of which ancestor to look up is based on the
-  type of the *child* object, as is the check of the ORPHAN flag.
-  Also note that ancestors are *not* checked for $-commands or
-  ^-commands; you should use the master room for global commands,
-  instead.
+  Note that the choice of which ancestor to look up is based on the type of 
+  the *child* object, as is the check of the ORPHAN flag. Also note that 
+  ancestors are *not* checked for $-commands or ^-commands; you should use 
+  the master room for global commands, instead.
 
 See also: PARENTS, ORPHAN
 & ANONYMOUS ATTRIBUTES
@@ -193,10 +188,12 @@
 
   See 'HELP ANONYMOUS2' for examples.
 & ANONYMOUS2
+& LAMBDA2
+& #LAMBDA2
   A typical usage of anonymous attributes would be to convert
   a list of dbrefs to names, as so:
 
-  >say map(#lambda/name(\%0), #3 #12 #23)
+  > say map(#lambda/name(\%0), #3 #12 #23)
   You say, "Joe Robert Sally"
 
   Because the code is parsed twice, you can actually build parts of it
@@ -204,19 +201,20 @@
   a lattrval function, which is like lattr() but it only returns
   non-empty attributes:
 
-  &lattrval me=
-   filter(#lambda/hasattrval([secure(before(%0, /))], \%0), lattr(%0))
+  > &lattrval me=
+     filter(#lambda/hasattrval([decompose(before(%0, /))], \%0), lattr(%0))
   
-  The first time '#lambda/hasattrval([secure(before(%0, /))], \%0)' is
+  The first time '#lambda/hasattrval([decompose(before(%0, /))], \%0)' is
   parsed in a call like 'u(lattrval, #1234)', it is turned into
   '#lambda/hasattrval(#1234, %0)', thus avoiding the need for a setq()
   or the like to store the top-level %0 for use in a real attribute
   called by filter(). However, this can lead to problems with
-  evaluating un-trusted code. Use secure() or escape() where
-  neccessary.
+  evaluating un-trusted code. Use decompose() where neccessary.
 
   See 'HELP ANONYMOUS3' for another example.
 & ANONYMOUS3
+& LAMBDA3
+& #LAMBDA3
   
   You can also use lit() to avoid having the code evaluated twice, if
   needed. For example, this code, which returns all unlinked exits in
@@ -233,6 +231,8 @@
   See 'HELP ANONYMOUS4' for a list of functions that support anonymous
   attributes.
 & ANONYMOUS4
+& LAMBDA4
+& #LAMBDA4
   The following functions support anonymous attributes:
   
   filter()    filterbool()   fold()      foreach()   map()      mapsql()
@@ -240,16 +240,14 @@
 & ATTRIB-OWNERSHIP
   ATTRIBUTE OWNERSHIP
   
-  The latest person to set an attribute on an object is the owner of
-  that attribute. If you lock an attribute, using the @atrlock
-  command, only the person who owns the attribute will be able to
-  alter the attribute. This allows you to create standard commands on
-  objects and then @chown them to others without letting them alter
-  them.
+  The latest person to set an attribute on an object is the owner of that 
+  attribute. If you lock an attribute, using the @atrlock command, only 
+  the person who owns the attribute will be able to alter the attribute. 
+  This allows you to create standard commands on objects and then @chown 
+  them to others without letting them alter them.
 
-  Attribute ownership is NOT changed when the object itself is
-  @chown'ed.  To change attribute ownership, you must use the
-  @atrchown command.
+  Attribute ownership is NOT changed when the object itself is @chown'ed. 
+  To change attribute ownership, you must use the @atrchown command.
 
   You must control an object in order to set attributes on it.
 
@@ -278,7 +276,7 @@
   QUEUE (*)     RQUOTA (*)    RUNOUT        SEX           STARTUP       
   SUCCESS       TFPREFIX
 
-(continued in help attributes2)
+  Continued in 'help attributes2'.
 & ATTRIBUTES2
   An attribute is part of the code on an object that makes it
   unique. An attribute can contain any sort of text -- from a single
@@ -294,7 +292,7 @@
   named anything you like. Please see 'help NON-STANDARD ATTRIBUTES'
   for more information on those.
 
-(continued in help attributes3)
+  Continued in 'help attributes3'.
 & ATTRIBUTES3
   Any attribute name can be shortened, but a shorter forms run the
   risk of conflicting with other attribute names.  This could result
@@ -309,7 +307,7 @@
   To see the attributes that are set on you or on any of the objects
   you own, you should use the "examine" command. See 'help examine'.
   
-(continued in help attributes4)
+  Continued in 'help attributes4'.
 & ATTRIBUTES4
   Attributes can be owned by someone other than the object they are
   set on.  This allows the person to change the content of just that
@@ -358,7 +356,7 @@
   consider "true" or "false", however, depends on the setting of the
   "tiny_booleans" config option (@config tiny will show this).
 
-(continued in help boolean2)
+  Continued in 'help boolean2'.
 & BOOLEAN2 
   If tiny_booleans is...
   no                       FALSE: null string, 0, any negative db
@@ -378,7 +376,7 @@
   0<non-numbers..>      TRUE                    FALSE               *
   <non-numbers...>      TRUE                    FALSE               *
 
-(continued in help boolean3)
+  Continued in 'help boolean3'.
 & BOOLEAN3
 
   Examples (assuming tiny_booleans is "no"):     
@@ -442,18 +440,15 @@
 
 See also: controls(), TRUST, MISTRUST, ZONES, SHARED PLAYERS
 & COSTS
-  These are usually:
+  Some things on the MUSH cost pennies. The default costs are shown below:
   
           kill: 10 pennies (or more, up to 100 pennies)
-          page: 0 pennies
           @dig: 10 pennies
           @create: 10 pennies (or more)
-          @find: 100 pennies
-          @search: 100 pennies
-          @entrances: 100 pennies
+          @search: 100 pennies *
           @link: 1 penny (if you  didn't already own it,
                           +1 to the previous owner).
-          @open: 1 penny (2 pennies if linked at  the same time)
+          @open: 1 penny (2 pennies if linked at the same time)
   
   Type '@config/list costs' to get the costs for the MUSH you are on.
 
@@ -505,26 +500,43 @@
   immediately find the object rather than checking through all the
   contents of your area to see if one matches the name.
 
-(continued in help dbref2)
+  Continued in 'help dbref2'.
 & DBREF2
   
-  If you own or control an object, you will see its dbref number
-  listed right after its name when you look at it (unless you are set
-  MYOPIC).
+  If you own or control an object, you will see its dbref number listed 
+  right after its name when you look at it (unless you are set MYOPIC).
 
   Example:
     > look me
     Cyclonus(#3PWenAMc)
     A very short desc.
 
-  The dbref number is indicated by the number/pound sign
-  (#). Cyclonus's dbref is #3. The letters following the dbref are the
-  abbreviations of the flags set on the object. NOTE: the abbreviation
-  of the OPAQUE flag is 'O' (o), which looks like '0' (zero) on some
-  clients. Make sure you have the right number before using it in your
-  code!
+  The dbref number is indicated by the number/pound sign (#). Cyclonus's 
+  dbref is #3. The letters following the dbref are the abbreviations of the
+  flags set on the object. NOTE: the abbreviation of the OPAQUE flag is 'O'
+  (o), which looks like '0' (zero) on some clients. Make sure you have the
+  right number before using it in your code!
 
-See also: MYOPIC, OPAQUE, MUSHCODE
+See also: MYOPIC, OPAQUE, MUSHCODE, MATCHING, OBJIDS
+& OBJIDS
+& OBJECT IDS
+
+  When an object is destroyed, its dbref number will eventually be recycled
+  and given to a newly created object. This can cause problems in code,
+  particularly in database code which stores members of a group, as code
+  which was meant to refer to the old object ends up referring to the new one
+  by mistake.
+  
+  To avoid this problem, you can use the "object id", or objid, instead of
+  the dbref. An object id consists of the object's dbref, a colon, and then
+  the object's creation time. Objids can be used anywhere dbrefs can and,
+  because the creation time is different each time the dbref is recycled, the
+  objid is totally unique to each object.
+  
+  The objid() function returns the object id of an object, and the %:
+  substitution evaluates to the objid of the enactor. 
+  
+See also: objid(), @lock-objid, DBREFS
 & DROP-TOS
 & DROPTOS
 
@@ -551,30 +563,57 @@
 & %~
 & %:
 & ENACTOR
-  The enactor is the object that does something (enacts something :).
-  This is an important concept in MUSH, because the way many commands
-  work will depend on who enters the command (ie, who the enactor is).
+  The enactor is the object which causes something to happen. This is an 
+  important concept in MUSH, because the way many commands work will depend
+  on who enters the command (ie, who the enactor is). Note that while the
+  enactor is the object which -caused- code/a command to run, it is not
+  necessarily the object which is running the code (that's the executor).
   Any type of object can be an enactor.
 
-  There are five %-substitutions that involve the enactor:
+  There are eight %-substitutions that involve the enactor:
     %# = the enactor's dbref
-    %N = the enactor's name, first letter capitalized
-    %n = the enactor's name, first letter as-is
+    %n = the enactor's name
     %~ = the enactor's accented name
     %: = the enactor's unique identifier, like objid(%#)
+    %a, %o, %p, %s = pronoun substitutions, based on the enactor's @sex.
+                     See 'help gender' for more information.
 
-  If, for example, you have an @osucc on an object that includes the
-  %n symbol, whenever someone picks up the object, that %n will be
-  replaced with the name of the enactor (the person who typed 'get
-  <object>' in this case).
+  If, for example, you have an @osuccess on an object that includes the %n
+  subtitution, whenever someone picks up the object, that %n will evaluate to
+  the name of the enactor (the person who typed 'get <object>' in this case).
   
-See also: EXECUTOR, CALLER, SUBSTITUTION, DBREF
+See also: EXECUTOR, CALLER, SUBSTITUTIONS, DBREF
+& %!
+& EXECUTOR
+  The executor of a command is the object actually carrying out the command
+  or running the code. This differs from the enactor, because the enactor is
+  the object that sets off the command. In some cases, the enactor and the
+  executor will be the same. The substitution %! evaluates to the dbref of
+  the executor of the code.
+
+  For example:
+    > @emit %n (%#) is the enactor and %! is the executor!
+    Cyclonus (#6) is the enactor and #6 is the executor!
+    > @create Box
+    Created: Object #10
+    > &EMIT box=$emit: @emit %n (%#) is the enactor and %! is the executor!
+    > emit
+    Cyclonus (#6) is the enactor and #10 is the executor!
+
+  In the first case, Cyclonus directly entered the command and was
+  therefore both the enactor and the executor. In the second, Cyclonus
+  set off the command on the box, so Cyclonus was still the enactor,
+  but the box was the object that was actually doing the @emit, and
+  was thus the executor.
+
+See also: ENACTOR, CALLER, SUBSTITUTIONS
 & %@
 & CALLER
-  In functions, the caller is the object which ran the function. The caller's
-  dbref is available using the %@ substitute, and is useful in code which is
-  evaluated using ufun() or similar functions, to tell who is evaluating the
-  attribute.
+  The caller is the object which causes an attribute to be evaluated (for
+  instance, by using ufun() or a similar function). The substitution %@ 
+  evaluates to the caller's dbref. It's particularly useful for functions
+  with side-effects, to check that the object evaluating the function has
+  permission.
   
   Example:
     > &cmd_test Foo=$test: @emit ufun(Bar/fun_test)
@@ -582,6 +621,8 @@
     > test
     Mike(#5) typed 'test', and Foo(#6) ufun()'d this!
     
+    > &wizfun Foo=if(hasflag(%@, Wizard), ufun(wizfun2), #-1 Sorry)
+    
 See also: ENACTOR, EXECUTOR
 & EVALUATION ORDER
   Whenever some text is entered by an object, the MUSH attempts to match it
@@ -620,57 +661,56 @@
 
   Because local $-commands overrule global $-commands, you can easily
   prevent a global $-command from working in a specific room by setting
-  a copy of the global $-command in that room. Alternatively, if a
-  global $-command is oddly not working in a room, you should check for
-  copies of the command word in the room (using @scan). Wizards who want to
-  ensure a global $-command always takes precedence over a local one should
-  use @command/add and @hook/override, to make the command run as a regular
+  a copy of the global $-command in that room. Alternatively, if a global 
+  $-command is oddly not working in a room, you should check for copies of 
+  the command word in the room (using @scan). Wizards who want to ensure a
+  global $-command always takes precedence over a local one should use 
+  @command/add and @hook/override, to make the command run as a regular
   game command instead of a softcoded global.
   
 See also: @command, @hook, $-commands, huh_command
-& %!
-& EXECUTOR
-  The executor of a command is the object actually carrying out the
-  command.  This differs from the enactor, because the enactor is the
-  object that sets off the command. In some cases, the enactor and the
-  executor will be the same. There is a %-substitution, %!, that is
-  replaced by the dbref # of the executor of the command.
-
-  For example:
-    > @emit %n (%#) is the enactor and %! is the executor!
-    Cyclonus (#6) is the enactor and #6 is the executor!
-    > @create Box
-    Created: Object #10
-    > &DO_EMIT box=$emit:@emit %n (%#) is the enactor and %! is the executor!
-    > emit
-    Cyclonus (#6) is the enactor and #10 is the executor!
-
-  In the first case, Cyclonus directly entered the command and was
-  therefore both the enactor and the executor. In the second, Cyclonus
-  set off the command on the box, so Cyclonus was still the enactor,
-  but the box was the object that was actually doing the @emit, and
-  was thus the executor.
-
-See also: ENACTOR, CALLER, SUBSTITUTION
 & FAILURE
   FAILURE  
 
-  A "failure" usually occurs when you try to do something that is
-  governed by an @lock and you don't pass the lock. If you try to take
-  a player or thing, and you don't pass their @lock, you will set off
-  their @fail/@ofail/@afail attributes. If you try to go through an
-  exit, and you don't pass its @lock, you will similarly set off its
-  @fail/@ofail/@afail. Other failure sets include:
+  A "failure" usually occurs when you try to do something that is governed 
+  by an @lock and you don't pass the lock. If you try to take a player or 
+  thing, or pass through an exit, and you don't pass its Basic @lock, you 
+  will set off their  @failure/@ofailure/@afailure attributes. A few failures
+  have special attributes, while others use <locktype>_LOCK`FAILURE,
+  <locktype>_LOCK`OFAILURE and <locktype>_LOCK`AFAILURE attributes.
 
-  Failing to enter an object (@efail, @oefail, @aefail)
-  Failing to leave an object (@lfail, @olfail, @alfail)
-  Failing to use an object (@ufail, @oufail, @aufail)
-  Other failures (&<locktype>_LOCK`FAILURE, &<locktype>_LOCK`OFAILURE, 
-    &<locktype>_LOCK`AFAILURE)
+  See 'help failure2' for a list of failure verbs and when they're triggered.
 
-  See @lock and locktypes for more information on lock types.
+  See 'help @lock' and 'help locktypes' for more information on lock types.
 
-See also: @lock, @fail, @efail, @lfail
+See also: verbs, @lock, @failure, @efail, @lfail
+
+& failure2
+  The following failures are defined in PennMUSH:
+  
+  Failure to...                                 Lock     Attribute
+  --------------------------------------------- -------- --------------------
+  "get" a player/thing, pass through an exit,   Basic    @failure
+    or "look" in a room
+  run an $-command on an object                 Command* COMMAND_LOCK`FAILURE
+  use zwho()                                    Zone     ZONE_LOCK`FAILURE
+  leave your current location                   Leave    @lfail
+  "take" from an object                         Take     TAKE_LOCK`FAILURE
+  "drop" a thing, or drop something in a room   Drop     DROP_LOCK_FAILURE
+   enter an object                              Enter    @efail
+  "follow" an object                            Follow   FOLLOW_LOCK`FAILURE
+  "give" an object away                         Give     GIVE_LOCK`FAILURE
+  "give" money to or "buy" from an object       Pay      PAY_LOCK`FAILURE
+  "@chzone" something to a zone                 Chzone   CHZONE_LOCK`FAILURE
+  "use" an object                               Use      @ufail
+  speak via say/pose/@*emit/teach in a room     Speech   SPEECH_LOCK`FAILURE
+  "page" or "@pemit" to an object               Page     PAGE_LOCK`FAILURE**
+  
+  
+  * The Use lock can also prevent you from running an $-command, but it will
+    still trigger COMMAND_LOCK`FAILURE.
+  ** @haven or @away will also be shown on failure to "page", if set
+  
 & GENDER
 & SEX
   Gender on a MUSH is entirely up to you. You can set yourself (or any
@@ -679,47 +719,52 @@
   the object is neuter. Setting a gender attribute will enable pronoun
   substitution by the MUSH. The SEX attribute is visual to anyone who
   wants to see it.
+  
+  The obj(), subj(), poss() and aposs() functions return different pronouns
+  for an object based on its @sex, and the %o, %s, %p and %a substitutions
+  return the same pronouns for the enactor.
 
 See also: @sex, SUBSTITUTION
 & GLOBALS
 & GLOBAL COMMANDS
   A command is "global" if it can be used anywhere in the world of the
-  MUSH. The standard MUSH commands are all global, so this term is
-  usually used to refer to user-defined commands on objects in the
-  Master Room of the MUSH. Global commands very greatly from MUSH to
-  MUSH, but you can usually find MUSH-specific help on them by typing
-  "+help".
+  MUSH. The standard/built-in MUSH commands are all global, so this term is
+  usually used to refer to user-defined commands on objects in the Master 
+  Room of the MUSH. Global commands very greatly from MUSH to MUSH, but you 
+  can usually find MUSH-specific help on them by typing "+help".
 
-See also: MASTER ROOM, USER-DEFINED COMMANDS, EVALUATION
+See also: MASTER ROOM, USER-DEFINED COMMANDS, EVALUATION ORDER
 & HERE
-  The word 'here' refers to the room you are in. For example, to
-  rename the room you're in (if you control it), you could enter
-  "@name here= <new name>".
+  The word 'here' refers to the room you are in. For example, to rename the 
+  room you're in (if you control it), you could use:
+
+    > @name here=<new name>
+    
+See also: MATCHING
 & HOMES
 & HOME
-  Every thing or player has a home, which is usually the room where it
-  was created. You can reset your home or the home of any object you
-  own with the @link command: @link <me|object>=<location>. You must
+  Every thing or player has a home, which is usually the room where it was
+  created. You can reset your home or the home of any object you own with
+  the @link command: @link [me | <object>]=<location>. You must
   also control <location>, unless that location (room or thing) is set
   ABODE or LINK_OK.
 
-  When a player types 'home', s/he is sent back to the home room. When
-  a thing with the STICKY flag set on it is dropped, it also goes to
-  its home location. Note that if the FIXED flag is set on a player,
-  he/she cannot use the 'home' command.
+  When a player types 'home', she is sent back to the home room. When a 
+  thing with the STICKY flag set on it is dropped, it also goes to its 
+  home location. Note that if the FIXED flag is set on a player, she cannot
+  use the 'home' command.
 
   You can create an exit that sends players home by doing:
         @link <exit name>=home
   You can set the drop-to in a room to home by doing:
         @link <room dbref or "here">=home
         
-  The home of an exit is its source (the room it's located in). You
-  can change the home/source of an exit by @teleporting it to another
-  room.
+  The home of an exit is its source (the room it's located in). You can
+  change the home/source of an exit by @teleporting it to another room.
 
   The home of a room is its drop-to.
 
-See also: DROP-TOS, @link, STICKY, LINK_OK, FIXED, EXITS
+See also: DROP-TOS, @link, STICKY, LINK_OK, FIXED, EXITS, home(), loc()
 & INTERIORS
   Here's a quick description of how to make things that can be
   entered:
@@ -735,7 +780,7 @@
   @enter car=You get into the car.      { The plain messages are shown to 
   @leave car=You get out of the car.    { the one entering or leaving 
        
-(continued in help interiors2)
+  Continued in 'help interiors2'.
 & INTERIORS2
   Now, if you want people inside to be able to hear and communicate
   with the outside, you also need to do the following.
@@ -794,7 +839,7 @@
     Breaker has arrived.
     Welcome Mat says, "Welcome, Breaker!"
 
-(continued in help listening2)
+  Continued in 'help listening2'.
 & ^
 & ^-LISTENS
 & LISTENING2
@@ -817,7 +862,7 @@
   Such attributes can also be @triggered as if the ^<pattern>: did not
   exist.
 
-(continued in help listening3)
+  Continued in 'help listening3'.
 & LISTENING3
   By default, ^-patterns work like @ahear. To have them work like
   @amhear, set the AMHEAR attribute flag on the attribute; to have
@@ -899,12 +944,15 @@
   control, since when all your money is spent, you can't queue any
   more commands.
 
-  The money system can also be used on player-created objects by
-  giving them @cost/@payment/@opayment/@apayment attributes. When
-  someone then pays the object by giving it the right number of
-  pennies, the attributes are triggered.
+  The money system can also be used on player-created objects by setting 
+  @cost/@payment/@opayment/@apayment attributes and using the "give" command
+  to give pennies, or by setting @pricelist/@buy/@obuy/@abuy attributes and
+  buying items with the "buy" command. The Pay @lock on an object controls
+  who can give it pennies.
+  
+  The "score" command tells you how many pennies you have.
 
-See also: COSTS, give, @cost, @pay, @opay, @apay
+See also: COSTS, give, @cost, @payment, @lock, buy, @buy, score, money()
 & MUSHCODE
 & SOFTCODE
 
@@ -922,7 +970,7 @@
   can be triggered by using a user-defined command or by using
   @trigger.
   
-(continued in help mushcode2)
+  Continued in 'help mushcode2'.
 & MUSHCODE2
 
   If you would like to learn more about mushcoding and how to create
@@ -981,7 +1029,7 @@
   also checked in similar fashion.  See 'help ANCESTORS' for more
   about ancestors.
 
-(continued in help parents2) 
+  Continued in 'help parents2'.
 & PARENTS2
  
   Note that the only properties inherited are attributes. In
@@ -1002,7 +1050,7 @@
   executed, "me", for example, refers to the child, not the parent,
   and the $-command's associated actions are performed by the child.
 
-(continued in help parents3)
+  Continued in 'help parents3'.
 & PARENTS3
   Attributes with $-commands _are_ inherited from the parent and
   previous generations. Conflicts are resolved not by the $-command
@@ -1019,7 +1067,7 @@
   > check
   I'm the child
 
-(continued in help parents4)
+  Continued in 'help parents4'.
 & PARENTS4
   If a parent has the same $-command name in a different attribute,
   however, BOTH the parent and child commands will execute:
@@ -1037,7 +1085,7 @@
   parent object, rather than having the $commands checked on the
   parent object.
 
-(continued in help parents5)
+  Continued in 'help parents5'.
 & PARENTS5
  
   Parent-object $-command checking is at its most efficient when there
@@ -1052,7 +1100,7 @@
   the parent that you want to make impossible to read, it's safe to
   allow the purchasers of your object to @chown their copy.
 
-See also: @parent, $-COMMANDS, ATTRIBUTES, ANCESTORS
+See also: @parent, $-COMMANDS, ATTRIBUTES, ANCESTORS, ORPHAN, pfun()
 & POWERS LIST
   Powers can be granted only by wizards, using the @power command.
   Powers cannot be granted to guest characters or players who are set
@@ -1075,7 +1123,7 @@
   long_fingers          Can do things remotely, like "get".
   many_attribs          Can exceed max_attrs_per_obj.
 
-(continued in help powers2)
+  Continued in 'help powers2'.
 & POWERS2
 & POWERS LIST2
   no_pay *              Doesn't need money for anything
@@ -1094,7 +1142,7 @@
   tport_anything        Can @teleport anything.
   tport_anywhere        Can @teleport to anywhere.
   unkillable *          Cannot be killed
-  can_nspemit           Can use @nspemit and nspemit()
+  can_spoof             Can use @ns*emit, ns*emit() and @*emit/spoof
   
   * When these powers are set on a player, all the objects they own which
     are not set MISTRUST are also considered to have the power.
@@ -1416,7 +1464,7 @@
   > command whee+blert foo
   whee is in register 0 and blert foo is in register 1.
 
-(continued in help registers2)
+  Continued in 'help registers2'.
 & REGISTERS2
   As you can see from the above example, the command trigger had two
   wildcards separated by a "+" sign. When the user types in the
@@ -1464,7 +1512,7 @@
   room) that you control or that is set LINK_OK can be used to wait
   actions on.
 
-(continued in help semaphores2)
+  Continued in 'help semaphores2'.
 & SEMAPHORES2
 
   An object is notified using the "@notify" command.  When you type
@@ -1487,7 +1535,7 @@
   order, or to make sure that two players can't use the same object at
   the same time.
 
-(continued in help semaphores3)
+  Continued in 'help semaphores3'.
 & SEMAPHORES3
 
   It's important to remember that the actions will be carried out NOT
@@ -1505,7 +1553,7 @@
   Wizard waits 30 seconds.
  
 See also: @wait, @drain, @notify
-(continued in help semaphores4)
+  Continued in 'help semaphores4'.
 & SEMAPHORES4
   Semaphores can be used to enforce mutual exclusion - to prevent
   the same object from being used simultaneously by two players.
@@ -1529,7 +1577,7 @@
   the end of the REPORT attribute. Note the STARTUP attribute -
   because semaphores are cleared when the MUSH starts up, you must
   insure that the object gets @notify'd once when it starts up.
-(Continued in help semaphores5)
+  Continued in 'help semaphores5'.
 & SEMAPHORES5
  Normally, semaphores use the SEMAPHORE attribute. However, other
  attributes can be used, as long as they follow a few simple rules: If
@@ -1544,7 +1592,7 @@
  would normally just use <object> in those commands. This means you
  can't have a un-timed semaphore on an attribute with a numeric name.
 
-(Continued in help semaphores6)
+  Continued in 'help semaphores6'.
 & SEMAPHORES6
  An example:
  
@@ -1633,7 +1681,7 @@
   letter after the % will capitalize the first letter of the resulting
   substitution.
 
-(continued in help SUBSTITUTIONS2)
+  Continued in 'help substitutions2'.
 & SUBSTITUTIONS2
 & %2
   If the ENACTOR's gender is set, you can use these substitutions to get the
@@ -1650,7 +1698,7 @@
      %wa-%wz, %xa-%xz = as above, for WA-WZ and XA-XZ
   These are the equivilent of get(me/<attribute>).
 
-(continued in help substitutions3)
+  Continued in 'help substitutions3'.
 & SUBSTITUTIONS3
 & %3
   Other substitutions:
@@ -1667,7 +1715,7 @@
     %iN = equivilent of itext(N), the list element for iter()/@dolist.
     %$N = equivilent of stext(N), the <string> in switch()/@switch.
  
-(continued in help substitutions4)
+  Continued in 'help substitutions4'.
 & SUBSTITUTIONS4
 & %4
   Example: 
@@ -1804,7 +1852,7 @@
   are often named with the "+" prefix, and local $-commands often have
   a "+" or "." prefix.
   
-(continued in help user-defined2)
+  Continued in 'help user-defined2'.
 & $-COMMANDS2
 & MACROS2
 & USER-DEFINED2
@@ -1852,7 +1900,6 @@
 & VERBS2
 & NONAME
 & NOSPACE
-
   Normally, the enactor's name and a space are prepended to the 'overb' and 
   'oxverb' attributes automatically. The NOSPACE attribute flag prevents a
   space being placed between the name and attribute value, and the NONAME
@@ -1863,7 +1910,7 @@
     > use Foo
     Sketch has used Foo!
     
-    > @ouse Foo=;'s used Foo!
+    > @ouse Foo='s used Foo!
     > @set Foo/ouse=nospace
     > use Foo
     Sketch's used Foo!
@@ -1898,7 +1945,7 @@
   my-desc               Warn on missing player description
   lock-checks           Warn on @lock problems
 
-(continued in help warnings list2)
+  Continued in 'help warnings list2'.
 & WARNINGS LIST2
   These warnings combine the functionality of multiple warnings above:
 
@@ -1921,17 +1968,17 @@
   command. You could use a wildcard in the command trigger to match
   substrings of it:
 
-  &TOO_LONG_CMD object=$supercali*:@emit whee
-  super
-  > (nothing happens)
-  supercali
-  > whee
-  supercalifra
-  > whee
-  supercalifragalisticexpealidocious
-  > whee
-  supercalifoobert
-  > whee
+  > &TOO_LONG_CMD object=$supercali*:@emit whee
+  > super
+  (nothing happens)
+  > supercali
+  whee
+  > supercalifra
+  whee
+  > supercalifragalisticexpealidocious
+  whee
+  > supercalifoobert
+  whee
 
   A backslash (\) can be used to escape * and ? if you want to match 
   a literal asterisk or question mark.
@@ -2035,12 +2082,13 @@
   do matching in different ways, but most will allow you to specify an
   object as:
     * its dbref (#7) or objid (#7:123456789)
-    * its full name (Box of chocolates)
-    * part of any word in its name, if nothing else shares that part (Box)
     * the string "me" (yourself)
     * the string "here" (the room you're in)
-  Usually, you can also qualify an object with an adjective to help
-  the MUSH determine which object you mean.  Adjectives include:
+    * a '*' followed by a playername (*javelin)
+    * its full name (Box of chocolates)
+    * part of any word in its name, if nothing else shares that part (Box)
+  You can usually qualify an object with an adjective (English matching)
+  to help the MUSH determine which object you mean Adjectives include:
     * my <obj> - an object you're carrying
     * this <obj> - an object in your location (also: this here <obj>)
     * toward <exit> - an exit in your location
@@ -2048,7 +2096,7 @@
       Objects are ordered in the order in which they're listed in your
       inventory, room contents, and exit list (in that order). If there
       aren't enough objects, this will fail.
-   You may combine some adjectives (my 1st box, this here 2nd box).
+  You can use an adjective with an ordinal (my 1st <obj>, this 2nd <obj>, etc)
 & &HELP
 This is the AHELP index.
 & RESTRICT
@@ -2097,6 +2145,8 @@
    localize   %q-registers are saved/restored when evaluating, as if
               the @function were wrapped in localize().
    userfn     Function can only be called from within an @function.
+   nosidefx   Don't allow side-effects for this function. See also the
+              function_side_effects @config option.
 
   Commands only:
    noplayer   Cannot be used by players.
Index: game/txt/hlp/penncmd.hlp
===================================================================
--- game/txt/hlp/penncmd.hlp	(.../184p2)	(revision 828)
+++ game/txt/hlp/penncmd.hlp	(.../184p3)	(revision 828)
@@ -187,6 +187,8 @@
   is @destroyed, not when the object is actually purged from the database,
   it's possible for <object> to be @undestroyed after the adestroy has run.
   
+  Please note that there are no destroy or odestroy attributes.
+  
 See also: @destroy, @undestroy
 & @adisconnect
   @adisconnect <object>[=<action list>]
@@ -369,8 +371,8 @@
   If the 'page_aliases' @config option is on, the first alias in the list is 
   shown along with the player's name when they page others.
   
-  Exits also support including the aliases directly in their name, but doing
-  so in new construction is depreciated and @alias should be used instead.
+  Exit aliases used to be a part of their name, though all newly created
+  exits use @alias instead.
  
   For other types of object, @alias has no special meaning.
 
@@ -471,9 +473,9 @@
 & @atrchown
   @atrchown <object>/<attribute>=<new owner>
   
-  These command changes the ownership of the attribute <attribute> on
-  <object> to <new owner>. You can only @atrchown attributes which you can
-  set. Wizards can @atrchown to any player, while mortals can only @atrchown
+  This command changes the ownership of the attribute <attribute> on <object>
+  to <new owner>. You can only @atrchown attributes which you can set. 
+  Wizards can @atrchown to any player, while mortals can only @atrchown
   attributes to themselves. Only players can own attributes; if <new owner>
   is not a player, <new owner>'s owner is used instead.
 
@@ -492,7 +494,7 @@
   alter the attribute for other reasons, such as not controlling <object>).
   You must be able to set an attribute in order to lock it.
 
-See also: @atrchown, ATTRIBUTES, NON-STANDARD ATTRIBUTES
+See also: atrlock(), @atrchown, ATTRIBUTES, NON-STANDARD ATTRIBUTES
 & @asuccess
 & @success
 & @osuccess
@@ -521,8 +523,8 @@
 & @attribute
   @attribute <attrib>
 
-  The @attribute command displays and modifies the MUSH's standard
-  attributes (see "@list/attribs" for a list of them).
+  The @attribute command displays and modifies the MUSH's standard attributes
+  (see "@list/attribs" for a list of them).
   
   *** Unlike TinyMUSH, changes to the PennMUSH attribute table are not saved 
   *** across shutdowns. Use these commands from God's @startup to ensure they
@@ -559,7 +561,7 @@
 
   @attribute/limit lets you restrict all _new_ values for an attribute to
   those that match a regexp pattern. Case insensitive. (Use (?-i) to make
-  your regexp case-sensitive)
+  your regexp case-sensitive.)
 
   @attribute/enum lets you restrict all _new_ values for an attribute to
   match an item in a list. It will also perform partial matching on the
@@ -1058,6 +1060,7 @@
   difference is refunded.
   
   This attribute is evaluated, with the amount being given passed as %0.
+  If the attribute returns a number less than 0, the money will be refused.
   Non-players must have this attribute set in order to receive pennies.
   Players who don't have a COST always accept the amount of pennies given.
 
@@ -1066,8 +1069,8 @@
     > @apay Exit Machine=@open %n-exit 
     > @pay Exit Machine=Your exit has been created.  
  
-    give Exit Machine=10
-    > Your exit has been created.
+    > give Exit Machine=10
+    Your exit has been created.
     (The exit will also have been opened by the machine.)
 
     > @cost charity=%0
@@ -1189,12 +1192,13 @@
   The /tf works the same as if you'd typed:
     @decompile/db <obj>[/<attrs>]=[default(me/TFPREFIX, FugueEdit >%b)]
     
-  If you have a TFPREFIX attribute set, the (unevaluated) contents of that
-  attribute is used as the prefix. Otherwise, the string "FugueEdit > " is
-  used. It's useful for automatically copying @decompile output into your
-  client to alter. It is highly recommended  that you set a TFPREFIX
-  attribute, to prevent others from maliciously placing code in your client's
-  command line.
+  with the exception that @decompile/tf does not include commands for setting
+  attribute flags. If you have a TFPREFIX attribute set, the (unevaluated) 
+  contents of that attribute is used as the prefix. Otherwise, the string 
+  "FugueEdit > " is used. It's useful for automatically copying @decompile 
+  output into your client to alter. It is highly recommended  that you set a
+  TFPREFIX attribute, to prevent others from maliciously placing code in your
+  client's command line.
 
   To set up @decompile/tf:
   
@@ -1284,7 +1288,7 @@
   
 See also: @destroy, GOING, @startup
 & @dig
-  @dig[/teleport] <room name>[=<exit to>[, <exit from>]]
+  @dig[/teleport] <room name>[=<exit to>[, <exit from>[, <dbref>]]]
   
   This command creates a new room named <room name>. Creating a room costs
   some pennies (see '@config room_cost' for exactly how many). If the
@@ -1297,6 +1301,9 @@
   to your current location. Opening exists also costs pennies; see 
   '@config exit_cost'. The exit names may contain multiple aliases, separated 
   with semicolons, as per 'help @name'.
+
+  Wizards can also specify the <dbref> of a garbage object to use when
+  creating the room. Otherwise, the room is given the next available dbref.
   
   See 'help @dig2' for examples.
 & @dig2
@@ -1407,7 +1414,7 @@
   "leave <object>" to enter/leave the object.
   
   These attributes only have meaning for players and things (as rooms/exits
-  cannot be "enter"ed) - the aliases for exits are part of their @name.
+  cannot be "enter"ed) - the aliases for exits are stored in @alias.
   
   Example:
     > @ealias Chair=Sit down;sit
@@ -1472,7 +1479,7 @@
   The /noeval switch prevents the MUSH from evaluating <message>.
   The /spoof switch causes nospoof notifications to show the enactor's
     dbref instead of the executor's dbref, and requires control over
-    the enactor or the Can_nspemit power.
+    the enactor or the Can_spoof power.
 
   @emit can be abbreviated "\"
 
@@ -1667,18 +1674,20 @@
 
 See also: DEBUG, @forwardlist, @lock
 & @force
-  @force[/noeval] <object>=<action list>
+  @force[/noeval][/inplace] <object>=<action list>
 
   This command forces <object> to queue the given action list, as if the
   object had entered the action list itself. You must control <object> to
   @force it. @force is useful for manipulating puppets. 
 
+  If /inplace is given, <object> will run <action list> _now_, instead of
+  being queued for execution later.
+
   @force can be abbreviated as
-    <dbref#> <action list>
+    <dbref> <action list>
 
   Continued in 'help @force2'.
 & @force2
-
   Normally, the action list is evaluated twice - once when @force is run, and 
   again when <object> runs the action list. If the /noeval switch is given, 
   <action list> is not evaluated until it is run by <object>.
@@ -1694,6 +1703,25 @@
     > #103 page Cyclonus=Whee
     Lackey pages: Whee
 
+  Continued in 'help @force3'.
+& @force3
+  Normally, @force creates a new queue entry. @force/inplace does not.
+
+  Examples:
+    > @create Lackey
+    Created: Object #103 
+    > &order me=$order *:say Lackey, %0 ; @force Lackey=%0 ; say Done?
+    > order pose salutes!
+    You say, "Lackey, pose salutes!"
+    You say, "Done?"
+    Lackey salutes!
+
+    > &order me=$order *:say Lackey, %0 ; @force/inplace Lackey=%0 ; say Done?
+    > order pose salutes!
+    You say, "Lackey, pose salutes!"
+    Lackey salutes!
+    You say, "Done?"
+
 See also: PUPPET, DBREF, objeval()
 & @flag
   @flag <flag name>
@@ -1957,8 +1985,11 @@
   @power to affect your own connections; only Wizards can affect other
   players' connections.
   
-  The /on and /yes switches (which are the default, if no <switch> is given)
-  hide a connection, while /off and /no unhide the connection.
+  The /on and /yes switches hide connections, while /off and /no unhide
+  connections. If no switch is given, the command acts as a toggle: for a
+  single descriptor, the hide status is reversed. For a player, if all his
+  connections are hidden, they will be unhidden. If any are unhidden, they
+  will all be hidden.
 
 See also: hidden(), WHO, lwho(), lports(), ports()
 & @idescribe
@@ -2000,6 +2031,8 @@
                 $commands that might match). If the match fails, normal
                 built-in command processing continues. Note that all locks
                 and flags on the object (HALT, etc.) still apply.
+  @hook/override/inplace: Same as @hook/override, but the resulting matches
+                are run immediately - not queued for later execution!
   @hook/before: The attribute is evaluated before the built-in command is run.
   @hook/after: The attribute is evaluated after the built-in command is run.
 
@@ -2034,6 +2067,28 @@
   > @set me=OOC
   > "test
   <OOC> Robert says, "test"
+
+  See 'help @hook3' for /inplace examples.
+& @hook3
+  > &dance me=$dance:pose sticks his right foot in ; say Do the hokey pokey
+                     ; pose sticks his right foot out
+  > dance
+  Walker sticks his right foot in
+  You say, "Do the hokey pokey"
+  Walker sticks his right foot out
+
+  > &cmd.say #3=$say *:@remit %l=%n declares, "%0"
+  > @hook/override say=#3,cmd.say
+  > dance
+  Walker sticks his right foot in
+  Walker sticks his right foot out
+  Walker declares, "Do the hokey pokey"
+
+  > @hook/override/inplace say=#3,cmd.say
+  > dance
+  Walker sticks his right foot in
+  Walker declares, "Do the hokey pokey"
+  Walker sticks his right foot out
 & HUH_COMMAND
 
   This internal command is run whenever someone attempts to run a command
@@ -2055,7 +2110,7 @@
       @pemit/sil %#=Huh? %b(Type "help" for help.) ;
       @break mod(get(%#/typos),10) ; 
       @wall %n wins %p [ordinal(div(get(%#/typos),10))] typo trophy!
-    > asfdsf (10 times)
+    > asfdsf  (10 times)
     Huh?  (Type "help" for help.)  (10 times)
     Announcement: Room Zero shouts, "Dunce wins his first typo trophy!"
 
@@ -2069,7 +2124,7 @@
   are in a meeting and cannot quickly return pages.
 
   Example: 
-    > @idle me=switch(idlesecs(me),>120,I'm idle. Use @mail)
+    > @idle me=switch(idle(me),>120,I'm idle. Use @mail)
 
   Players paging me will only see the "I'm idle" message if I've been
   idle for over 2 minutes (120 seconds).
@@ -2125,11 +2180,13 @@
   you force the bird to @lemit "Cheep", everyone in room #10 will hear
   "Cheep". This command is the same as "@emit/room". 
 
+  With the /silent switch, no confirmation message is shown. With /noisy, it
+  is. If neither is given, the silent_pemit option determines if it is shown.
   The /silent switch suppresses the normal confirmation message.
   The /noeval switch prevents <message> from being evaluated.
   The /spoof switch causes nospoof notifications to show the enactor's
     dbref instead of the executor's dbref, and requires control over
-    the enactor or the Can_nspemit power.
+    the enactor or the Can_spoof power.
 & @list
   @list/<switch>
   @list[/lowercase] <switch>
@@ -2163,7 +2220,7 @@
 
 See also: @list
 & @link
-  @link[/preserve] <object>=<dbref | here | home | variable>
+  @link[/preserve] <object>=[<dbref> | here | home | variable]
 
   Links <object> to either a room or a thing. If a thing or player is
   linked, that sets the object's HOME. If a room is linked, that sets 
@@ -2175,7 +2232,7 @@
   control the room, OR the room must be set LINK_OK. If the exit is
   currently unlinked, and you pass its @lock/link, you may link it even
   if you do not own it. In this case, the exit will be @chowned to you
-  (and set HALT).  Linking an exit may have a cost (usually 1 penny.)
+  (and set HALT). Linking an exit may have a cost (usually 1 penny.)
   The Wizard-only /preserve switch can be used to link without @chowning
   and HALTing the exit.
 
@@ -2224,7 +2281,7 @@
   > @listen Recorder=@emit *
   > @ahear Recorder=:records %0
   > @emit Whee!
-  > Whee!
+  Whee!
     In this example, the Recorder's listen-pattern is NOT matched, because
     it doesn't hear the '@emit Whee!', it only hears the 'Whee!' part, which
     doesn't match.
@@ -2396,6 +2453,19 @@
   you should probably use a bit lock instead.
 
 See also: @lock-bit
+& @lock-name
+NAME LOCKS
+  You can test for objects matching a given name by using the below format
+
+    @lock <object>=name^<pattern>
+
+  It is similar to performing strmatch(%n,<pattern>), though will also match
+  for a player/exit with <pattern> as one of its @aliases.
+
+  For example, to lock "Bob's Tools" to only people with a name beginning
+  with Bob:
+    @lock/use Bob's Tools=name^bob*
+
 & @lock-bit
 & @lock-flag
 & @lock-type
@@ -2476,6 +2546,7 @@
 
   Simple     - Always true, always false, or locking to an object.
   Objid      - Check if the object trying to pass the lock matches an objid.
+  Name       - Check the name of the object attempting to pass the lock.
   Owner      - Lock to objects owned by the owner of an object.
   Carry      - Lock to someone carrying an object such as a key.
   Indirect   - Use the result of a lock on another object.
@@ -2521,6 +2592,7 @@
   @lock/drop            Who can drop this object or in this room
   @lock/give            Who can give this object
   @lock/from            Who can give things to this object
+  @lock/pay             Who can give pennies to/buy from this object
   @lock/receive         What things can be given to this object
   @lock/follow          Who can follow this object
   @lock/examine         Who can examine this object if it's VISUAL
@@ -2550,12 +2622,17 @@
 See also: @lock, lockflags(), llockflags(), lset()
 & @log
   @log[/<switch>] <message>
-
+  @log/recall/<switch> [<number>]
+ 
   This wizard-only command puts <message> in a log file, tagged with
   the time and object executing the command.  The available switches
   are /check, /cmd, /conn, /err, /trace, and /wiz, specifying which
   file to log to.  /cmd is default.
 
+  Adding the /recall switch will display the last <number> lines
+  written to that log file, or the entire log buffer (Which is the
+  last 1 kilobyte or so of data written to the log) if omitted.
+
 See also: @logwipe
 & @logwipe
   @logwipe/<switch> <password>
@@ -2627,27 +2704,32 @@
   /list   : list the MOTDs (like @listmotd, can be used by anyone)
 & @name
   @name <object>=<new name>
+  @name <player|exit>=<new name>[;<alias1>[;<aliasN>]]
 
   Changes the name of <object> to <new name>.
 
   Players can change their name to anything valid which is not currently in
   use by another player, as a name or alias. (They can change their name to
   something from their own @alias.)
+  
+  You can change the alias for a player or exit while renaming it, by giving
+  the alias(es) after the new name, each separated by a semicolon. If the
+  name is followed by a semicolon with no aliases, the existing alias will
+  be cleared instead.
 
-  An exit can have many names, each separated by a semicolon. In new
-  construction, the aliases should be in the @alias attribute, but
-  they are also supported in the name itself. The exit can be referred
-  to by any of these names in all commands. For example:
-
-    (New-style)
-    > @name exit=East <e>
-    > @alias exit=east;e
-    (Old-style)
-    > @name exit=East <e>;east;e
-    
   When <object>'s name is changed, its ONAME and ANAME verb attributes will
   be triggered. See 'help @oname' for details.
   
+  Examples:
+    > @name here=My Room
+    Name set.
+    > @name me=Mike;Michael;m
+    Alias set.
+    Name set.
+    > @name me=Obi Wan;
+    Alias removed;
+    Name set.
+  
 See also: @alias, @oname, name(), fullname()
 & @ONAME
 & @ANAME
@@ -2707,13 +2789,13 @@
   @nslemit[/<switch>] <message>
   @nspemit[/switches] <object>=<message>
   @nsprompt[/switches] <object>=<message>
-  @nsremit[/switches] <object> = <message>.
-  @nsoemit[/<switch>] [<room>/]<object> [<object>...] = <message>
-  @nszemit <zone> = <message>
+  @nsremit[/switches] <object>=<message>.
+  @nsoemit[/<switch>] [<room>/]<object> [<object>...]=<message>
+  @nszemit <zone>=<message>
 
   These commands work like @emit, @lemit, @pemit, @prompt, @remit, @oemit, 
   and @zemit, respectively, but will not include nospoof information if used
-  by Wizards or someone with the Can_Nspemit @power. They are meant to be
+  by Wizards or someone with the Can_spoof @power. They are meant to be
   used by commands in the master room where the nospoof information is just
   useless noise. They take all switches of their respective commands.
 
@@ -2725,17 +2807,22 @@
  
   This command shows <message> to everyone in the location of <object>
   EXCEPT <object>. A list of objects can be given, in which case the message
-  is shown in the locations of each, to everyone but those objects.
+  is shown in the locations of each, to everyone but those objects. If 
+  <object> contains a space, it should be enclosed in double-quotes.
   
   If <room> is specified (usually as a dbref), this command shows <message> 
   to everyone in <room> except for the given <object>s. In this case, each
-  <object> is matched relative to <room>.
+  <object> is matched relative to <room>. If no matching <object>s are found
+  in <room>, this is the equivilent of @remit <room>=<message>
   
   The /noeval switch prevents the MUSH from evaluating <message>.
   The /spoof switch causes nospoof notifications to show the enactor's
     dbref instead of the executor's dbref, and requires control over
-    the enactor or the Can_nspemit power.
-    
+    the enactor or the Can_spoof power.
+
+  See 'help @oemit2' for examples.
+See also: @emit, @pemit, @nsoemit, oemit(), nsoemit(), NOSPOOF, SPOOFING
+& @oemit2
   Examples:
     Show a message in the locations of players Bob and Fred, to everyone
     except those two players:
@@ -2743,8 +2830,10 @@
     
     Show a message in #50 to everyone except the object 'Spy'.
     > @oemit #50/Spy=Sssh!
- 
-See also: @emit, @pemit, @nsoemit, oemit(), nsoemit(), NOSPOOF, SPOOFING
+    
+    Show a message to everyone in your current location, except the 2nd
+    object called 'foo'.
+    > @oemit %L/"2nd foo"=bar
 & @open
   @open <exit name>[=<destination>[, <return exit name>[, <source room>]]]
 
@@ -2908,7 +2997,7 @@
     /noeval    -- <message> will not be evaluated for substitutions 
     /spoof     -- the enactor's dbref will be used for nospoof notifications
                   instead of the executor's dbref. Requires control
-                  over enactor or Can_nspemit power. 
+                  over enactor or Can_spoof power. 
 
   You cannot @pemit to objects set HAVEN, or objects whose @lock/page you do
   not pass, unless you are set WIZARD or have the pemit_all @power.
@@ -3087,7 +3176,7 @@
    space-separated list of targets.
   The /spoof switch causes nospoof notifications to show the enactor's
    dbref instead of the executor's dbref, and requires control over
-   the enactor or the Can_nspemit power.
+   the enactor or the Can_spoof power.
 
 See also: @emit, @pemit, @oemit, SPOOFING, NOSPOOF, CONTROL.
 & @restart
@@ -3289,31 +3378,33 @@
 & @sitelock
   @sitelock
   @sitelock/name <name>
-  @sitelock <host-pattern>=<options>[, <name>]
-  @sitelock[/<ban|register>] <host-pattern>
+  @sitelock[/player] <host-pattern>=<options>[, <name>]
+  @sitelock[/<ban|register>][/player] <host-pattern>
   @sitelock/check <host>
-  @sitelock/remove <string>
-
-  The @sitelock command adds rules to the access.cnf file, controlling
-  a host's level of access to the MUSH, or adds banned player names to
-  the names.cnf file. Only Wizards may use @sitelock.
+  @sitelock/remove[/player] <string>
 
-  @sitelock without arguments lists all sites in access.cnf.
-  Rules are processed in the order listed, and the first matching
-  rule is applied. @sitelock/check tells you which rule will match
-  for a given <host>.
+  The @sitelock command adds rules to the access.cnf file, controlling a 
+  host's level of access to the MUSH, or adds banned player names to the 
+  names.cnf file. Only Wizards may use @sitelock.
+  
+  @sitelock without arguments lists all sites in access.cnf. Rules are 
+  processed in the order listed, and the first matching rule is applied. 
+  @sitelock/check tells you which rule will match for a given <host>.
 
-  @sitelock/name adds a name to the list of banned player names.
-  Use !<name> to remove a name from the list.
+  @sitelock/name adds a name to the list of banned player names.  Use 
+  !<name> to remove a name from the list.
 
   @sitelock <host-pattern>=<options>[, <name>] controls the access options
   for hosts which match <host-pattern>, which may include wildcard
-  characters "*" and "?". See help @sitelock2 for the list of options,
-  and help @sitelock3 for an explanation about the name argument.
+  characters "*" and "?". See help @sitelock2 for the list of options, and
+  help @sitelock3 for an explanation about the name argument.
 
-  For backward compatibility, @sitelock/ban is shorthand for
-  setting options "!connect !create !guest", and @sitelock/register
-  is shorthand for options "!create register".
+  For backward compatibility, @sitelock/ban is shorthand for setting options
+  "!connect !create !guest", and @sitelock/register is shorthand for options
+  "!create register".
+  
+  If the /player switch is given, <host-pattern> is treated as a player name,
+  and sitelock rules are added for that player's LASTIP and LASTSITE, if set.
 
 & @sitelock2
 
@@ -3358,7 +3449,10 @@
   use @newpassword or @sitelock *=!connect,Twink.
 
   @sitelock/remove will delete entries that were added with @sitelock
-  if their host-pattern matches <string> exactly.
+  if their host-pattern matches <string> exactly. If the /player switch is
+  given, <string> is treated as a player name, and entries whose
+  host-patterns match the player's LASTIP or LASTSITE addresses exactly will
+  be deleted.
 
 & @SPEECHMOD
   @speechmod <object>[=<modifier>]
@@ -3387,10 +3481,30 @@
     Test
     
 See also: say, pose, @emit, @chatformat, @pageformat
+& @mapsql
+  @mapsql[/notify][/colnames] <obj>/<attr>=<query>
+
+  This command issues an SQL query if the MUSH supports SQL and
+  can connect to an SQL server. You must be WIZARD or have the
+  Sql_Ok power to use @sql.
+
+  Returned rows are passed to <obj>/<attr>, with Row number passed as %0
+  and the columns passed as %1-%9. Row numbers start at 1.
+
+  The /notify switch causes @mapsql to do an "@notify me" at the end of
+  the list.
+
+  The /colnames switch causes @mapsql to first queue the obj/attr with
+  row number 0 and %0-%9 being the column names.
+
+  Example:
+  > &desctable me=think align(30 20 4 10 10,%0,%1,%2,%3,%4)
+  > @mapsql me/desctable=DESCRIBE table_name
+See also: sql(), sqlescape(), mapsql(), @sql
 & @sql
   @sql <query>
 
-  This command issues and SQL query if the MUSH supports SQL and
+  This command issues an SQL query if the MUSH supports SQL and
   can connect to an SQL server. You must be WIZARD or have the
   Sql_Ok power to use @sql.
 
@@ -3402,7 +3516,7 @@
   Example:
     > @sql SHOW TABLES
 
-See also: sql(), sqlescape(), mapsql()
+See also: sql(), sqlescape(), mapsql(), @mapsql
 & @squota
   @squota <victim> [= [+|-] <amount>]
 
@@ -3457,6 +3571,7 @@
   The "here" and "inventory" flags check only your location or
   inventory, respectively. "exits" only checks for AUDIBLE exits.
 & @switch
+& @select
   @switch[/<switch>] <string>=<expr1>, <action1> [,<exprN>, 
                                  <actionN>]... [,<default>]
   @select <string>=<expr1>, <action1> [,<exprN>, <actionN>]... [,<default>]
@@ -3479,6 +3594,8 @@
   @switch/first runs <action> for the first matching <expr> only. Same as
                 @select, and often the desired behaviour.
   @switch/notify queues "@notify me" after the last <action>. 
+  @switch/inplace runs all actions in place, instead of creating a new queue
+                  entry for them.
   @switch/regexp makes <expr>s case-insensitive regular expressions, not
                  wildcard/glob patterns.
 
@@ -3502,6 +3619,21 @@
                                       say Not Puppet!
     > test
     thing says, "Not Puppet!"
+  Continued in 'help @switch3'
+& @switch3
+  Examples: 
+    > &SWITCH_EX me=$foo *:think before ; @switch %0=1,think one ; think after
+    > foo 1
+    thing before
+    thing after
+    thing one
+
+    > &SWITCH_EX me=$foo *:think before ; @switch/inplace %0=1,think one ;
+                    think after
+    > foo 1
+    thing before
+    thing one
+    thing after
 & @teleport
   @teleport[/silent][/inside] [<object>=]<room>
 
@@ -3861,10 +3993,14 @@
   @listmotd as the Wiz MOTD. A more permanent message can be set by
   the siteadmin by editing the file "wiz.txt".
 & @zemit
-  @zemit <zone>=<message>
+  @zemit[/silent|/noisy] <zone>=<message>
 
-  Emits a message to all rooms in <zone>. You must have control in that
-  zone in order to use this command.
+  Emits a message to all rooms in <zone>. You must have control <zone> in 
+  order to use this command.
+  
+  The /silent switch suppresses the confirmation message, and /noisy causes
+  it to be shown. With neither switch, the silent_pemit @config option
+  determines whether or not the message is shown.
   
 See also: @nszemit, zemit(), zone(), zwho(), ZONES
 & ahelp
@@ -3974,11 +4110,10 @@
   when you don't have a home. You can describe the interior of an
   object differently from its exterior by using @idescribe.
 
-See: @enter, @oenter, @oxenter, @aenter, leave, @lock, @idesc, INTERIORS
-& events
+See: @enter, @efail, @ealias, leave, @lock, @idescribe, INTERIORS
 & rules
-  events [<topic>]
   rules [<topic>]
+  events [<topic>] 
 
   These commands, like news, work the same way as the help command,
   except that the information provided in them is specific to this
@@ -4081,69 +4216,65 @@
   'take' is usually an alias for the 'get' command.
 
 See also: @lock, ENTER_OK, give, drop, @success, inventory
-& @abuy
-  @abuy <object>[=<action list>]
-
-  Sets the actions to be taken after a player buys an item from
-  PRICELIST. The item purchased is passed in as %0, and the amount
-  paid as %1
-
-See also: buy, @buy, @obuy, @pricelist, MONEY, ACTION LISTS
 & @buy
-  @buy <object>[=<message>]
-
-  Sets the message that is shown to anyone who buys something from
-  the object, using the 'buy' command. The item purchased is passed
-  in as %0, and the amount paid as %1.
-
-See also: buy, @abuy, @obuy, @pricelist, MONEY
+& @abuy
 & @obuy
+  @buy <object>[=<message>]
   @obuy <object>[=<message>]
+  @abuy <object>[=<message>]
+  
+  These attributes contain the message shown to a player who successfully
+  buys something from <object> using the "buy" command, the message shown to 
+  others in the room when something is bought from <object> (prefixed with
+  the buyer's name), and the actions to be taken by <object> when something
+  is bought from it, respectively. Each attribute is passed the item being
+  purchased as %0 and the amount paid for it as %1.
 
-  Sets the message that will be show to others whenever someone buys
-  an item from the object's PRICELIST using the 'buy' command. The
-  name of the person giving the money will be automatically inserted
-  at the beginning of the message. The item purchased is passed in as
-  %0, and the amount paid as %1.
+  Example:
+    > @buy Vendor=udefault(me/buy`%0,You buy %0 for %1 [money(%1)]., %0, %1)
+    > @obuy Vendor=hands some money to [name(me)] for [art(%0)] %0.
+    > @abuy Vendor=:goes into the storeroom. ; @wait 2=:returns with %n's %0.
 
-See also: buy, @abuy, @obuy, @pricelist, MONEY
+See also: buy, @pricelist, MONEY, @lock, VERBS, @cost, give
 & @pricelist
   @pricelist <object>=<item1>:<price1>[,<price2>][ <item2>:...]
 
-  The PRICELIST attribute is a space-delimited list of item names and
-  prices that are checked when the 'buy' command is run.
+  The PRICELIST attribute is a space-delimited list of item names and prices
+  that are checked when the 'buy' command is run.
   
-  An item name may have '_'s where the player would use a space in the
-  name.
+  An item name may have '_'s where the player would use a space in the name.
 
-  A price is either a number (20), a range of numbers (10-30), or a
-  minimum number (10+).
+  A price is either a number (20), a range of numbers (10-30), or a minimum 
+  number (10+). An item can also have several different prices, separated by
+  commas.
+  
+  A player must pass <object>'s @lock/pay in order to purchase from it.
 
-  ex:
-    @PRICELIST vendor=mansion:1000+ large_house:100-200 house:20,30,50
+  Example::
+    > @PRICELIST vendor=mansion:1000+ large_house:100-200 house:20,30,50
 
-See also: buy, @abuy, @buy, @obuy, MONEY, @cost
+See also: buy, @buy, MONEY, @cost, give, @lock
 & buy
   buy <item>[ from <vendor>][ for <cost>]
 
   When you try buying an item, PRICELIST attributes on nearby objects
-  (or <vendor> if given) will be checked for matching item:costs. If
-  <cost> is given, the first item that matches that cost will be
-  purchased.  Otherwise, the first matching item that you can afford
-  will be purchased.
+  (or <vendor> if given) will be checked for matching item:costs. If <cost>
+  is given, the first item that matches that cost will be purchased.
+  Otherwise, the first matching item that you can afford will be purchased.
+  You must pass the vendor's @lock/pay in order to purchase items.
 
-  If the pricelist match contains a list of prices, ITEM:30,20,10, the
-  first one you can afford will be the resulting price.
+  If the pricelist match contains a list of prices, ITEM:30,20,10, the first
+  one you can afford will be the resulting price.
 
-  ex:
-  > @PRICELIST vendor=coke:20 pepsi:20
-  > &drink`coke vendor=You enjoy a delicious coke.
-  > &drink`pepsi vendor=It tastes like a funny coke.
-  > @BUY vendor=u(drink`%0)
-  > buy coke
-  You enjoy a delicious coke.
+  Example:
+    > @PRICELIST vendor=coke:20 pepsi:20
+    > &drink`coke vendor=You enjoy a delicious coke.
+    > &drink`pepsi vendor=It tastes like a funny coke.
+    > @BUY vendor=u(drink`%0)
+    > buy coke
+    You enjoy a delicious coke.
 
-See also: @ABUY, @BUY, @PRICELIST, give, @COST
+See also: @BUY, @PRICELIST, give, @COST
 & give
   give[/silent] <recipient>=<number>
   give[/silent] <number> to <recipient>
@@ -4152,11 +4283,13 @@
 
   The first two forms of this command give <number> pennies to <recipient>.
   If <recipient> is a non-player, it must have an @COST, and any pennies
-  given to it will go to its owner. If /silent is given, the message 
-  informing the recipient how many pennies were given is suppressed. Wizards
-  may "give" a negative number of pennies to take from <recipient>. When you
-  give pennies, <recipient>'s PAYMENT/OPAYMENT/APAYMENT attributes are
-  triggered.
+  given to it will go to its owner. The amount given must match <recipient>'s
+  @cost (if set). If /silent is given, the message informing the recipient
+  how many pennies were given is suppressed. Wizards may "give" a negative 
+  number of pennies to take from players. When you give <recipient> pennies,
+  his PAYMENT/OPAYMENT/APAYMENT attributes are triggered. You must pass
+  <recipient>'s @lock/pay, unless you are a Wizard and are either giving a 
+  negative number of pennies, or giving to a player with no @cost.
   
   The last two forms of this command give an <object> from your inventory to
   <recipient>. The recipient must be set ENTER_OK, and you must pass his
@@ -4241,7 +4374,7 @@
   fail to leave, the object's @lfail/@olfail/@alfail messages/actions
   will be triggered.
 
-See also: enter, @leave, @lfail, @lock, INTERIORS 
+See also: enter, @leave, @lfail, @lalias, @lock, INTERIORS 
 & LOGOUT
   LOGOUT
 
@@ -4315,7 +4448,7 @@
     You paged Airwolf with 'see, I don't have to retype the name.'.
     > page "John Lennon" Ringo=Paul's fine!
 
-(continued in help page2)
+  Continued in 'help page2'.
 & page2
   Page will attempt a partial match on the name, checking both for an
   @alias and to see if the name matches someone connected. If the
@@ -4344,11 +4477,11 @@
 & pose
 & semipose
   pose[/noeval] <action>
-  :<action pose>
+  :<action>
 
-  pose[/nospace] <action>
+  pose/nospace[/noeval] <action>
   semipose[/noeval] <action>
-  ;<action pose>
+  ;<action>
  
   The pose and semipose commands allow you to perform actions. Pose shows
   your name, a space, and then <action>; semipose omits the space. They can 
@@ -4444,28 +4577,23 @@
   whisper/noeval <player>=<message>
   whisper/list <players>=<message>
 
-  Whispers the message to the named person, if they are in the same
-  room as you. No one will see the message you whisper.  You can also
-  whisper to things you are carrying, or to things that are carrying
-  you. whisper <player>=:<pose> also works, in a fashion similar to
-  page-pose.
-
-  In a noisy whisper, other players in the room may be told who you
-  whispered to (but not what you whispered): Polgara whispers to
-  Javelin.  The probability that a noisy whisper will be heard aloud
-  is configurable.  In a silent whisper, other players will not know
-  that you whispered.  The default whisper may be configured either
-  silent or noisy (check @config)
+  Whispers the message to the named person, if they are nearby. If <message>
+  is prefixed with a ':' or ';' it will be posed or semiposed, respectively.
+  
+  With the /noisy switch, other players in the room may be informed who you
+  whisper to (but not what you whisper); the probability that a noisy whisper
+  will be heard is set by the 'whisper_loudness' @config option. With the
+  /silent switch, the whisper will not be overheard. (When neither switch is
+  given, the default behaviour is controlled by the 'noisy_whisper' @config
+  option.)
 
-(continued in help whisper2)
-& whisper2
-  The /noeval switch prevents any evaluation of the message, and is
-  handy when you want to say things that use special characters like %
-  or []'s.
+  <message> will not be evaluated if the /noeval switch is given.
+  
+  The /list switch lets you whisper to multiple people at once. In this case,
+  <players> is a space-separated list of names, and names with spaces should
+  be enclosed in double-quotes, as per page/list.
 
-  The /list switch lets you whisper to many people at once. Multiple
-  persons should be space-separated, and names with spaces should be
-  enclosed in double-quotes.
+See also: page, pose, @pemit
 & WHO
 & DOING
   WHO [<prefix>]
@@ -4499,7 +4627,7 @@
   
     > &HOOK.WHO <object>=not(comp(left(%c,3),WHO))
     > @hook/ignore WHO=<object>,HOOK.WHO
-	  
+
   @hooks are not maintained across reboots, and should be placed into an
   @startup on a low-dbref object.
   
Index: game/txt/hlp/pennvOLD.hlp
===================================================================
--- game/txt/hlp/pennvOLD.hlp	(.../184p2)	(revision 828)
+++ game/txt/hlp/pennvOLD.hlp	(.../184p3)	(revision 828)
@@ -4417,7 +4417,7 @@
 For information on a specific patchlevel of one of the versions listed,
 type 'help <version>p<patchlevel>'. For example, 'help 1.7.2p3'
 
-1.8.4: 0, 1, 2
+1.8.4: 0, 1, 2, 3
 1.8.3: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
 1.8.2: 0, 1, 2, 3, 4, 5, 6, 7, 8
 1.8.1: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
Index: game/txt/hlp/pennevents.hlp
===================================================================
--- game/txt/hlp/pennevents.hlp	(.../184p2)	(revision 0)
+++ game/txt/hlp/pennevents.hlp	(.../184p3)	(revision 828)
@@ -0,0 +1,214 @@
+& EVENTS
+& EVENT
+  PennMUSH Events are hardcoded events that may or may not be caused by
+  players. The Event system lets administrators designate an object as
+  an event handler (using the "event_handler" config option). The
+  event_handler object will then have attributes triggered, with arguments,
+  on specified events.
+
+  To use the PennMUSH Event system:
+
+  > @create Event Handler
+  > @config/set event_handler=[num(Event Handler)]
+  > &<event name> Event Handler=<action list>
+
+  You will very likely want to set the event_handler option in your mush.cnf
+  file to ensure it survives over dumps and is actively receiving events
+  even during startup.
+
+  The enactor of an event is either:
+    1) The executor that caused it, or
+    2) #-1 for system events without an executor.
+
+  For a list of events and their arguments, see "help event list".
+
+  For some examples of using events, see "help event examples".
+& EVENT EXAMPLES
+  Suppose you want random dbsave messages:
+  > &DUMP`COMPLETE Event Handler=
+        @config/set dump_complete=SAVE: [v(randword(lattr(me/dumpmsg`*)))]
+  > &DUMPMSG`NOTHING Event=The Database has been saved, nothing to see here.
+  > &DUMPMSG`GRETZKY Event=The Database saves, but Gretzky scores!
+  > &DUMPMSG`GEICO Event=The Database saved 15% by switching to Geico!
+  > @dump
+  SAVE: The Database has been saved, nothing to see here.
+  > @dump
+  SAVE: The Database saved 15% by switching to Geico!
+
+  Or admin want to be notified when a player connect attempt fails.
+  > @set Event=wizard
+  > &SOCKET`LOGINFAIL Event=@wizwall/emit On descriptor '%0' from IP '%1'
+          a failed connect attempt to '%4': '%3'
+  (Later, a player attempts to log in as #1)
+  Broadcast: [Event Handler]: On descriptor 3, from IP '127.0.0.1',
+    a failed connect attempt to '#1': 'invalid password'
+
+  For more examples, see "help event examples2".
+& EVENT EXAMPLES2
+  Suppose you want @pcreated players to be powered builder, set shared and
+  zonelocked to roys, but players created at the connect screen to not be.
+  > @set Event=wizard
+  > &PLAYER`CREATE Event=@assert %# ;
+      @pemit %#=Auto-Setting [name(%0)] Builder and shared ;
+      @power %0=builder ; @lock/zone %0=FLAG^ROYALTY ; @set %0=shared
+  > @pcreate Grid-BC
+  Auto-Setting Grid-BC Builder and Shared
+
+  And for our last example: Suppose anytime somebody uses 'kill' or 'slay',
+  you want to teleport them to a jail.
+  > @dig Kill-jail
+  > @desc Kill-Jail=You came here because you killed someone!
+  > @set Event=Wizard
+  > &object`kill event=@pemit %#=MURDERER! ; @tel %#=<dbref of Kill-Jail>
+  > kill Mercutio
+  You killed Mercutio!
+  MURDERER!
+  Jail (#123R)
+  You came here because you killed someone!
+
+  The Event Handler object, since it's handling so many events, may become
+  cluttered with attributes. We recommend using @trigger and @include to
+  separate events to multiple objects.
+& EVENT LIST
+  Event names are of the format <type>`<event>. The 'type' is used simply to
+  group similar events together for help.
+
+  Event syntax in the help is of the form:
+  <eventgroup>`<eventname> (What is passed as %0, %1, ... %9)
+
+  The following event types and events have been added to PennMUSH. To see
+  the help for them, type "help event <type>".
+
+  dump: dump`5min, dump`1min, dump`complete, dump`error
+  db: db`dbck, db`purge, db`warnings
+  object: object`create, object`destroy, object`move, object`rename,
+          object`kill
+  sql: sql`connect, sql`connectfail, sql`disconnect
+  signal: signal`usr1, signal`usr2
+  player: player`create, player`connect, player`disconnect
+          player`inactivity
+  socket: socket`connect, socket`disconnect, socket`loginfail,
+          socket`createfail
+& EVENT DB
+  db`dbck: Run after the regular database consistency check.
+  db`purge: Run after the regular purging of destroyed objects.
+  db`wcheck: Run after the regular @warnings check.
+& EVENT DUMP
+  dump`5min (Original message, isforking)
+      Database save will occur in 5 minutes.
+  dump`1min (Original message, isforking)
+      Database save will occur in 1 minute.
+  dump`complete (Original message, wasforking)
+      Database save has completed.
+  dump`error (Error message, wasforking, exit_status)
+      Database save failed! You might want this to alert any admin on.
+      exit_status has different meanings in forking and non-forking
+      dumps.
+      In forking: exit_status is a string, either "SIGNAL <int>" or
+        "EXIT <int>". SIGNAL <int> refers to the mush process receiving error
+        message via signal while EXIT <int> refers to mush process exiting
+        abnormally.
+      In nonforking: exit_status is "PERROR <string>" - string being the
+        error message returned by strerror(errno).
+      If you are seeing errors on dbsave, we recommend setting forking_dump
+      to 0, as nonforking dumps have more verbose error messages.
+
+  These run in addition to any messages that may be sent. If you want to
+  replace the messages, config (via @config or the .cnf file) the dump
+  messages to be empty.
+& EVENT OBJECT
+  object`create  (new objid, cloned-from)
+      Triggered on the creation of any object except player.
+      If it was created using @clone, then cloned-from will be a objid.
+      Otherwise cloned-from will be null.
+
+  object`destroy (objid, origname, type, owner, parent, zone)
+      Triggered _after_ the object is destroyed. Passed arguments are former
+      objid, name, type, owner, etc. Enactor is always #-1, so use former
+      owner.
+
+  object`move (objid, newloc, origloc, issilent, cause)
+      Triggered after the object is moved, @tel'd, or otherwise sent to a
+      new location. If issilent is 1, then the object was moved using
+      @tel/silent.
+
+  object`kill    (objid of object killed, cost, wasslay)
+      Triggered when an object has been killed with 'kill' or 'slay' command.
+      Note that if this is set, it overrides the default behavior of
+      @halting the object, @teling it home and giving it an amount of
+      money that was paid to kill them. So if you want to mimic
+      old behavior, you need:
+      &OBJECT`KILL event handler=@halt %0 ; @tel %0=home ;
+              give %0=mul(%1,fdiv(kill_bonus,100));
+
+  object`rename  (objid, new name, old name)
+      Triggered when any object is renamed.
+& EVENT SQL
+  sql`connect (platform)
+      Triggered on successful connect to the SQL database.
+      platform is 'mysql', 'psql' or similar.
+
+  sql`connectfail (platform, Error message)
+      Triggered on unsuccessful connect to the SQL database.
+
+  sql`disconnect (platform, Error message)
+      Triggered if SQL disconnects for any reason. Usually not a worry since
+      Penn will auto-reconnect if it can.
+& EVENT SIGNAL
+No arguments are passed to these events.
+
+  signal`usr1: Triggered when the PennMUSH process receives a "kill -USR1"
+
+  signal`usr2: Triggered when the PennMUSH process receives a "kill -USR2"
+
+  If these attributes exist, then penn will NOT perform what it usually does
+  when it receives a signal. In effect, these override Penn's default actions.
+
+  To mimic old behaviour:
+  &SIGNAL`USR1 Event Handler=@pemit/list lwho()=GAME: Reboot w/o disconnect
+      from game account, please wait. ; @shutdown/reboot
+  &SIGNAL`USR2 Event Handler=@dump
+& EVENT PLAYER
+  player`create (objid, name, how, descriptor)
+      Triggered when a player is created. If the player was @pcreated, then
+      %# will be the person who did the @pcreate. If player was created
+      by using 'create' at the connect screen, then %# will be #-1 and
+      descriptor will be non-null.
+      <how> is one of: "pcreate", "create" or "register".
+
+  player`connect (objid, number of connections, descriptor)
+      Similar to @aconnect, but for events, and so you can use descriptor.
+
+  player`disconnect (objid, number of remaining connections, hidden?,
+                     cause of disconnection, ip, descriptor, conn() secs,
+                     idle() secs, recv bytes/sent bytes/command count)
+      Similar to @adisconnect, but for event system, and with more
+      information available.
+  player`inactivity: Triggered when idle players are disconnected. Only run
+      if at least one player gets idlebooted (Or auto-hidden), not at every
+      inactivity check.
+& EVENT SOCKET
+  socket`connect (descriptor, ip)
+      Triggered when a socket first connects to the port. Using this and
+      player`connect could be spammy. This happens when a connecting socket
+      sees the connect screen.
+
+  socket`disconnect (former descriptor, former ip, cause of disconnection,
+                     recv bytes/sent bytes/command count)
+      Triggered when a socket disconnects. Using this and player`disconnect
+      could be spammy.
+
+  socket`loginfail (descriptor, IP, count, reason, playerobjid)
+      Triggered when a connection attempt fails. 'count' is the number of
+      fails in the past 10 minutes. If used in conjuction with the config
+      option connect_fail_limit, then any failures after the limit is reached
+      will NOT trigger player`fail. If the connect is a failed attempt to log
+      into a valid player, playerobjid will be set to that objid. Otherwise it
+      will be set to #-1
+
+  socket`createfail (descriptor, ip, count, reason, name)
+      Triggered when a player create attempt fails. <count> is the # of
+      fails caused by this ip.
+
+    A sitelock rule with deny_silent will not trigger socket`createfail or
+    socket`createfail.
Index: game/txt/hlp/pennflag.hlp
===================================================================
--- game/txt/hlp/pennflag.hlp	(.../184p2)	(revision 828)
+++ game/txt/hlp/pennflag.hlp	(.../184p3)	(revision 828)
@@ -330,7 +330,7 @@
   LOUD objects bypass all speech, channel speech, and interaction @locks.
   This flag can only be set by royalty or wizards.
 
-See also: can_nspemit
+See also: can_spoof (help powers2)
 & INHERIT
 & TRUST
   Flag:  TRUST  (all types)
@@ -434,7 +434,7 @@
   The MISTRUST flag prevents an object from controlling another object via
   Control @locks, Zone @locks on ZMOs or SHARED players, or from controlling
   other objects with the same owner. It also prevents the object from
-  inheriting the no_pay, no_kill and no_quota powers from its owner.
+  inheriting the no_pay, unkillable and no_quota powers from its owner.
   
   This flag can be used when you with a single player to retain ownership
   of objects that other players will control or run arbitrary code on, and
@@ -506,32 +506,27 @@
 
 See also: warnings, @warnings, @wcheck
 & NOSPOOF
-  Flag:  NOSPOOF  (players)
+& PARANOID
+  Flag:  NOSPOOF  (all types)
+  Flag:  PARANOID  (all types)
 
-  If a player is set NOSPOOF, @emits of all sorts will be tagged with the
-  name of the person/object making them. This prevents spoofing and lets
-  you see where such messages originated. Objects belonging to NOSPOOF 
-  players are automatically considered NOSPOOF. 
+  If an object is set NOSPOOF, messages of all kinds will be tagged with the
+  name of the person/object causing them. This prevents spoofing and lets you
+  see where such messages originated. When a NOSPOOF object is also set
+  PARANOID, the dbref of the emitting object is also shown. You will not see
+  nospoof information for your own messages unless you are also set PARANOID.
+
+  When a player is set NOSPOOF or PARANOID, everything it owns is also
+  treated as having the flag.
   
   Note that NOSPOOF output can be spammy and that the output format of
   NOSPOOF can mess up @listen and ^-patterns, giving unexpected results.
-
-  Sample output:
-    > @set me=nospoof
-    Flag set.
-    > @pemit me=Testing
-    [Cyclonus->Cyclonus] Testing
-
-See also: PARANOID, SPOOFING, @emit, @pemit, @remit, @oemit, @nspemit
-& PARANOID
-  Flag:  PARANOID  (players)
-
-  Used in conjunction with the NOSPOOF flag. If a player is set PARANOID 
-  and NOSPOOF, @emits of all sorts are tagged with the name and dbref of
-  the person/object making them and the name of the object's owner, if the 
-  emit was not from a player.
-
-See also: NOSPOOF, SPOOFING, @emit, @pemit, @remit, @oemit, @nspemit
+  
+  For the @pemit command, the Nospoof tag is '[Source->Recipient]', or
+  '[Source(#dbref)->Recipient]' for Paranoid objects. For all other messages,
+  it's '[Source:]' for Nospoof, or '[Source(#dbref)]' for Paranoid objects.
+    
+See also: SPOOFING, @emit, @pemit, @remit, @oemit, @nspemit
 & ON-VACATION
   Flag:  ON-VACATION  (players)
 
Index: game/txt/hlp/pennattr.hlp
===================================================================
--- game/txt/hlp/pennattr.hlp	(.../184p2)	(revision 828)
+++ game/txt/hlp/pennattr.hlp	(.../184p3)	(revision 828)
@@ -37,7 +37,8 @@
   ^-listens. They always only affect the attribute they're set on, regardless
   of attribute trees:
 
-  debug (b)         Show debug output when this attribute is evaluated.
+  debug (b)         Start showing debug output while this attr is evaluated.
+  no_debug (B)      Stop showing debug output when this attr is evaluated
   regexp (R)        Match $-commands and ^-listens using regular expressions.
                     See 'help regexps'.
   case (C)          Match $-commands and ^-listens case sensitively.
@@ -71,7 +72,7 @@
 components (much as filesystems use / or \). For example, the
 following attribute name would be a couple levels down in its tree:
 
-	CHAR`SKILLS`PHYSICAL
+  CHAR`SKILLS`PHYSICAL
 
 Attribute names may not start or end with the backtick, and may not
 contain two backticks in a row.
Index: game/aliascnf.dst
===================================================================
--- game/aliascnf.dst	(.../184p2)	(revision 828)
+++ game/aliascnf.dst	(.../184p3)	(revision 828)
@@ -28,16 +28,16 @@
 # And hook commands, with
 # hook_command <cmd> <hook> [<obj>[/<attr>]]
 # as per @hook/<hook> <cmd>=[<obj>[/<attr>]]. See 'help @hook'.
-# Don't include the '#' in <obj>, just use the number.
-# hook_command say override 123/cmd.say
+# inplace override hooks have use inplace/override as the hook.
+# hook_command say override #123/cmd.say
+# hook_command say override/inplace #123/cmd.say
 
 # You can also add new functions, with
 # add_function <function> <obj>/<attr> [<minargs> [<maxargs>]]
 # as per @function <function>=<obj>, <attr>[, <minargs>[, <maxargs>]]
-# Don't include the '#' in <obj>, just use the number. See 'help @function'
 # If <function> is the name of a built-in function, it will be disabled
 # and replaced with the user function (like @function/delete).
-# add_function foo 123/fun.foo 1 5
+# add_function foo #123/fun.foo 1 5
 
 # You can also alias commands to other names.
 # command_alias EXISTING_COMMAND ALIAS
Index: game/mushcnf.dst
===================================================================
--- game/mushcnf.dst	(.../184p2)	(revision 828)
+++ game/mushcnf.dst	(.../184p3)	(revision 828)
@@ -102,6 +102,10 @@
 # See also: exits_connect_rooms
 base_room 0
 
+# Event handler. This dbref receives all events generated by
+# PennMUSH. See 'help events' for this.
+event_handler -1
+
 # The ancestor room. This dbref serves as an 'ultimate parent' to
 # all rooms that aren't set ORPHAN. Set to -1 to disable.
 ancestor_room -1
@@ -321,6 +325,10 @@
 # This doesn't allocate memory, it just sets a maximum.
 max_channels 200
 
+# What's the maximum length a player's @channel/title can be?
+# This does not include ansi/markup.
+chan_title_len 80
+
 # How many channels can each non-admin create? Set this to some number
 # higher than zero to allow mortals to create channels.
 max_player_chans 0
Index: po/fi_FI.pox
===================================================================
Index: po/sv_SE.pox
===================================================================
--- po/sv_SE.pox	(.../184p2)	(revision 828)
+++ po/sv_SE.pox	(.../184p3)	(revision 828)
@@ -2959,10 +2959,6 @@
 msgid "That is not a valid lock name."
 msgstr "Det r inte ett giltigt ls namn."
 
-#: src/log.c:355
-msgid "That is not a valid log."
-msgstr "Det r inte en giltig logg."
-
 #: src/create.c:54
 msgid "That is not a valid object."
 msgstr "Det r inte ett giltigt objekt."
Index: po/pennmush.pot
===================================================================
--- po/pennmush.pot	(.../184p2)	(revision 828)
+++ po/pennmush.pot	(.../184p3)	(revision 828)
@@ -8,10 +8,11 @@
 msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2010-12-05 02:00-0600\n"
+"POT-Creation-Date: 2011-03-06 02:00-0600\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
+"Language: \n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=CHARSET\n"
 "Content-Transfer-Encoding: 8bit\n"
@@ -115,765 +116,765 @@
 msgid "Unknown access option: %s"
 msgstr ""
 
-#: atr_tab.c:265
+#: atr_tab.c:267
 msgid "Attribute value does not match the /limit regexp."
 msgstr ""
 
-#: atr_tab.c:274 atr_tab.c:310
+#: atr_tab.c:276 atr_tab.c:312
 #, c-format
 msgid "Value for %s needs to be one of: %s"
 msgstr ""
 
-#: atr_tab.c:355
+#: atr_tab.c:357
 msgid "Invalid Regular Expression."
 msgstr ""
 
-#: atr_tab.c:369
+#: atr_tab.c:371
 msgid "Delimiter must be one character."
 msgstr ""
 
-#: atr_tab.c:394
+#: atr_tab.c:396
 msgid "Unknown limit type?"
 msgstr ""
 
-#: atr_tab.c:403 atr_tab.c:474 atr_tab.c:551 atr_tab.c:634
+#: atr_tab.c:405 atr_tab.c:476 atr_tab.c:553 atr_tab.c:636
 msgid "Which attribute do you mean?"
 msgstr ""
 
-#: atr_tab.c:416
+#: atr_tab.c:418
 msgid ""
 "I don't know that attribute. Please use @attribute/access to create it, "
 "first."
 msgstr ""
 
-#: atr_tab.c:422
+#: atr_tab.c:424
 msgid "That attribute's permissions cannot be changed."
 msgstr ""
 
-#: atr_tab.c:435
+#: atr_tab.c:437
 #, c-format
 msgid "%s -- Attribute limit or enum unset."
 msgstr ""
 
-#: atr_tab.c:438
+#: atr_tab.c:440
 #, c-format
 msgid "%s -- Attribute limit or enum already unset."
 msgstr ""
 
-#: atr_tab.c:446
+#: atr_tab.c:448
 #, c-format
 msgid "%s -- Attribute %s set to: %s"
 msgstr ""
 
-#: atr_tab.c:480 flags.c:2092 flags.c:2102 flags.c:2262 flags.c:2273
+#: atr_tab.c:482 flags.c:2097 flags.c:2107 flags.c:2267 flags.c:2278
 msgid "I don't understand those permissions."
 msgstr ""
 
-#: atr_tab.c:490
+#: atr_tab.c:492
 msgid "That attribute's permissions can not be changed."
 msgstr ""
 
-#: atr_tab.c:496 atr_tab.c:593
+#: atr_tab.c:498 atr_tab.c:595
 msgid "Invalid attribute name."
 msgstr ""
 
-#: atr_tab.c:502
+#: atr_tab.c:504
 msgid "Critical memory failure - Alert God!"
 msgstr ""
 
-#: atr_tab.c:533
+#: atr_tab.c:535
 #, c-format
 msgid "%s -- Attribute permissions now: %s"
 msgstr ""
 
-#: atr_tab.c:558 atr_tab.c:607 atr_tab.c:645
+#: atr_tab.c:560 atr_tab.c:609 atr_tab.c:647
 msgid "That attribute isn't in the attribute table"
 msgstr ""
 
-#: atr_tab.c:569
+#: atr_tab.c:571
 #, c-format
 msgid "Removed %s from attribute table."
 msgstr ""
 
-#: atr_tab.c:586
+#: atr_tab.c:588
 msgid "Which attributes do you mean?"
 msgstr ""
 
-#: atr_tab.c:600
+#: atr_tab.c:602
 #, c-format
 msgid "The name %s is already used in the attribute table."
 msgstr ""
 
-#: atr_tab.c:618
+#: atr_tab.c:620
 #, c-format
 msgid "Renamed %s to %s in attribute table."
 msgstr ""
 
-#: atr_tab.c:648
+#: atr_tab.c:650
 msgid "Attribute"
 msgstr ""
 
-#: atr_tab.c:650
+#: atr_tab.c:652
 msgid "Limit"
 msgstr ""
 
-#: atr_tab.c:652
+#: atr_tab.c:654
 msgid "Enum"
 msgstr ""
 
-#: atr_tab.c:655 cmds.c:396 cmds.c:585 game.c:2398
+#: atr_tab.c:657 cmds.c:397 cmds.c:599 game.c:2406
 msgid "Flags"
 msgstr ""
 
-#: atr_tab.c:657
+#: atr_tab.c:659
 msgid "Creator"
 msgstr ""
 
-#: atr_tab.c:672
+#: atr_tab.c:674
 #, c-format
 msgid "Attribs: %s"
 msgstr ""
 
-#: attrib.c:1796 look.c:823 look.c:1581
+#: attrib.c:1826 look.c:823 look.c:1587
 msgid "Garbage is garbage."
 msgstr ""
 
-#: attrib.c:1811 attrib.c:1818 attrib.c:1836
+#: attrib.c:1841 attrib.c:1848 attrib.c:1866 set.c:94
 #, c-format
 msgid "'%s' is not a valid alias."
 msgstr ""
 
-#: attrib.c:1821 attrib.c:1839
+#: attrib.c:1851 attrib.c:1869
 #, c-format
 msgid "'%s' contains too many aliases."
 msgstr ""
 
-#: attrib.c:1824 attrib.c:1842
+#: attrib.c:1854 attrib.c:1872
 msgid "Null aliases are not valid."
 msgstr ""
 
-#: attrib.c:1856
+#: attrib.c:1886
 #, c-format
 msgid "'%s' is not a valid exit name."
 msgstr ""
 
-#: attrib.c:1873
+#: attrib.c:1903
 #, c-format
 msgid "%s should contain only dbrefs."
 msgstr ""
 
-#: attrib.c:1878
+#: attrib.c:1908
 #, c-format
 msgid "Invalid dbref #%d in %s."
 msgstr ""
 
-#: attrib.c:1883
+#: attrib.c:1913
 #, c-format
 msgid "I don't think #%d wants to hear from %s."
 msgstr ""
 
-#: attrib.c:1888
+#: attrib.c:1918
 #, c-format
 msgid "I don't think #%d wants %s's mail."
 msgstr ""
 
-#: attrib.c:1911 set.c:1148
+#: attrib.c:1941 set.c:1177
 #, c-format
 msgid "Attribute %s is SAFE. Set it !SAFE to modify it."
 msgstr ""
 
-#: attrib.c:1918
+#: attrib.c:1948
 #, c-format
 msgid "Unable to remove '%s' because of a protected tree attribute."
 msgstr ""
 
-#: attrib.c:1924
+#: attrib.c:1954
 #, c-format
 msgid ""
 "Unable to set '%s' because of a failure to create a needed parent attribute."
 msgstr ""
 
-#: attrib.c:1929
+#: attrib.c:1959
 msgid "That's not a very good name for an attribute."
 msgstr ""
 
-#: attrib.c:1934
+#: attrib.c:1964
 #, c-format
 msgid "You must set %s first."
 msgstr ""
 
-#: attrib.c:1937
+#: attrib.c:1967
 #, c-format
 msgid "%s is a branch attribute; remove its children first."
 msgstr ""
 
-#: attrib.c:1940
+#: attrib.c:1970
 msgid "That attribute cannot be changed by you."
 msgstr ""
 
-#: attrib.c:1943
+#: attrib.c:1973
 msgid "Too many attributes on that object to add another."
 msgstr ""
 
-#: attrib.c:1946
+#: attrib.c:1976
 msgid "No such attribute to reset."
 msgstr ""
 
-#: attrib.c:1955 command.c:1900
+#: attrib.c:1985 command.c:1907
 msgid "Alias set."
 msgstr ""
 
-#: attrib.c:1957
+#: attrib.c:1987
 msgid "Alias removed."
 msgstr ""
 
-#: attrib.c:1970
+#: attrib.c:2000
 #, c-format
 msgid "%s loses its ears and becomes deaf."
 msgstr ""
 
-#: attrib.c:1974
+#: attrib.c:2004
 #, c-format
 msgid "%s grows ears and can now hear."
 msgstr ""
 
-#: attrib.c:1982
+#: attrib.c:2012
 msgid "Set"
 msgstr ""
 
-#: attrib.c:1982
+#: attrib.c:2012
 msgid "Cleared"
 msgstr ""
 
-#: attrib.c:2012 attrib.c:2019 attrib.c:2085 attrib.c:2092
+#: attrib.c:2042 attrib.c:2049 attrib.c:2115 attrib.c:2122
 msgid "You need to give an object/attribute pair."
 msgstr ""
 
-#: attrib.c:2030 attrib.c:2103 bsd.c:2879 bsd.c:2925 bsd.c:4206 bsd.c:4740
-#: bsd.c:4773 bsd.c:4785 bsd.c:4790 cmds.c:78 cmds.c:83 cmds.c:88 cmds.c:93
-#: cmds.c:98 command.c:1702 command.c:1729 command.c:1821 command.c:1903
-#: command.c:2074 cque.c:1013 cque.c:1115 cque.c:1166 cque.c:1553 cque.c:1666
-#: cque.c:1724 cque.c:1841 create.c:100 create.c:119 create.c:237 create.c:302
-#: create.c:311 create.c:315 create.c:367 create.c:371 create.c:389
-#: create.c:625 destroy.c:234 destroy.c:893 extchat.c:1777 extchat.c:1794
-#: extchat.c:1825 extchat.c:3980 flags.c:1545 flags.c:1550 flags.c:1710
-#: function.c:1038 function.c:1292 function.c:1516 function.c:1661
-#: function.c:1707 function.c:1754 funmisc.c:957 game.c:961 game.c:1533
-#: lock.c:715 lock.c:779 lock.c:975 look.c:1341 look.c:1630 malias.c:764
-#: malias.c:869 match.c:483 move.c:539 move.c:870 move.c:885 predicat.c:1249
-#: rob.c:429 set.c:188 set.c:971 set.c:1054 set.c:1091 set.c:1104 set.c:1189
-#: speech.c:1517 warnings.c:294 warnings.c:515 wiz.c:444 wiz.c:567 wiz.c:578
-#: wiz.c:852 wiz.c:1017 wiz.c:1047
+#: attrib.c:2060 attrib.c:2133 bsd.c:2917 bsd.c:2963 bsd.c:4259 bsd.c:4795
+#: bsd.c:4829 bsd.c:4841 bsd.c:4846 cmds.c:78 cmds.c:83 cmds.c:88 cmds.c:93
+#: cmds.c:98 command.c:1709 command.c:1736 command.c:1828 command.c:1910
+#: command.c:2081 cque.c:1233 cque.c:1335 cque.c:1386 cque.c:1773 cque.c:1886
+#: cque.c:1944 cque.c:2061 create.c:102 create.c:127 create.c:256 create.c:321
+#: create.c:330 create.c:334 create.c:386 create.c:390 create.c:408
+#: create.c:661 destroy.c:234 destroy.c:913 extchat.c:1784 extchat.c:1801
+#: extchat.c:1832 extchat.c:4031 flags.c:1550 flags.c:1555 flags.c:1715
+#: function.c:1041 function.c:1295 function.c:1522 function.c:1667
+#: function.c:1713 function.c:1760 funmisc.c:957 game.c:968 game.c:1541
+#: lock.c:717 lock.c:781 lock.c:977 look.c:1341 look.c:1636 malias.c:764
+#: malias.c:869 match.c:529 move.c:553 move.c:885 move.c:900 predicat.c:1398
+#: rob.c:460 set.c:210 set.c:1001 set.c:1083 set.c:1120 set.c:1133 set.c:1218
+#: speech.c:1566 sql.c:367 warnings.c:294 warnings.c:515 wiz.c:452 wiz.c:575
+#: wiz.c:586 wiz.c:868 wiz.c:1033 wiz.c:1063
 msgid "Permission denied."
 msgstr ""
 
-#: attrib.c:2038
+#: attrib.c:2068
 #, c-format
 msgid "That attribute is %slocked."
 msgstr ""
 
-#: attrib.c:2044
+#: attrib.c:2074
 msgid "You need to be able to set the attribute to change its lock."
 msgstr ""
 
-#: attrib.c:2051
+#: attrib.c:2081
 msgid "Attribute locked."
 msgstr ""
 
-#: attrib.c:2056
+#: attrib.c:2086
 msgid "Attribute unlocked."
 msgstr ""
 
-#: attrib.c:2060
+#: attrib.c:2090
 msgid "Invalid status on atrlock.. Notify god."
 msgstr ""
 
-#: attrib.c:2066 attrib.c:2136 set.c:986 set.c:1033
+#: attrib.c:2096 attrib.c:2166 set.c:1016 set.c:1057 set.c:1062
 msgid "No such attribute."
 msgstr ""
 
-#: attrib.c:2113
+#: attrib.c:2143
 msgid "I can't find that player"
 msgstr ""
 
-#: attrib.c:2122
+#: attrib.c:2152
 msgid "You can only chown an attribute to yourself."
 msgstr ""
 
-#: attrib.c:2127
+#: attrib.c:2157
 msgid "Attribute owner changed."
 msgstr ""
 
-#: attrib.c:2131
+#: attrib.c:2161
 msgid "You don't have the permission to chown that."
 msgstr ""
 
-#: boolexp.c:421
+#: boolexp.c:423
 msgid "Too much recursion in lock!"
 msgstr ""
 
-#: boolexp.c:1000
+#: boolexp.c:1011
 #, c-format
 msgid "I don't see %s here."
 msgstr ""
 
-#: boolexp.c:1004
+#: boolexp.c:1015
 #, c-format
 msgid "I don't know which %s you mean!"
 msgstr ""
 
-#: boolexp.c:2052 boolexp.c:2068
+#: boolexp.c:2067 boolexp.c:2083
 #, c-format
 msgid "%s lock refers to garbage object"
 msgstr ""
 
-#: boolexp.c:2061
+#: boolexp.c:2076
 #, c-format
 msgid "%s lock has eval-lock that uses a nonexistant attribute '%s'."
 msgstr ""
 
-#: boolexp.c:2071
+#: boolexp.c:2086
 #, c-format
 msgid "%s lock has indirect lock to %s/%s that it can't read"
 msgstr ""
 
-#: bsd.c:263 player.c:201
+#: bsd.c:262 player.c:224
 msgid "Either that player does not exist, or has a different password."
 msgstr ""
 
-#: bsd.c:266
+#: bsd.c:265
 msgid ""
 "Either there is already a player with that name, or that name is illegal."
 msgstr ""
 
-#: bsd.c:267
+#: bsd.c:266
 msgid "The password is invalid (or missing)."
 msgstr ""
 
-#: bsd.c:268
+#: bsd.c:267
 msgid "Unable to register that player with that email address."
 msgstr ""
 
-#: bsd.c:269
+#: bsd.c:268
 msgid "Registration successful! You will receive your password by email."
 msgstr ""
 
-#: bsd.c:270
+#: bsd.c:269
 msgid "Going down - Bye"
 msgstr ""
 
-#: bsd.c:271
+#: bsd.c:270
 msgid "GAME: SSL connections must be dropped, sorry."
 msgstr ""
 
-#: bsd.c:695
+#: bsd.c:696
 #, c-format
 msgid "Unable to open %s. Error output continues to stderr.\n"
 msgstr ""
 
-#: bsd.c:699 log.c:142
+#: bsd.c:700 log.c:163
 msgid "Ack!  Failed reopening stderr!"
 msgstr ""
 
-#: bsd.c:939 bsd.c:949
+#: bsd.c:940 bsd.c:943 bsd.c:955 bsd.c:958
 msgid "GAME: ERROR! Forking database save failed!"
 msgstr ""
 
-#: bsd.c:966
+#: bsd.c:975
 msgid "GAME: Shutdown by external signal"
 msgstr ""
 
-#: bsd.c:1462
+#: bsd.c:1469
 #, c-format
 msgid ""
 "%s sizes:  NewUser...%d  Connect...%d  Guest...%d  Motd...%d  Wizmotd...%d  "
 "Quit...%d  Register...%d  Down...%d  Full...%d"
 msgstr ""
 
-#: bsd.c:2498
+#: bsd.c:2515
 #, c-format
 msgid "%ld failed connections since last login."
 msgstr ""
 
-#: bsd.c:2511
+#: bsd.c:2528
 msgid "Your HAVEN flag is set. You cannot receive pages."
 msgstr ""
 
-#: bsd.c:2515
+#: bsd.c:2532
 msgid "Welcome back from vacation! Don't forget to unset your ON-VACATION flag"
 msgstr ""
 
-#: bsd.c:2822 wiz.c:864
+#: bsd.c:2860 wiz.c:880
 msgid "You are politely shown to the door."
 msgstr ""
 
-#: bsd.c:2831
+#: bsd.c:2869
 msgid "You boot an idle self."
 msgstr ""
 
-#: bsd.c:2833
+#: bsd.c:2871
 #, c-format
 msgid "You boot %d idle selves."
 msgstr ""
 
-#: bsd.c:2885 bsd.c:2936
+#: bsd.c:2923 bsd.c:2974
 msgid "That's not a port number."
 msgstr ""
 
-#: bsd.c:2895
+#: bsd.c:2933
 msgid "That port is not active."
 msgstr ""
 
-#: bsd.c:2900 speech.c:577
+#: bsd.c:2938 speech.c:596
 #, c-format
 msgid "You pemit \"%s\" to %s."
 msgstr ""
 
-#: bsd.c:2901 bsd.c:2982 bsd.c:2988
+#: bsd.c:2939 bsd.c:3020 bsd.c:3026
 msgid "a connecting player"
 msgstr ""
 
-#: bsd.c:2941 bsd.c:2953
+#: bsd.c:2979 bsd.c:2991
 msgid "What do you want to page with?"
 msgstr ""
 
-#: bsd.c:2971
+#: bsd.c:3009
 msgid "That port's not active."
 msgstr ""
 
-#: bsd.c:2978
+#: bsd.c:3016
 #, c-format
 msgid "From afar, %s%s%s"
 msgstr ""
 
-#: bsd.c:2980 speech.c:1046
+#: bsd.c:3018 speech.c:1089
 #, c-format
 msgid "Long distance to %s: %s%s%s"
 msgstr ""
 
-#: bsd.c:2985
+#: bsd.c:3023
 #, c-format
 msgid "%s pages: %s"
 msgstr ""
 
-#: bsd.c:2986 speech.c:1049
+#: bsd.c:3024 speech.c:1092
 #, c-format
 msgid "You paged %s with '%s'"
 msgstr ""
 
-#: bsd.c:3296 bsd.c:3350 bsd.c:3404 bsd.c:3485
+#: bsd.c:3330 bsd.c:3383 bsd.c:3437 bsd.c:3519
 msgid "Player Name"
 msgstr ""
 
-#: bsd.c:3296 bsd.c:3350 bsd.c:3405 bsd.c:3485
+#: bsd.c:3330 bsd.c:3383 bsd.c:3438 bsd.c:3519
 msgid "On For"
 msgstr ""
 
-#: bsd.c:3296 bsd.c:3351 bsd.c:3405 bsd.c:3485
+#: bsd.c:3330 bsd.c:3384 bsd.c:3438 bsd.c:3519
 msgid "Idle"
 msgstr ""
 
-#: bsd.c:3316 bsd.c:3369 bsd.c:3450 bsd.c:3521
+#: bsd.c:3349 bsd.c:3402 bsd.c:3484 bsd.c:3556
 msgid "There are no players connected."
 msgstr ""
 
-#: bsd.c:3319
+#: bsd.c:3352
 msgid "There is 1 player connected."
 msgstr ""
 
-#: bsd.c:3322 bsd.c:3375 bsd.c:3456 bsd.c:3527
+#: bsd.c:3355 bsd.c:3408 bsd.c:3490 bsd.c:3562
 #, c-format
 msgid "There are %d players connected."
 msgstr ""
 
-#: bsd.c:3372 bsd.c:3453 bsd.c:3524
+#: bsd.c:3405 bsd.c:3487 bsd.c:3559
 msgid "There is one player connected."
 msgstr ""
 
-#: bsd.c:3405 bsd.c:3485
+#: bsd.c:3438 bsd.c:3519
 msgid "Loc #"
 msgstr ""
 
-#: bsd.c:3405 bsd.c:3485
+#: bsd.c:3438 bsd.c:3519
 msgid "Cmds"
 msgstr ""
 
-#: bsd.c:3405 bsd.c:3486
+#: bsd.c:3438 bsd.c:3520
 msgid "Des"
 msgstr ""
 
-#: bsd.c:3406
+#: bsd.c:3439
 msgid "Host"
 msgstr ""
 
-#: bsd.c:3434 bsd.c:3507
+#: bsd.c:3468 bsd.c:3542
 msgid "Connecting..."
 msgstr ""
 
-#: bsd.c:3486
+#: bsd.c:3520
 msgid "Sent"
 msgstr ""
 
-#: bsd.c:3486
+#: bsd.c:3520
 msgid "Recv"
 msgstr ""
 
-#: bsd.c:3486
+#: bsd.c:3520
 msgid "Pend"
 msgstr ""
 
-#: bsd.c:3599
+#: bsd.c:3634
 #, c-format
 msgid "%s created."
 msgstr ""
 
-#: bsd.c:3600 bsd.c:3622 bsd.c:3625 bsd.c:3843 bsd.c:3846
+#: bsd.c:3635 bsd.c:3657 bsd.c:3660 bsd.c:3896 bsd.c:3899
 msgid "GAME:"
 msgstr ""
 
-#: bsd.c:3602
+#: bsd.c:3637
 #, c-format
 msgid "GAME: Suspect %s created."
 msgstr ""
 
-#: bsd.c:3607
+#: bsd.c:3642
 msgid "has DARK-reconnected."
 msgstr ""
 
-#: bsd.c:3607
+#: bsd.c:3642
 msgid "has DARK-connected."
 msgstr ""
 
-#: bsd.c:3610
+#: bsd.c:3645
 msgid "has HIDDEN-reconnected."
 msgstr ""
 
-#: bsd.c:3611
+#: bsd.c:3646
 msgid "has HIDDEN-connected."
 msgstr ""
 
-#: bsd.c:3613
+#: bsd.c:3648
 msgid "has reconnected."
 msgstr ""
 
-#: bsd.c:3613
+#: bsd.c:3648
 msgid "has connected."
 msgstr ""
 
-#: bsd.c:3619 bsd.c:3841
+#: bsd.c:3654 bsd.c:3894
 #, c-format
 msgid "GAME: Suspect %s"
 msgstr ""
 
-#: bsd.c:3632
+#: bsd.c:3667
 msgid "You are nowhere!"
 msgstr ""
 
-#: bsd.c:3819
+#: bsd.c:3872
 msgid "has partially DARK-disconnected."
 msgstr ""
 
-#: bsd.c:3820
+#: bsd.c:3873
 msgid "has DARK-disconnected."
 msgstr ""
 
-#: bsd.c:3822
+#: bsd.c:3875
 msgid "has partially HIDDEN-disconnected."
 msgstr ""
 
-#: bsd.c:3823
+#: bsd.c:3876
 msgid "has HIDDEN-disconnected."
 msgstr ""
 
-#: bsd.c:3825
+#: bsd.c:3878
 msgid "has partially disconnected."
 msgstr ""
 
-#: bsd.c:3826
+#: bsd.c:3879
 msgid "has disconnected."
 msgstr ""
 
-#: bsd.c:3871
+#: bsd.c:3924
 msgid "You may get 15 minutes of fame and glory in life, but not right now."
 msgstr ""
 
-#: bsd.c:3876 extchat.c:2094
+#: bsd.c:3929
 msgid "cleared"
 msgstr ""
 
-#: bsd.c:3878 extchat.c:2094
+#: bsd.c:3931
 msgid "set"
 msgstr ""
 
-#: bsd.c:3883
+#: bsd.c:3936
 #, c-format
 msgid "Motd %s."
 msgstr ""
 
-#: bsd.c:3887
+#: bsd.c:3940
 #, c-format
 msgid "Wizard motd %s."
 msgstr ""
 
-#: bsd.c:3891
+#: bsd.c:3944
 #, c-format
 msgid "Down motd %s."
 msgstr ""
 
-#: bsd.c:3895
+#: bsd.c:3948
 #, c-format
 msgid "Full motd %s."
 msgstr ""
 
-#: bsd.c:3898
+#: bsd.c:3951
 #, c-format
 msgid "MOTD: %s"
 msgstr ""
 
-#: bsd.c:3900
+#: bsd.c:3953
 #, c-format
 msgid "Wiz MOTD: %s"
 msgstr ""
 
-#: bsd.c:3901
+#: bsd.c:3954
 #, c-format
 msgid "Down MOTD: %s"
 msgstr ""
 
-#: bsd.c:3902
+#: bsd.c:3955
 #, c-format
 msgid "Full MOTD: %s"
 msgstr ""
 
-#: bsd.c:3923
+#: bsd.c:3976
 msgid "Why would you want to do that?"
 msgstr ""
 
-#: bsd.c:3942
+#: bsd.c:3995
 #, c-format
 msgid "Doing set. %d characters lost."
 msgstr ""
 
-#: bsd.c:3945
+#: bsd.c:3998
 msgid "Doing set."
 msgstr ""
 
-#: bsd.c:3963
+#: bsd.c:4016
 #, c-format
 msgid "The current poll is: %s"
 msgstr ""
 
-#: bsd.c:3968
+#: bsd.c:4021
 msgid "Who do you think you are, Gallup?"
 msgstr ""
 
-#: bsd.c:3974
+#: bsd.c:4027
 msgid "Poll reset."
 msgstr ""
 
-#: bsd.c:3989
+#: bsd.c:4042
 #, c-format
 msgid "Poll set to '%s'. %d characters lost."
 msgstr ""
 
-#: bsd.c:3992
+#: bsd.c:4045
 #, c-format
 msgid "Poll set to: %s"
 msgstr ""
 
-#: bsd.c:4161 bsd.c:4170 bsd.c:4691 bsd.c:4700 cmds.c:448 fundb.c:895
-#: fundb.c:922
+#: bsd.c:4214 bsd.c:4223 bsd.c:4746 bsd.c:4755 cmds.c:449 fundb.c:900
+#: fundb.c:927
 msgid "#-1 INVALID SECOND ARGUMENT"
 msgstr ""
 
-#: bsd.c:4174 bsd.c:4704 extchat.c:2397 extchat.c:2402 parse.c:99
+#: bsd.c:4227 bsd.c:4759 extchat.c:2415 extchat.c:2420 parse.c:99
 msgid "#-1 PERMISSION DENIED"
 msgstr ""
 
-#: bsd.c:4213 bsd.c:4783
+#: bsd.c:4266 bsd.c:4839
 msgid "Couldn't find that descriptor."
 msgstr ""
 
-#: bsd.c:4221 wiz.c:1424
+#: bsd.c:4274 wiz.c:1440
 msgid "Couldn't find that player."
 msgstr ""
 
-#: bsd.c:4439 funufun.c:321
+#: bsd.c:4494 funufun.c:326
 msgid "#-1 INVALID ZONE"
 msgstr ""
 
-#: bsd.c:4556 bsd.c:4577 bsd.c:4630
+#: bsd.c:4611 bsd.c:4632 bsd.c:4685
 msgid "#-1 NOT CONNECTED"
 msgstr ""
 
-#: bsd.c:4587 bsd.c:4600 bsd.c:4613
+#: bsd.c:4642 bsd.c:4655 bsd.c:4668
 msgid "#-1 FUNCTION REQUIRES ONE ARGUMENT"
 msgstr ""
 
-#: bsd.c:4794
+#: bsd.c:4850
 msgid "Noone is connected to that descriptor."
 msgstr ""
 
-#: bsd.c:4799
+#: bsd.c:4857
 msgid "Connection hidden."
 msgstr ""
 
-#: bsd.c:4801
+#: bsd.c:4859
 msgid "Connection unhidden."
 msgstr ""
 
-#: bsd.c:4815 wiz.c:890
+#: bsd.c:4873 wiz.c:906
 msgid "That player is not online."
 msgstr ""
 
-#: bsd.c:4824
+#: bsd.c:4893
 msgid "You no longer appear on the WHO list."
 msgstr ""
 
-#: bsd.c:4826
+#: bsd.c:4895
 #, c-format
 msgid "%s no longer appears on the WHO list."
 msgstr ""
 
-#: bsd.c:4830
+#: bsd.c:4899
 msgid "You now appear on the WHO list."
 msgstr ""
 
-#: bsd.c:4832
+#: bsd.c:4901
 #, c-format
 msgid "%s now appears on the WHO list."
 msgstr ""
 
-#: bsd.c:4874
+#: bsd.c:4946
 msgid ""
 "\n"
 "*** Inactivity timeout ***\n"
 msgstr ""
 
-#: bsd.c:4884
+#: bsd.c:4957
 msgid ""
 "\n"
 "*** Inactivity limit reached. You are now HIDDEN. ***\n"
 msgstr ""
 
-#: bsd.c:5039 bsd.c:5046
+#: bsd.c:5114 bsd.c:5121
 msgid "GAME: Error writing reboot database!"
 msgstr ""
 
-#: bsd.c:5233
+#: bsd.c:5307
 msgid "GAME: Reboot finished."
 msgstr ""
 
-#: bsd.c:5255
+#: bsd.c:5329
 #, c-format
 msgid "Unable to reboot using executable '%s': %s"
 msgstr ""
 
-#: bsd.c:5264
+#: bsd.c:5338
 msgid "GAME: Reboot w/o disconnect from game account, please wait."
 msgstr ""
 
-#: bsd.c:5269
+#: bsd.c:5343
 #, c-format
 msgid "GAME: Reboot w/o disconnect by %s, please wait."
 msgstr ""
@@ -902,610 +903,610 @@
 msgid "Option set."
 msgstr ""
 
-#: cmds.c:519
-msgid "You must give a switch for @hook"
+#: cmds.c:525
+msgid "You must give a switch for @hook."
 msgstr ""
 
-#: cmds.c:527
+#: cmds.c:530
+msgid "You can only use /inplace with /override."
+msgstr ""
+
+#: cmds.c:540
 msgid "Huh?  (Type \"help\" for help.)"
 msgstr ""
 
-#: cmds.c:583 game.c:2402
+#: cmds.c:597 game.c:2410
 msgid "Locks"
 msgstr ""
 
-#: cmds.c:587 cmds.c:903 game.c:2400
+#: cmds.c:601 cmds.c:911 game.c:2408
 msgid "Powers"
 msgstr ""
 
-#: cmds.c:685 extmail.c:1624
+#: cmds.c:705 extmail.c:1644
 msgid "You cannot do that while gagged."
 msgstr ""
 
-#: cmds.c:755
+#: cmds.c:775
 msgid "@message them with what?"
 msgstr ""
 
-#: cmds.c:758
+#: cmds.c:778
 msgid "Use what attribute for the @message?"
 msgstr ""
 
-#: cmds.c:762
+#: cmds.c:782
 msgid "@message who?"
 msgstr ""
 
-#: cmds.c:1106
+#: cmds.c:1113
 msgid "You can't teleport to nothing!"
 msgstr ""
 
-#: cmds.c:1298
+#: cmds.c:1306
 msgid "Buy for WHAT price?"
 msgstr ""
 
-#: cmds.c:1303
+#: cmds.c:1311
 msgid "You can't buy things by taking money."
 msgstr ""
 
-#: cmds.c:1420
+#: cmds.c:1428
 #, c-format
 msgid "No command found in code by %s - don't start code with functions."
 msgstr ""
 
-#: command.c:1275
+#: command.c:1282
 #, c-format
 msgid "%s doesn't know switch %s."
 msgstr ""
 
-#: command.c:1683
+#: command.c:1690
 msgid "This command has not been implemented."
 msgstr ""
 
-#: command.c:1710 command.c:1741
+#: command.c:1717 command.c:1748
 msgid "Bad command name."
 msgstr ""
 
-#: command.c:1716
+#: command.c:1723
 #, c-format
 msgid "Command %s added."
 msgstr ""
 
-#: command.c:1719
+#: command.c:1726
 #, c-format
 msgid "Command %s already exists."
 msgstr ""
 
-#: command.c:1738 command.c:1827 command.c:1918 command.c:2291 command.c:2394
+#: command.c:1745 command.c:1834 command.c:1925 command.c:2310 command.c:2414
 msgid "No such command."
 msgstr ""
 
-#: command.c:1746
+#: command.c:1753
 msgid "Command cloned."
 msgstr ""
 
-#: command.c:1835
+#: command.c:1842
 msgid "You can't delete built-in commands. @command/disable instead."
 msgstr ""
 
-#: command.c:1851
+#: command.c:1858
 #, c-format
 msgid "Removed %s and aliases from command table."
 msgstr ""
 
-#: command.c:1854 command.c:1859
+#: command.c:1861 command.c:1866
 #, c-format
 msgid "Removed %s from command table."
 msgstr ""
 
-#: command.c:1875
+#: command.c:1882
 msgid "You must specify a command."
 msgstr ""
 
-#: command.c:1888
+#: command.c:1895
 msgid ""
 "WARNING: /NOEVAL no longer creates a Noparse command.\n"
 "         Use /NOPARSE if that's what you meant."
 msgstr ""
 
-#: command.c:1895
+#: command.c:1902
 msgid "I can't alias a command to that!"
 msgstr ""
 
-#: command.c:1897
+#: command.c:1904
 msgid "Unable to set alias."
 msgstr ""
 
-#: command.c:1929
+#: command.c:1936
 msgid "How do you want to restrict the command?"
 msgstr ""
 
-#: command.c:1934
+#: command.c:1941
 msgid "Restrict attempt failed."
 msgstr ""
 
-#: command.c:1938
+#: command.c:1945
 msgid "@command is ALWAYS enabled."
 msgstr ""
 
-#: command.c:1944
+#: command.c:1951
 #, c-format
 msgid "Name       : %s (%s)"
 msgstr ""
 
-#: command.c:1957
+#: command.c:1964
 #, c-format
 msgid "Flags      : %s"
 msgstr ""
 
-#: command.c:1959
+#: command.c:1966
 #, c-format
 msgid "Lock       : %s"
 msgstr ""
 
-#: command.c:1967
+#: command.c:1974
 #, c-format
 msgid "Switches   : %s"
 msgstr ""
 
-#: command.c:1969
+#: command.c:1976
 msgid "Switches   :"
 msgstr ""
 
-#: command.c:1982
+#: command.c:1989
 #, c-format
 msgid "Leftside   : %s"
 msgstr ""
 
-#: command.c:1994
+#: command.c:2001
 #, c-format
 msgid "Rightside  : %s"
 msgstr ""
 
-#: command.c:1997
+#: command.c:2004
 #, c-format
 msgid "Arguments  : %s"
 msgstr ""
 
-#: command.c:2013
+#: command.c:2020
 #, c-format
 msgid "Commands: %s"
 msgstr ""
 
-#: command.c:2295
+#: command.c:2314
 msgid "Hooks not allowed with that command."
 msgstr ""
 
-#: command.c:2308
+#: command.c:2327
 msgid "Unknown hook type"
 msgstr ""
 
-#: command.c:2313
+#: command.c:2332
 #, c-format
 msgid "Hook removed from %s."
 msgstr ""
 
-#: command.c:2322
+#: command.c:2341
 msgid "You must give an object."
 msgstr ""
 
-#: command.c:2324
+#: command.c:2343
 msgid "You must give both an object and attribute."
 msgstr ""
 
-#: command.c:2329
+#: command.c:2348
 msgid "Invalid hook object."
 msgstr ""
 
-#: command.c:2340
+#: command.c:2360
 #, c-format
 msgid "Hook set for %s"
 msgstr ""
 
-#: command.c:2374
+#: command.c:2394
 msgid "There are no hooks currently set."
 msgstr ""
 
-#: command.c:2379
+#: command.c:2399
 msgid "The following commands have hooks: "
 msgstr ""
 
-#: conf.c:552
+#: conf.c:558
 msgid "Options affecting attributes"
 msgstr ""
 
-#: conf.c:553
+#: conf.c:559
 msgid "Chat system options"
 msgstr ""
 
-#: conf.c:554
+#: conf.c:560
 msgid "Options affecting command behavior"
 msgstr ""
 
-#: conf.c:555
+#: conf.c:561
 msgid "Compile-time options"
 msgstr ""
 
-#: conf.c:556
+#: conf.c:562
 msgid "Cosmetic options"
 msgstr ""
 
-#: conf.c:557
+#: conf.c:563
 msgid "Costs"
 msgstr ""
 
-#: conf.c:558
+#: conf.c:564
 msgid "Database options"
 msgstr ""
 
-#: conf.c:559
+#: conf.c:565
 msgid "Options affecting dumps and other periodic processes"
 msgstr ""
 
-#: conf.c:560
+#: conf.c:566
 msgid "Files used by the MUSH"
 msgstr ""
 
-#: conf.c:561
+#: conf.c:567
 msgid "Default flags for new objects"
 msgstr ""
 
-#: conf.c:562
+#: conf.c:568
 msgid "Options affecting function behavior"
 msgstr ""
 
-#: conf.c:563
+#: conf.c:569
 msgid "Limits and other constants"
 msgstr ""
 
-#: conf.c:564
+#: conf.c:570
 msgid "Logging options"
 msgstr ""
 
-#: conf.c:565
+#: conf.c:571
 msgid "Message files sent by the MUSH"
 msgstr ""
 
-#: conf.c:566
+#: conf.c:572
 msgid "Networking and connection-related options"
 msgstr ""
 
-#: conf.c:567
+#: conf.c:573
 msgid "TinyMUSH compatibility options"
 msgstr ""
 
-#: conf.c:1291
+#: conf.c:1301
 msgid "GAME: Saving database. Game may freeze for a few moments."
 msgstr ""
 
-#: conf.c:1292
+#: conf.c:1302
 msgid "GAME: Save complete. "
 msgstr ""
 
-#: conf.c:1311
+#: conf.c:1321
 msgid "Penny"
 msgstr ""
 
-#: conf.c:1312
+#: conf.c:1322
 msgid "Pennies"
 msgstr ""
 
-#: conf.c:1352
+#: conf.c:1362
 msgid "GAME: Database save in 1 minute."
 msgstr ""
 
-#: conf.c:1353
+#: conf.c:1363
 msgid "GAME: Database save in 5 minutes."
 msgstr ""
 
-#: conf.c:1393
+#: conf.c:1403
 msgid "Broadcast:"
 msgstr ""
 
-#: conf.c:1394
+#: conf.c:1404
 msgid "Admin:"
 msgstr ""
 
-#: conf.c:1395
+#: conf.c:1405
 msgid "Announcement:"
 msgstr ""
 
-#: conf.c:1661
+#: conf.c:1667
 msgid "I only know the following types of options:"
 msgstr ""
 
-#: conf.c:1691
+#: conf.c:1697
 msgid "Use: @config/list <type of options> where type is one of:"
 msgstr ""
 
-#: conf.c:1804
+#: conf.c:1810
 msgid "#-1 NO SUCH CONFIG OPTION"
 msgstr ""
 
-#: conf.c:1843
+#: conf.c:1849
 msgid "That option cannot be altered."
 msgstr ""
 
-#: conf.c:1848 function.c:1774
+#: conf.c:1854 function.c:1780
 msgid "Disabled."
 msgstr ""
 
-#: conf.c:1850 function.c:1771
+#: conf.c:1856 function.c:1777
 msgid "Enabled."
 msgstr ""
 
-#: conf.c:1854
+#: conf.c:1860
 msgid "That isn't an on/off option."
 msgstr ""
 
-#: conf.c:1858
+#: conf.c:1864
 msgid "No such option."
 msgstr ""
 
-#: conf.c:1865
+#: conf.c:1871
 msgid " Attributes are not compressed in memory."
 msgstr ""
 
-#: conf.c:1868
+#: conf.c:1874
 msgid " Attributes are Huffman compressed in memory."
 msgstr ""
 
-#: conf.c:1871
+#: conf.c:1877
 msgid " Attributes are word compressed in memory."
 msgstr ""
 
-#: conf.c:1874
+#: conf.c:1880
 msgid " Attributes are 8-bit word compressed in memory."
 msgstr ""
 
-#: conf.c:1878
+#: conf.c:1884
 msgid " The MUSH was compiled with SSL support."
 msgstr ""
 
-#: conf.c:1882
+#: conf.c:1888
 msgid " The MUSH was compiled with MySQL support."
 msgstr ""
 
-#: conf.c:1885
+#: conf.c:1891
 msgid " The MUSH was compiled with Postgresql support."
 msgstr ""
 
-#: conf.c:1888
+#: conf.c:1894
 msgid " The MUSH was compiled with Sqlite3 support."
 msgstr ""
 
-#: conf.c:1892
+#: conf.c:1898
 msgid " DNS and ident lookups are handled by a slave process."
 msgstr ""
 
-#: conf.c:1894
+#: conf.c:1900
 msgid " DNS and ident lookups are handled by the MUSH process."
 msgstr ""
 
-#: conf.c:1898
+#: conf.c:1904
 msgid " Extended convtime() is supported."
 msgstr ""
 
-#: conf.c:1900
+#: conf.c:1906
 msgid " convtime() is stricter."
 msgstr ""
 
-#: conf.c:1904
+#: conf.c:1910
 msgid " CPU usage limiting is supported."
 msgstr ""
 
-#: conf.c:1906
+#: conf.c:1912
 msgid " CPU usage limiting is NOT supported."
 msgstr ""
 
-#: conf.c:1910
+#: conf.c:1916
 msgid " Changed help files will be automatically reindexed."
 msgstr ""
 
-#: conf.c:1914
+#: conf.c:1920
 msgid " SSE2 instructions are being used."
 msgstr ""
 
-#: conf.c:1918
+#: conf.c:1924
 msgid " SSE3 instructions are being used."
 msgstr ""
 
-#: conf.c:1922
+#: conf.c:1928
 msgid " Altivec instructions are being used."
 msgstr ""
 
-#: conf.c:1926
+#: conf.c:1932
 msgid " @config/save is enabled."
 msgstr ""
 
-#: conf.c:1928
+#: conf.c:1934
 msgid " @config/save is disabled."
 msgstr ""
 
-#: cque.c:224
+#: cque.c:228
 #, c-format
 msgid "Not enough money to queue command for %s(#%d)."
 msgstr ""
 
-#: cque.c:240
+#: cque.c:244
 #, c-format
 msgid "GAME: Object %s(%s) lost a %s to queue loss."
 msgstr ""
 
-#: cque.c:249
+#: cque.c:253
 #, c-format
 msgid "Runaway object: %s(%s). Commands halted."
 msgstr ""
 
-#: cque.c:315 cque.c:478
+#: cque.c:344 cque.c:481 cque.c:693
 msgid "Queue entry table full. Try again later."
 msgstr ""
 
-#: cque.c:748
+#: cque.c:975
 msgid "@break recursion exceeded."
 msgstr ""
 
-#: cque.c:756
-msgid "@include recursion exceeded."
-msgstr ""
-
-#: cque.c:980
+#: cque.c:1200
 msgid "You must specify an object to use for the semaphore."
 msgstr ""
 
-#: cque.c:990
+#: cque.c:1210
 msgid "You may not specify a semaphore attribute with the ANY switch."
 msgstr ""
 
-#: cque.c:1022
+#: cque.c:1242
 msgid "You may not specify a semaphore count with the ALL switch."
 msgstr ""
 
-#: cque.c:1026
+#: cque.c:1246
 msgid "The semaphore count must be an integer."
 msgstr ""
 
-#: cque.c:1042
+#: cque.c:1262
 msgid "Drained."
 msgstr ""
 
-#: cque.c:1044
+#: cque.c:1264
 msgid "Notified."
 msgstr ""
 
-#: cque.c:1153 cque.c:1161 cque.c:1541 cque.c:1548 cque.c:1711 cque.c:1718
+#: cque.c:1373 cque.c:1381 cque.c:1761 cque.c:1768 cque.c:1931 cque.c:1938
 msgid "That is not a valid pid!"
 msgstr ""
 
-#: cque.c:1172
+#: cque.c:1392
 msgid "You cannot adjust the timeout of an indefinite semaphore."
 msgstr ""
 
-#: cque.c:1177
+#: cque.c:1397
 msgid "That is not a valid timestamp."
 msgstr ""
 
-#: cque.c:1243
+#: cque.c:1463
 #, c-format
 msgid "Queue entry with pid %u updated."
 msgstr ""
 
-#: cque.c:1265
+#: cque.c:1485
 msgid "#-1 INVALID PID"
 msgstr ""
 
-#: cque.c:1492 set.c:177
+#: cque.c:1712 set.c:199
 msgid "I couldn't find that player."
 msgstr ""
 
-#: cque.c:1495 rob.c:187 rob.c:352 speech.c:567
+#: cque.c:1715 rob.c:196 rob.c:383 speech.c:588
 msgid "I don't know who you mean!"
 msgstr ""
 
-#: cque.c:1501
+#: cque.c:1721
 msgid "Queue for : all"
 msgstr ""
 
-#: cque.c:1503
+#: cque.c:1723
 #, c-format
 msgid "Queue for : %s"
 msgstr ""
 
-#: cque.c:1507
+#: cque.c:1727
 msgid "Player Queue:"
 msgstr ""
 
-#: cque.c:1510
+#: cque.c:1730
 msgid "Object Queue:"
 msgstr ""
 
-#: cque.c:1513
+#: cque.c:1733
 msgid "Wait Queue:"
 msgstr ""
 
-#: cque.c:1516
+#: cque.c:1736
 msgid "Semaphore Queue:"
 msgstr ""
 
-#: cque.c:1519
+#: cque.c:1739
 msgid "------------  Queue Done  ------------"
 msgstr ""
 
-#: cque.c:1522
+#: cque.c:1742
 #, c-format
 msgid ""
 "Totals: Player...%d/%d[%ddel]  Object...%d/%d[%ddel]  Wait...%d/%d[%ddel]  "
 "Semaphore...%d/%d"
 msgstr ""
 
-#: cque.c:1584 cque.c:1689 cque.c:1691
+#: cque.c:1804 cque.c:1909 cque.c:1911
 msgid "Halted"
 msgstr ""
 
-#: cque.c:1670
+#: cque.c:1890
 msgid "You may not use @halt obj=command on this object."
 msgstr ""
 
-#: cque.c:1679
+#: cque.c:1899
 msgid "All of your objects have been halted."
 msgstr ""
 
-#: cque.c:1682
+#: cque.c:1902
 #, c-format
 msgid "All objects for %s have been halted."
 msgstr ""
 
-#: cque.c:1684
+#: cque.c:1904
 #, c-format
 msgid "All of your objects have been halted by %s."
 msgstr ""
 
-#: cque.c:1752
+#: cque.c:1972
 #, c-format
 msgid "Queue entry with pid %u halted."
 msgstr ""
 
-#: cque.c:1766
+#: cque.c:1986
 msgid "You do not have the power to bring the world to a halt."
 msgstr ""
 
-#: cque.c:1772
+#: cque.c:1992
 #, c-format
 msgid "Your objects have been globally halted by %s"
 msgstr ""
 
-#: cque.c:1790
+#: cque.c:2010
 msgid "You do not have the power to restart the world."
 msgstr ""
 
-#: cque.c:1802
+#: cque.c:2022
 #, c-format
 msgid "Your objects are being globally restarted by %s"
 msgstr ""
 
-#: cque.c:1847
+#: cque.c:2067
 #, c-format
 msgid "All objects for %s are being restarted."
 msgstr ""
 
-#: cque.c:1851
+#: cque.c:2071
 #, c-format
 msgid "All of your objects are being restarted by %s."
 msgstr ""
 
-#: cque.c:1855
+#: cque.c:2075
 #, c-format
 msgid "Restarting: %s's %s(%s)"
 msgstr ""
 
-#: cque.c:1857
+#: cque.c:2077
 #, c-format
 msgid "Restarting: %s(%s), by %s"
 msgstr ""
 
-#: cque.c:1862
+#: cque.c:2082
 msgid "All of your objects are being restarted."
 msgstr ""
 
-#: cque.c:1864
+#: cque.c:2084
 #, c-format
 msgid "Restarting: %s(%s)"
 msgstr ""
@@ -1522,166 +1523,166 @@
 msgid "You can't link to that."
 msgstr ""
 
-#: create.c:104
+#: create.c:106
 msgid "Sorry, you can only make exits out of rooms."
 msgstr ""
 
-#: create.c:108
+#: create.c:110
 msgid "You can't make an exit in a place that's crumbling."
 msgstr ""
 
-#: create.c:112
+#: create.c:114
 msgid "Open where?"
 msgstr ""
 
-#: create.c:115
+#: create.c:119
 msgid "That's a strange name for an exit!"
 msgstr ""
 
-#: create.c:145
+#: create.c:158
 #, c-format
 msgid "Opened exit %s"
 msgstr ""
 
-#: create.c:149
+#: create.c:162
 msgid "Trying to link..."
 msgstr ""
 
-#: create.c:154
+#: create.c:167
 #, c-format
 msgid "You don't have enough %s to link."
 msgstr ""
 
-#: create.c:158
+#: create.c:171
 #, c-format
 msgid "Linked exit #%d to #%d"
 msgstr ""
 
-#: create.c:189
+#: create.c:208
 msgid "Open from where?"
 msgstr ""
 
-#: create.c:230
+#: create.c:249
 msgid "Unlink what?"
 msgstr ""
 
-#: create.c:233 match.c:481 wiz.c:984
+#: create.c:252 match.c:527 wiz.c:1000
 msgid "I don't know which one you mean!"
 msgstr ""
 
-#: create.c:243
+#: create.c:262
 #, c-format
 msgid "Unlinked exit #%d (Used to lead to %s)."
 msgstr ""
 
-#: create.c:248
+#: create.c:267
 msgid "Dropto removed."
 msgstr ""
 
-#: create.c:251
+#: create.c:270
 msgid "You can't unlink that!"
 msgstr ""
 
-#: create.c:290
+#: create.c:309
 msgid "You somehow wound up in a exit. No biscuit."
 msgstr ""
 
-#: create.c:321 create.c:328
+#: create.c:340 create.c:347
 #, c-format
 msgid "It costs %d %s to link this exit."
 msgstr ""
 
-#: create.c:346
+#: create.c:365
 #, c-format
 msgid "Linked exit #%d to %s"
 msgstr ""
 
-#: create.c:354 fundb.c:1895 wiz.c:401
+#: create.c:373 fundb.c:1945 wiz.c:409
 msgid "No match."
 msgstr ""
 
-#: create.c:358
+#: create.c:377
 msgid "That is an exit."
 msgstr ""
 
-#: create.c:362
+#: create.c:381
 msgid "You may not link something to itself."
 msgstr ""
 
-#: create.c:373
+#: create.c:392
 msgid "Can't set home to home."
 msgstr ""
 
-#: create.c:378
+#: create.c:397
 msgid "Home set."
 msgstr ""
 
-#: create.c:385
+#: create.c:404
 msgid "That is not a room!"
 msgstr ""
 
-#: create.c:393
+#: create.c:412
 msgid "Dropto set."
 msgstr ""
 
-#: create.c:397
+#: create.c:416
 msgid "Internal error: weird object type."
 msgstr ""
 
-#: create.c:424
+#: create.c:449
 msgid "Dig what?"
 msgstr ""
 
-#: create.c:426
+#: create.c:451
 msgid "That's a silly name for a room!"
 msgstr ""
 
-#: create.c:445
+#: create.c:474
 #, c-format
 msgid "%s created with room number %d."
 msgstr ""
 
-#: create.c:487
+#: create.c:517
 msgid "Create what?"
 msgstr ""
 
-#: create.c:490
+#: create.c:520
 msgid "That's a silly name for a thing!"
 msgstr ""
 
-#: create.c:540
+#: create.c:570
 #, c-format
 msgid "Created: Object %s."
 msgstr ""
 
-#: create.c:583 create.c:715
+#: create.c:616 create.c:751
 msgid ""
 "Warning: @CLONE/PRESERVE on an object with WIZ, ROY, @powers, or @warnings."
 msgstr ""
 
-#: create.c:614 set.c:117
+#: create.c:653 set.c:103 set.c:114
 msgid "That is not a reasonable name."
 msgstr ""
 
-#: create.c:630
+#: create.c:666
 msgid "There's nothing left of it to clone!"
 msgstr ""
 
-#: create.c:634
+#: create.c:670
 msgid "You cannot @CLONE/PRESERVE. Use normal @CLONE instead."
 msgstr ""
 
-#: create.c:647
+#: create.c:683
 #, c-format
 msgid "Cloned: Object %s."
 msgstr ""
 
-#: create.c:664
+#: create.c:700
 #, c-format
 msgid "Cloned: Room #%d."
 msgstr ""
 
-#: create.c:716
+#: create.c:752
 #, c-format
 msgid "Cloned: Exit #%d."
 msgstr ""
@@ -1804,834 +1805,839 @@
 msgid "That can't be undestroyed."
 msgstr ""
 
-#: destroy.c:526
+#: destroy.c:527
 #, c-format
 msgid "%s has been spared from destruction."
 msgstr ""
 
-#: destroy.c:529
+#: destroy.c:530
 #, c-format
 msgid "You have been spared from destruction by %s."
 msgstr ""
 
-#: destroy.c:532
+#: destroy.c:533
 msgid "You have been spared from destruction."
 msgstr ""
 
-#: destroy.c:558
+#: destroy.c:559
 #, c-format
 msgid "The room %s has been spared from destruction."
 msgstr ""
 
-#: destroy.c:562
+#: destroy.c:563
 #, c-format
 msgid "The room %s has been spared from destruction by %s."
 msgstr ""
 
-#: destroy.c:751
+#: destroy.c:771
 msgid ""
 "The floor disappears under your feet, you fall through NOTHINGness and then:"
 msgstr ""
 
-#: destroy.c:807
+#: destroy.c:827
 #, c-format
 msgid "You get your %d %s deposit back for %s."
 msgstr ""
 
-#: destroy.c:898
+#: destroy.c:918
 msgid "That is not a valid dbref."
 msgstr ""
 
-#: destroy.c:903
+#: destroy.c:923
 msgid "Unable to create object with that dbref."
 msgstr ""
 
-#: destroy.c:1025
+#: destroy.c:1043
 msgid "Purge complete."
 msgstr ""
 
-#: destroy.c:1027
+#: destroy.c:1045
 msgid "Sorry, you are a mortal."
 msgstr ""
 
-#: destroy.c:1210
+#: destroy.c:1229
 #, c-format
 msgid "You own a disconnected room, %s"
 msgstr ""
 
-#: destroy.c:1236
+#: destroy.c:1255
 #, c-format
 msgid "You own an object in a circular zone chain: %s"
 msgstr ""
 
-#: destroy.c:1255
+#: destroy.c:1274
 #, c-format
 msgid "You own an object without a @lock/zone being used as a zone: %s"
 msgstr ""
 
-#: destroy.c:1333
+#: destroy.c:1352
 #, c-format
 msgid "You own an object %s that was 'orphaned'."
 msgstr ""
 
-#: destroy.c:1362 destroy.c:1369
+#: destroy.c:1381 destroy.c:1388
 #, c-format
 msgid "It was moved to %s."
 msgstr ""
 
-#: destroy.c:1375
+#: destroy.c:1394
 msgid "It was destroyed."
 msgstr ""
 
-#: destroy.c:1471
+#: destroy.c:1490
 msgid "Silly mortal, chicks are for kids!"
 msgstr ""
 
-#: destroy.c:1474
+#: destroy.c:1493
 msgid "GAME: Performing database consistency check."
 msgstr ""
 
-#: destroy.c:1477
+#: destroy.c:1496
 msgid "GAME: Database consistency check complete."
 msgstr ""
 
-#: extchat.c:159 extchat.c:179 extchat.c:1200 extchat.c:1334 extchat.c:1344
-#: extchat.c:1399 extchat.c:1623 extchat.c:2784 extchat.c:3888
+#: extchat.c:159 extchat.c:179 extchat.c:1211 extchat.c:1343 extchat.c:1353
+#: extchat.c:1407 extchat.c:1630 extchat.c:2825 extchat.c:3939
 msgid "CHAT: I don't recognize that channel."
 msgstr ""
 
-#: extchat.c:162 extchat.c:182 extchat.c:1337 extchat.c:1402 extchat.c:1501
+#: extchat.c:162 extchat.c:182 extchat.c:1346 extchat.c:1410 extchat.c:1508
 msgid "CHAT: I don't know which channel you mean."
 msgstr ""
 
-#: extchat.c:1021
+#: extchat.c:1032
 msgid "CHAT: Partial matches are:"
 msgstr ""
 
-#: extchat.c:1174 extchat.c:3848 extchat.c:3966
+#: extchat.c:1185 extchat.c:3899 extchat.c:4017
 msgid "You need to specify a channel."
 msgstr ""
 
-#: extchat.c:1178 extchat.c:1701
+#: extchat.c:1189 extchat.c:1708
 msgid "What do you want to do with the channel?"
 msgstr ""
 
-#: extchat.c:1197 extchat.c:3885
+#: extchat.c:1208 extchat.c:3936
 #, c-format
 msgid "CHAT: You can't do that with channel <%s>."
 msgstr ""
 
-#: extchat.c:1216 extchat.c:1313
+#: extchat.c:1227 extchat.c:1322
 msgid "I don't understand what you want to do."
 msgstr ""
 
-#: extchat.c:1225 extchat.c:1240 extchat.c:1286
+#: extchat.c:1236 extchat.c:1251 extchat.c:1296
 msgid "Invalid target."
 msgstr ""
 
-#: extchat.c:1231 extchat.c:1349
+#: extchat.c:1242 extchat.c:1358
 #, c-format
 msgid "Sorry, wrong type of thing for channel <%s>."
 msgstr ""
 
-#: extchat.c:1236 extchat.c:1324
+#: extchat.c:1247 extchat.c:1333
 msgid "Guests are not allowed to join channels."
 msgstr ""
 
-#: extchat.c:1246 extchat.c:1278 extchat.c:1376
+#: extchat.c:1257 extchat.c:1289 extchat.c:1385
 #, c-format
 msgid "%s is already on channel <%s>."
 msgstr ""
 
-#: extchat.c:1256
+#: extchat.c:1267
 msgid ""
 "CHAT: Warning: Target does not meet channel join permissions! (joining "
 "anyway)"
 msgstr ""
 
-#: extchat.c:1258 extchat.c:1361
+#: extchat.c:1269 extchat.c:1370
 msgid "Permission to join denied."
 msgstr ""
 
-#: extchat.c:1264
+#: extchat.c:1275
 #, c-format
 msgid "CHAT: %s joins you to channel <%s>."
 msgstr ""
 
-#: extchat.c:1267
+#: extchat.c:1278
 #, c-format
 msgid "CHAT: You join %s to channel <%s>."
 msgstr ""
 
-#: extchat.c:1274 extchat.c:1372
+#: extchat.c:1285 extchat.c:1381
 msgid "has joined this channel."
 msgstr ""
 
-#: extchat.c:1290
+#: extchat.c:1300
 msgid "Guests may not leave channels."
 msgstr ""
 
-#: extchat.c:1299 extchat.c:1414
+#: extchat.c:1308 extchat.c:1421
 msgid "has left this channel."
 msgstr ""
 
-#: extchat.c:1302
+#: extchat.c:1311
 #, c-format
 msgid "CHAT: %s removes you from channel <%s>."
 msgstr ""
 
-#: extchat.c:1305
+#: extchat.c:1314
 #, c-format
 msgid "CHAT: You remove %s from channel <%s>."
 msgstr ""
 
-#: extchat.c:1308 extchat.c:1418
+#: extchat.c:1317 extchat.c:1425
 #, c-format
 msgid "%s is not on channel <%s>."
 msgstr ""
 
-#: extchat.c:1331
+#: extchat.c:1340
 #, c-format
 msgid "CHAT: You are already on channel <%s>."
 msgstr ""
 
-#: extchat.c:1359
+#: extchat.c:1368
 msgid ""
 "CHAT: Warning: You don't meet channel join permissions! (joining anyway)"
 msgstr ""
 
-#: extchat.c:1366
+#: extchat.c:1375
 #, c-format
 msgid "CHAT: You join channel <%s>."
 msgstr ""
 
-#: extchat.c:1389
+#: extchat.c:1397
 msgid "Guests are not allowed to leave channels."
 msgstr ""
 
-#: extchat.c:1396
+#: extchat.c:1404
 #, c-format
 msgid "CHAT: You are not on channel <%s>."
 msgstr ""
 
-#: extchat.c:1415
+#: extchat.c:1422
 #, c-format
 msgid "CHAT: You leave channel <%s>."
 msgstr ""
 
-#: extchat.c:1492
+#: extchat.c:1499
 msgid "Don't you have anything to say?"
 msgstr ""
 
-#: extchat.c:1505
+#: extchat.c:1512
 msgid "CHAT: You may wish to set the CHAN_USEFIRSTMATCH flag on yourself."
 msgstr ""
 
-#: extchat.c:1515
+#: extchat.c:1522
 msgid "CHAT: No such channel."
 msgstr ""
 
-#: extchat.c:1539 extchat.c:1635
+#: extchat.c:1546 extchat.c:1642
 #, c-format
 msgid "Sorry, you're not the right type to be on channel <%s>."
 msgstr ""
 
-#: extchat.c:1546
+#: extchat.c:1553
 #, c-format
 msgid "Sorry, you're not allowed to speak on channel <%s>."
 msgstr ""
 
-#: extchat.c:1549 extchat.c:2917
+#: extchat.c:1556 extchat.c:2958
 msgid "No such channel."
 msgstr ""
 
-#: extchat.c:1557 extchat.c:1650
+#: extchat.c:1564 extchat.c:1657
 msgid "You must be on that channel to speak on it."
 msgstr ""
 
-#: extchat.c:1560 extchat.c:1653
+#: extchat.c:1567 extchat.c:1660
 msgid "You must stop gagging that channel to speak on it."
 msgstr ""
 
-#: extchat.c:1566
+#: extchat.c:1573
 msgid "What do you want to say to that channel?"
 msgstr ""
 
-#: extchat.c:1608
+#: extchat.c:1615
 msgid "That is not a valid channel."
 msgstr ""
 
-#: extchat.c:1613
+#: extchat.c:1620
 msgid "I don't recognize that channel."
 msgstr ""
 
-#: extchat.c:1616
+#: extchat.c:1623
 msgid "I don't know which channel you mean."
 msgstr ""
 
-#: extchat.c:1641
+#: extchat.c:1648
 #, c-format
 msgid "Sorry, you're not allowed to @cemit on channel <%s>."
 msgstr ""
 
-#: extchat.c:1659
+#: extchat.c:1666
 msgid "What do you want to emit?"
 msgstr ""
 
-#: extchat.c:1667
+#: extchat.c:1674
 #, c-format
 msgid "Cemit to channel %s: %s"
 msgstr ""
 
-#: extchat.c:1693 extchat.c:2055
+#: extchat.c:1700 extchat.c:2063
 msgid "You must specify a channel."
 msgstr ""
 
-#: extchat.c:1697
+#: extchat.c:1704
 msgid "Guests may not modify channels."
 msgstr ""
 
-#: extchat.c:1712
+#: extchat.c:1719
 msgid "No more room for channels."
 msgstr ""
 
-#: extchat.c:1716
+#: extchat.c:1723
 msgid "The channel needs a shorter name."
 msgstr ""
 
-#: extchat.c:1720
+#: extchat.c:1727
 msgid "Invalid name for a channel."
 msgstr ""
 
-#: extchat.c:1724
+#: extchat.c:1731
 msgid "You already own too many channels."
 msgstr ""
 
-#: extchat.c:1729
+#: extchat.c:1736
 msgid "CHAT: The channel needs a more unique name."
 msgstr ""
 
-#: extchat.c:1738
+#: extchat.c:1745
 msgid "You can't create channels of that type."
 msgstr ""
 
-#: extchat.c:1742
+#: extchat.c:1749
 msgid "Warning: channel will be created disabled."
 msgstr ""
 
-#: extchat.c:1745
+#: extchat.c:1752
 #, c-format
 msgid "You can't afford the %d %s."
 msgstr ""
 
-#: extchat.c:1752 extchat.c:1759
+#: extchat.c:1759 extchat.c:1766
 msgid "CHAT: No more memory for channels!"
 msgstr ""
 
-#: extchat.c:1771
+#: extchat.c:1778
 #, c-format
 msgid "CHAT: Channel <%s> created."
 msgstr ""
 
-#: extchat.c:1788
+#: extchat.c:1795
 msgid "Channel removed."
 msgstr ""
 
-#: extchat.c:1803
+#: extchat.c:1810
 msgid "The channel needs a more unique new name."
 msgstr ""
 
-#: extchat.c:1808
+#: extchat.c:1815
 msgid "That name is too long."
 msgstr ""
 
-#: extchat.c:1816
+#: extchat.c:1823
 #, c-format
 msgid "has renamed %s to %s."
 msgstr ""
 
-#: extchat.c:1820
+#: extchat.c:1827
 msgid "Channel renamed."
 msgstr ""
 
-#: extchat.c:1831
+#: extchat.c:1838
 msgid "You can't make channels that type."
 msgstr ""
 
-#: extchat.c:1835
+#: extchat.c:1842
 msgid "Warning: channel will be disabled."
 msgstr ""
 
-#: extchat.c:1839
+#: extchat.c:1846
 #, c-format
 msgid "Invalid or same permissions on channel <%s>. No changes made."
 msgstr ""
 
-#: extchat.c:1844
+#: extchat.c:1851
 #, c-format
 msgid "Permissions on channel <%s> changed."
 msgstr ""
 
-#: extchat.c:1904
+#: extchat.c:1911
 msgid "Only players can use that option."
 msgstr ""
 
-#: extchat.c:1911
+#: extchat.c:1918
 msgid "You are not on any channels."
 msgstr ""
 
-#: extchat.c:1917
+#: extchat.c:1924
 msgid "All channels have been muted."
 msgstr ""
 
-#: extchat.c:1918
+#: extchat.c:1925
 msgid "All channels have been unmuted."
 msgstr ""
 
-#: extchat.c:1921
+#: extchat.c:1928
 msgid "You hide on all the channels you can."
 msgstr ""
 
-#: extchat.c:1922
+#: extchat.c:1929
 msgid "You unhide on all channels."
 msgstr ""
 
-#: extchat.c:1925
+#: extchat.c:1932
 msgid "All channels have been gagged."
 msgstr ""
 
-#: extchat.c:1926
+#: extchat.c:1933
 msgid "All channels have been ungagged."
 msgstr ""
 
-#: extchat.c:1929
+#: extchat.c:1936
 msgid "All channels have been combined."
 msgstr ""
 
-#: extchat.c:1930
+#: extchat.c:1937
 msgid "All channels have been uncombined."
 msgstr ""
 
-#: extchat.c:1951 extchat.c:2062
+#: extchat.c:1958 extchat.c:2070
 #, c-format
 msgid "You are not on channel <%s>."
 msgstr ""
 
-#: extchat.c:1963
+#: extchat.c:1970
 #, c-format
 msgid "You will no longer hear connection messages on channel <%s>."
 msgstr ""
 
-#: extchat.c:1970
+#: extchat.c:1977
 #, c-format
 msgid "You will now hear connection messages on channel <%s>."
 msgstr ""
 
-#: extchat.c:1981
+#: extchat.c:1988
 #, c-format
 msgid "You are not permitted to hide on channel <%s>."
 msgstr ""
 
-#: extchat.c:1988
+#: extchat.c:1995
 #, c-format
 msgid "You no longer appear on channel <%s>'s who list."
 msgstr ""
 
-#: extchat.c:1995
+#: extchat.c:2002
 #, c-format
 msgid "You now appear on channel <%s>'s who list."
 msgstr ""
 
-#: extchat.c:2006
+#: extchat.c:2013
 #, c-format
 msgid "You will no longer hear messages on channel <%s>."
 msgstr ""
 
-#: extchat.c:2012
+#: extchat.c:2019
 #, c-format
 msgid "You will now hear messages on channel <%s>."
 msgstr ""
 
-#: extchat.c:2023
+#: extchat.c:2030
 #, c-format
 msgid "Connect messages on channel <%s> will now be combined with others."
 msgstr ""
 
-#: extchat.c:2029
+#: extchat.c:2037
 #, c-format
 msgid ""
 "Connect messages on channel <%s> will no longer be combined with others."
 msgstr ""
 
-#: extchat.c:2068
+#: extchat.c:2076
 #, c-format
 msgid "You have no title set on <%s>."
 msgstr ""
 
-#: extchat.c:2070
+#: extchat.c:2078
 #, c-format
 msgid "Your title on <%s> is '%s'."
 msgstr ""
 
-#: extchat.c:2079
+#: extchat.c:2089
+#, c-format
+msgid "Title cleared for %schannel <%s>."
+msgstr ""
+
+#: extchat.c:2095
 msgid "Title too long."
 msgstr ""
 
-#: extchat.c:2086
+#: extchat.c:2102
 msgid "Invalid character in title."
 msgstr ""
 
-#: extchat.c:2093
+#: extchat.c:2112
 #, c-format
-msgid "Title %s for %schannel <%s>."
+msgid "Title set for %schannel <%s>."
 msgstr ""
 
-#: extchat.c:2121 flags.c:2041 malias.c:278
+#: extchat.c:2139 flags.c:2046 malias.c:278
 msgid "Name"
 msgstr ""
 
-#: extchat.c:2121
+#: extchat.c:2139
 msgid "Users"
 msgstr ""
 
-#: extchat.c:2121
+#: extchat.c:2139
 msgid "Msgs"
 msgstr ""
 
-#: extchat.c:2121
+#: extchat.c:2139
 msgid "Chan Type"
 msgstr ""
 
-#: extchat.c:2121
+#: extchat.c:2139
 msgid "Status"
 msgstr ""
 
-#: extchat.c:2122
+#: extchat.c:2140
 msgid "Buf"
 msgstr ""
 
-#: extchat.c:2171
+#: extchat.c:2189
 msgid "Gag"
 msgstr ""
 
-#: extchat.c:2171
+#: extchat.c:2189
 msgid "On"
 msgstr ""
 
-#: extchat.c:2171
+#: extchat.c:2189
 msgid "Off"
 msgstr ""
 
-#: extchat.c:2218 extchat.c:2265 extchat.c:2314 extchat.c:2370 extchat.c:2424
-#: extchat.c:2468
+#: extchat.c:2236 extchat.c:2283 extchat.c:2332 extchat.c:2388 extchat.c:2442
+#: extchat.c:2486 extchat.c:2508
 msgid "#-1 NO CHANNEL GIVEN"
 msgstr ""
 
-#: extchat.c:2223 extchat.c:2230 extchat.c:2270 extchat.c:2277 extchat.c:2336
-#: extchat.c:2375 extchat.c:2387 extchat.c:2429 extchat.c:2441 extchat.c:2473
-#: extchat.c:3256 extchat.c:3343 extchat.c:3385
+#: extchat.c:2241 extchat.c:2248 extchat.c:2288 extchat.c:2295 extchat.c:2354
+#: extchat.c:2393 extchat.c:2405 extchat.c:2447 extchat.c:2459 extchat.c:2491
+#: extchat.c:2513 extchat.c:3304 extchat.c:3391 extchat.c:3433
 msgid "#-1 NO SUCH CHANNEL"
 msgstr ""
 
-#: extchat.c:2226 extchat.c:2273 extchat.c:2339 extchat.c:2378 extchat.c:2432
-#: extchat.c:2476
+#: extchat.c:2244 extchat.c:2291 extchat.c:2357 extchat.c:2396 extchat.c:2450
+#: extchat.c:2494 extchat.c:2516
 msgid "#-1 AMBIGUOUS CHANNEL NAME"
 msgstr ""
 
-#: extchat.c:2251 extchat.c:2395
+#: extchat.c:2269 extchat.c:2413
 msgid "#-1 NOT ON CHANNEL"
 msgstr ""
 
-#: extchat.c:2319
+#: extchat.c:2337
 msgid "#-1 NO TEXT GIVEN"
 msgstr ""
 
-#: extchat.c:2347
+#: extchat.c:2365
 msgid "#-1 CHANNEL DOES NOT HAVE A BUFFER"
 msgstr ""
 
-#: extchat.c:2500
+#: extchat.c:2541
 #, c-format
 msgid "CHAT: %s has removed all users from <%s>."
 msgstr ""
 
-#: extchat.c:2523
+#: extchat.c:2564
 msgid "CHAT: Wipe that silly grin off your face instead."
 msgstr ""
 
-#: extchat.c:2528
+#: extchat.c:2569
 #, c-format
 msgid "CHAT: Channel <%s> wiped."
 msgstr ""
 
-#: extchat.c:2550
+#: extchat.c:2591
 msgid "CHAT: Only a channel modifier can do that."
 msgstr ""
 
-#: extchat.c:2558 extchat.c:3222 match.c:485 set.c:584
+#: extchat.c:2599 extchat.c:3270 match.c:378 match.c:531 set.c:613
 msgid "I can't see that here."
 msgstr ""
 
-#: extchat.c:2560 extchat.c:3224
+#: extchat.c:2601 extchat.c:3272
 msgid "I don't know which thing you mean."
 msgstr ""
 
-#: extchat.c:2565
+#: extchat.c:2606
 #, c-format
 msgid "CHAT: Channel <%s> no longer mogrified by %s."
 msgstr ""
 
-#: extchat.c:2571
+#: extchat.c:2612
 #, c-format
 msgid "CHAT: Channel <%s> isn't being mogrified."
 msgstr ""
 
-#: extchat.c:2577
+#: extchat.c:2618
 msgid "CHAT: You must control the mogrifier."
 msgstr ""
 
-#: extchat.c:2582
+#: extchat.c:2623
 #, c-format
 msgid "CHAT: Channel <%s> now mogrified by %s."
 msgstr ""
 
-#: extchat.c:2603
+#: extchat.c:2644
 msgid "CHAT: Only a Wizard can do that."
 msgstr ""
 
-#: extchat.c:2610
+#: extchat.c:2651
 msgid "CHAT: Invalid owner."
 msgstr ""
 
-#: extchat.c:2618
+#: extchat.c:2659
 #, c-format
 msgid "CHAT: Channel <%s> now owned by %s."
 msgstr ""
 
-#: extchat.c:2672
+#: extchat.c:2713
 #, c-format
 msgid "CHAT: Channel <%s> resists."
 msgstr ""
 
-#: extchat.c:2702
+#: extchat.c:2743
 msgid "CHAT: I don't understand that key."
 msgstr ""
 
-#: extchat.c:2711
+#: extchat.c:2752
 #, c-format
 msgid "CHAT: Joinlock on <%s> reset."
 msgstr ""
 
-#: extchat.c:2712
+#: extchat.c:2753
 #, c-format
 msgid "CHAT: Joinlock on <%s> set."
 msgstr ""
 
-#: extchat.c:2718
+#: extchat.c:2759
 #, c-format
 msgid "CHAT: Speaklock on <%s> reset."
 msgstr ""
 
-#: extchat.c:2719
+#: extchat.c:2760
 #, c-format
 msgid "CHAT: Speaklock on <%s> set."
 msgstr ""
 
-#: extchat.c:2725
+#: extchat.c:2766
 #, c-format
 msgid "CHAT: Seelock on <%s> reset."
 msgstr ""
 
-#: extchat.c:2726
+#: extchat.c:2767
 #, c-format
 msgid "CHAT: Seelock on <%s> set."
 msgstr ""
 
-#: extchat.c:2732
+#: extchat.c:2773
 #, c-format
 msgid "CHAT: Hidelock on <%s> reset."
 msgstr ""
 
-#: extchat.c:2733
+#: extchat.c:2774
 #, c-format
 msgid "CHAT: Hidelock on <%s> set."
 msgstr ""
 
-#: extchat.c:2739
+#: extchat.c:2780
 #, c-format
 msgid "CHAT: Modlock on <%s> reset."
 msgstr ""
 
-#: extchat.c:2740
+#: extchat.c:2781
 #, c-format
 msgid "CHAT: Modlock on <%s> set."
 msgstr ""
 
-#: extchat.c:2767
+#: extchat.c:2808
 #, c-format
 msgid "Description: %s"
 msgstr ""
 
-#: extchat.c:2768
+#: extchat.c:2809
 #, c-format
 msgid "Owner: %s"
 msgstr ""
 
-#: extchat.c:2770
+#: extchat.c:2811
 #, c-format
 msgid "Mogrifier: %s (#%d)"
 msgstr ""
 
-#: extchat.c:2773
+#: extchat.c:2814
 #, c-format
 msgid "Flags: %s"
 msgstr ""
 
-#: extchat.c:2777
+#: extchat.c:2818
 #, c-format
 msgid "Recall buffer: %dk, with %d lines stored."
 msgstr ""
 
-#: extchat.c:2816
+#: extchat.c:2857
 #, c-format
 msgid "CHAT: You don't have permission to decompile <%s>."
 msgstr ""
 
-#: extchat.c:2865
+#: extchat.c:2906
 msgid "CHAT: No channel matches that string."
 msgstr ""
 
-#: extchat.c:2882 look.c:204 speech.c:373 speech.c:992
+#: extchat.c:2923 look.c:204 speech.c:394 speech.c:875 speech.c:1035
 msgid "and"
 msgstr ""
 
-#: extchat.c:2896
+#: extchat.c:2937
 msgid "There are no connected players on that channel."
 msgstr ""
 
-#: extchat.c:2898
+#: extchat.c:2939
 #, c-format
 msgid "Members of channel <%s> are:"
 msgstr ""
 
-#: extchat.c:2920
+#: extchat.c:2961
 msgid "I can't tell which channel you mean."
 msgstr ""
 
-#: extchat.c:2934 function.c:868
+#: extchat.c:2975 function.c:871
 msgid "#-1 INVALID ARGUMENT"
 msgstr ""
 
-#: extchat.c:2956
+#: extchat.c:2997
 msgid "#-1 NO PERMISSIONS FOR CHANNEL"
 msgstr ""
 
-#: extchat.c:2999
+#: extchat.c:3040
 msgid "CHAT: New description too long."
 msgstr ""
 
-#: extchat.c:3012
+#: extchat.c:3053
 #, c-format
 msgid "CHAT: Channel <%s> description cleared."
 msgstr ""
 
-#: extchat.c:3016
+#: extchat.c:3057
 #, c-format
 msgid "CHAT: Channel <%s> description set."
 msgstr ""
 
-#: extchat.c:3169
+#: extchat.c:3217
 msgid "Channels:"
 msgstr ""
 
-#: extchat.c:3175
+#: extchat.c:3223
 msgid "Channels: *NONE*"
 msgstr ""
 
-#: extchat.c:3259
+#: extchat.c:3307
 msgid "#-2 AMBIGUOUS CHANNEL MATCH"
 msgstr ""
 
-#: extchat.c:3281
+#: extchat.c:3329
 msgid "#-1 NO SUCH LOCK TYPE"
 msgstr ""
 
-#: extchat.c:3396
+#: extchat.c:3444
 msgid "#-1 NO RECALL BUFFER"
 msgstr ""
 
-#: extchat.c:3535
+#: extchat.c:3586
 msgid "You must specify a type of lock!"
 msgstr ""
 
-#: extchat.c:3815
+#: extchat.c:3866
 #, c-format
 msgid "To channel %s: %s"
 msgstr ""
 
-#: extchat.c:3855
+#: extchat.c:3906
 msgid "Which line do you want to start recall from?"
 msgstr ""
 
-#: extchat.c:3869 extchat.c:3877
+#: extchat.c:3920 extchat.c:3928
 msgid "How many lines did you want to recall?"
 msgstr ""
 
-#: extchat.c:3894
+#: extchat.c:3945
 msgid "CHAT: You must be able to join a channel to recall from it."
 msgstr ""
 
-#: extchat.c:3898
+#: extchat.c:3949
 msgid "CHAT: That channel doesn't have a recall buffer."
 msgstr ""
 
-#: extchat.c:3913
+#: extchat.c:3964
 msgid "CHAT: Nothing to recall."
 msgstr ""
 
-#: extchat.c:3917
+#: extchat.c:3968
 #, c-format
 msgid "CHAT: Recall from channel <%s>"
 msgstr ""
 
-#: extchat.c:3944
+#: extchat.c:3995
 msgid "CHAT: End recall"
 msgstr ""
 
-#: extchat.c:3948
+#: extchat.c:3999
 #, c-format
 msgid "CHAT: To recall the entire buffer, use @chan/recall %s=0"
 msgstr ""
 
-#: extchat.c:3970
+#: extchat.c:4021
 msgid "You need to specify the number of lines to buffer."
 msgstr ""
 
-#: extchat.c:3975
+#: extchat.c:4026
 msgid "Invalid buffer size."
 msgstr ""
 
-#: extchat.c:3990
+#: extchat.c:4041
 #, c-format
 msgid "CHAT: Channel buffering disabled for channel <%s>."
 msgstr ""
 
-#: extchat.c:3995
+#: extchat.c:4046
 #, c-format
 msgid "CHAT: Channel buffering already disabled for channel <%s>."
 msgstr ""
 
-#: extchat.c:4003
+#: extchat.c:4054
 #, c-format
 msgid "CHAT: Resizing buffer of channel <%s>"
 msgstr ""
 
-#: extchat.c:4008
+#: extchat.c:4059
 #, c-format
 msgid "CHAT: Buffering enabled on channel <%s>."
 msgstr ""
 
-#: extmail.c:222 extmail.c:1218
+#: extmail.c:222 extmail.c:1230
 msgid "(no subject)"
 msgstr ""
 
@@ -2840,7 +2846,7 @@
 msgid "Failed attempt to forward @mail to #%d"
 msgstr ""
 
-#: extmail.c:1152 extmail.c:1294
+#: extmail.c:1152 extmail.c:1307
 #, c-format
 msgid "MAIL: You sent your message to %s."
 msgstr ""
@@ -2850,570 +2856,575 @@
 msgid "MAIL: Your message was not sent to %s due to a mail forwarding problem."
 msgstr ""
 
-#: extmail.c:1178
+#: extmail.c:1190
 msgid "MAIL: You cannot send mail to non-existent people."
 msgstr ""
 
-#: extmail.c:1183
+#: extmail.c:1195
 msgid "MAIL: You probably don't wanna send mail saying 'clear'."
 msgstr ""
 
-#: extmail.c:1189
+#: extmail.c:1201
 #, c-format
 msgid "MAIL: %s is not accepting mail from you right now."
 msgstr ""
 
-#: extmail.c:1196
+#: extmail.c:1208
 #, c-format
 msgid "MAIL: %s's mailbox is full. Can't send."
 msgstr ""
 
-#: extmail.c:1296
+#: extmail.c:1311
+#, c-format
+msgid "MAIL: You sent your message to %s, but they can't mail you!"
+msgstr ""
+
+#: extmail.c:1316
 #, c-format
 msgid "MAIL: You have a new message (%d) from %s."
 msgstr ""
 
-#: extmail.c:1319
+#: extmail.c:1339
 msgid "The postal service issues a warrant for your arrest."
 msgstr ""
 
-#: extmail.c:1336
+#: extmail.c:1356
 msgid "You annihilate the post office. All messages cleared."
 msgstr ""
 
-#: extmail.c:1353
+#: extmail.c:1373
 msgid "Go get some bugspray."
 msgstr ""
 
-#: extmail.c:1360 extmail.c:1460 extmail.c:1860 wiz.c:728
+#: extmail.c:1380 extmail.c:1480 extmail.c:1880 wiz.c:744
 #, c-format
 msgid "%s: No such player."
 msgstr ""
 
-#: extmail.c:1365
+#: extmail.c:1385
 #, c-format
 msgid "Mail cleared for %s(#%d)."
 msgstr ""
 
-#: extmail.c:1370
+#: extmail.c:1390
 #, c-format
 msgid "Bad object #%d has mail."
 msgstr ""
 
-#: extmail.c:1372
+#: extmail.c:1392
 #, c-format
 msgid "%s(#%d) has mail but is not a player."
 msgstr ""
 
-#: extmail.c:1378
+#: extmail.c:1398
 #, c-format
 msgid "Mail database top is %d, actual message count is %d. Fixing."
 msgstr ""
 
-#: extmail.c:1382
+#: extmail.c:1402
 msgid "Mail sanity check completed."
 msgstr ""
 
-#: extmail.c:1386
+#: extmail.c:1406
 #, c-format
 msgid "Fixing mail for #%d."
 msgstr ""
 
-#: extmail.c:1417
+#: extmail.c:1437
 msgid "Mail sanity fix completed."
 msgstr ""
 
-#: extmail.c:1419
+#: extmail.c:1439
 msgid "That is not a debugging option."
 msgstr ""
 
-#: extmail.c:1464 extmail.c:1864
+#: extmail.c:1484 extmail.c:1884
 msgid "The post office protects privacy!"
 msgstr ""
 
-#: extmail.c:1472
+#: extmail.c:1492
 #, c-format
 msgid "There are %d messages in the mail spool."
 msgstr ""
 
-#: extmail.c:1485
+#: extmail.c:1505
 #, c-format
 msgid "MAIL: There are %d msgs in the mail spool, %d unread, %d cleared."
 msgstr ""
 
-#: extmail.c:1503
+#: extmail.c:1523
 #, c-format
 msgid "MAIL: There are %d old msgs in the mail spool, totalling %d characters."
 msgstr ""
 
-#: extmail.c:1507
+#: extmail.c:1527
 #, c-format
 msgid "MAIL: There are %d new msgs in the mail spool, totalling %d characters."
 msgstr ""
 
-#: extmail.c:1511
+#: extmail.c:1531
 #, c-format
 msgid ""
 "MAIL: There are %d cleared msgs in the mail spool, totalling %d characters."
 msgstr ""
 
-#: extmail.c:1526
+#: extmail.c:1546
 #, c-format
 msgid "%s sent %d messages."
 msgstr ""
 
-#: extmail.c:1527
+#: extmail.c:1547
 #, c-format
 msgid "%s has %d messages."
 msgstr ""
 
-#: extmail.c:1556
+#: extmail.c:1576
 #, c-format
 msgid "Mail statistics for %s:"
 msgstr ""
 
-#: extmail.c:1559
+#: extmail.c:1579
 #, c-format
 msgid "%d messages sent, %d unread, %d cleared."
 msgstr ""
 
-#: extmail.c:1561
+#: extmail.c:1581
 #, c-format
 msgid "%d messages received, %d unread, %d cleared."
 msgstr ""
 
-#: extmail.c:1566
+#: extmail.c:1586
 #, c-format
 msgid "%d messages sent, %d unread, %d cleared, totalling %d characters."
 msgstr ""
 
-#: extmail.c:1570
+#: extmail.c:1590
 #, c-format
 msgid "%d messages received, %d unread, %d cleared, totalling %d characters."
 msgstr ""
 
-#: extmail.c:1575
+#: extmail.c:1595
 #, c-format
 msgid "Last is dated %s"
 msgstr ""
 
-#: extmail.c:1600
+#: extmail.c:1620
 msgid "MAIL: Invalid mail command."
 msgstr ""
 
-#: extmail.c:1664 extmail.c:1681 funcrypt.c:332
+#: extmail.c:1684 extmail.c:1701 funcrypt.c:332
 msgid "#-1 NO SUCH PLAYER"
 msgstr ""
 
-#: extmail.c:1688
+#: extmail.c:1708
 msgid "#-1 FOLDER MUST BE INTEGER"
 msgstr ""
 
-#: extmail.c:1748
+#: extmail.c:1768
 msgid "#-1 INVALID MESSAGE OR PLAYER"
 msgstr ""
 
-#: extmail.c:1779
+#: extmail.c:1799
 msgid "Permission denied"
 msgstr ""
 
-#: extmail.c:1785
+#: extmail.c:1805
 msgid "Invalid message specification"
 msgstr ""
 
-#: extmail.c:1838
+#: extmail.c:1858
 msgid "#-? fun_mailstats called with invalid called_as!"
 msgstr ""
 
-#: extmail.c:2533 extmail.c:2630
+#: extmail.c:2551 extmail.c:2650
 msgid "MAIL: Invalid message specification"
 msgstr ""
 
-#: extmail.c:2541 extmail.c:2551 extmail.c:2558 extmail.c:2568 extmail.c:2575
-#: extmail.c:2585
+#: extmail.c:2561 extmail.c:2571 extmail.c:2578 extmail.c:2588 extmail.c:2595
+#: extmail.c:2605
 msgid "MAIL: Invalid age"
 msgstr ""
 
-#: extmail.c:2545 extmail.c:2562 extmail.c:2579
+#: extmail.c:2565 extmail.c:2582 extmail.c:2599
 msgid "MAIL: Message ages must be integers"
 msgstr ""
 
-#: extmail.c:2591 extmail.c:2596
+#: extmail.c:2611 extmail.c:2616
 msgid "MAIL: Invalid dbref #"
 msgstr ""
 
-#: extmail.c:2603 extmail.c:2608
+#: extmail.c:2623 extmail.c:2628
 msgid "MAIL: Invalid player"
 msgstr ""
 
-#: extmail.c:2664
+#: extmail.c:2684
 msgid "Read "
 msgstr ""
 
-#: extmail.c:2666
+#: extmail.c:2686
 msgid "Unread "
 msgstr ""
 
-#: extmail.c:2668
+#: extmail.c:2688
 msgid "Cleared "
 msgstr ""
 
-#: extmail.c:2670
+#: extmail.c:2690
 msgid "Urgent "
 msgstr ""
 
-#: extmail.c:2672
+#: extmail.c:2692
 msgid "Mass "
 msgstr ""
 
-#: extmail.c:2674
+#: extmail.c:2694
 msgid "Fwd "
 msgstr ""
 
-#: extmail.c:2676
+#: extmail.c:2696
 msgid "Tagged"
 msgstr ""
 
-#: extmail.c:2702 extmail.c:2736
+#: extmail.c:2722 extmail.c:2756
 #, c-format
 msgid "MAIL: %d messages in folder %d [%s] (%d unread, %d cleared)."
 msgstr ""
 
-#: extmail.c:2707 extmail.c:2741
+#: extmail.c:2727 extmail.c:2761
 #, c-format
 msgid "MAIL: Warning! Limit on inbox messages is %d!"
 msgstr ""
 
-#: extmail.c:2713 extmail.c:2739
+#: extmail.c:2733 extmail.c:2759
 msgid ""
 "\n"
 "MAIL: You have no mail.\n"
 msgstr ""
 
-#: extmail.c:2885
+#: extmail.c:2905
 #, c-format
 msgid "You sent your message to the '%s' alias"
 msgstr ""
 
-#: flags.c:1334
+#: flags.c:1339
 msgid "You can't make admin into guests."
 msgstr ""
 
-#: flags.c:1364
+#: flags.c:1369
 msgid "You must @lock/zone before you can set a player ZONE"
 msgstr ""
 
-#: flags.c:1453
+#: flags.c:1458
 msgid "Type: "
 msgstr ""
 
-#: flags.c:1455
+#: flags.c:1460
 msgid " Flags: "
 msgstr ""
 
-#: flags.c:1535 flags.c:1699
+#: flags.c:1540 flags.c:1704
 #, c-format
 msgid "Internal error: Unable to find flagspace '%s'!"
 msgstr ""
 
-#: flags.c:1540
+#: flags.c:1545
 #, c-format
 msgid "%s - I don't recognize that flag."
 msgstr ""
 
-#: flags.c:1566 flags.c:1575
+#: flags.c:1571 flags.c:1580
 #, c-format
 msgid "%s is no longer listening."
 msgstr ""
 
-#: flags.c:1584
+#: flags.c:1589
 #, c-format
 msgid "Exit %s is no longer broadcasting."
 msgstr ""
 
-#: flags.c:1592
+#: flags.c:1597
 msgid "Audible exits in this room have been deactivated."
 msgstr ""
 
-#: flags.c:1598
+#: flags.c:1603
 msgid "This room is no longer broadcasting."
 msgstr ""
 
-#: flags.c:1599
+#: flags.c:1604
 msgid "Your contents can no longer be heard from outside."
 msgstr ""
 
-#: flags.c:1609 flags.c:1670
+#: flags.c:1614 flags.c:1675
 msgid " (already)"
 msgstr ""
 
-#: flags.c:1610
+#: flags.c:1615
 msgid " reset."
 msgstr ""
 
-#: flags.c:1620
+#: flags.c:1625
 msgid "Warning: Setting trust flag on zoned object"
 msgstr ""
 
-#: flags.c:1627 flags.c:1636
+#: flags.c:1632 flags.c:1641
 #, c-format
 msgid "%s is now listening."
 msgstr ""
 
-#: flags.c:1646
+#: flags.c:1651
 #, c-format
 msgid "Exit %s is now broadcasting."
 msgstr ""
 
-#: flags.c:1654
+#: flags.c:1659
 msgid "Audible exits in this room have been activated."
 msgstr ""
 
-#: flags.c:1659
+#: flags.c:1664
 msgid "This room is now broadcasting."
 msgstr ""
 
-#: flags.c:1660
+#: flags.c:1665
 msgid "Your contents can now be heard from outside."
 msgstr ""
 
-#: flags.c:1671
+#: flags.c:1676
 msgid " set."
 msgstr ""
 
-#: flags.c:1705
+#: flags.c:1710
 #, c-format
 msgid "%s - I don't recognize that power."
 msgstr ""
 
-#: flags.c:1722
+#: flags.c:1727
 #, c-format
 msgid "%s - %s removed."
 msgstr ""
 
-#: flags.c:1724
+#: flags.c:1729
 #, c-format
 msgid "%s - %s (already) removed."
 msgstr ""
 
-#: flags.c:1729
+#: flags.c:1734
 #, c-format
 msgid "%s - %s (already) granted."
 msgstr ""
 
-#: flags.c:1732
+#: flags.c:1737
 #, c-format
 msgid "%s - %s granted."
 msgstr ""
 
-#: flags.c:1741
+#: flags.c:1746
 msgid "CLEARED"
 msgstr ""
 
-#: flags.c:1741
+#: flags.c:1746
 msgid "SET"
 msgstr ""
 
-#: flags.c:2038 flags.c:2079 flags.c:2142
+#: flags.c:2043 flags.c:2084 flags.c:2147
 #, c-format
 msgid "No such %s."
 msgstr ""
 
-#: flags.c:2042
+#: flags.c:2047
 msgid "Character"
 msgstr ""
 
-#: flags.c:2043
+#: flags.c:2048
 msgid "Aliases"
 msgstr ""
 
-#: flags.c:2044
+#: flags.c:2049
 msgid "Type(s)"
 msgstr ""
 
-#: flags.c:2046
+#: flags.c:2051
 msgid "Perms"
 msgstr ""
 
-#: flags.c:2048
+#: flags.c:2053
 msgid "ResetPrms"
 msgstr ""
 
-#: flags.c:2074 flags.c:2137 flags.c:2203
+#: flags.c:2079 flags.c:2142 flags.c:2208
 msgid "You don't have enough magic for that."
 msgstr ""
 
-#: flags.c:2083
+#: flags.c:2088
 #, c-format
 msgid "How do you want to restrict that %s?"
 msgstr ""
 
-#: flags.c:2111
+#: flags.c:2116
 #, c-format
 msgid "Permissions on %s %s set."
 msgstr ""
 
-#: flags.c:2146
+#: flags.c:2151
 #, c-format
 msgid "What type do you want to make that %s?"
 msgstr ""
 
-#: flags.c:2155 flags.c:2243
+#: flags.c:2160 flags.c:2248
 msgid "I don't understand the list of types."
 msgstr ""
 
-#: flags.c:2165
+#: flags.c:2170
 #, c-format
 msgid ""
 "Objects of other types already have this %s set. Search for them and remove "
 "it first."
 msgstr ""
 
-#: flags.c:2172
+#: flags.c:2177
 #, c-format
 msgid "Type of %s %s set."
 msgstr ""
 
-#: flags.c:2207
+#: flags.c:2212
 #, c-format
 msgid "You must provide a name for the %s."
 msgstr ""
 
-#: flags.c:2212
+#: flags.c:2217
 #, c-format
 msgid "%s names must be longer than one character."
 msgstr ""
 
-#: flags.c:2217
+#: flags.c:2222
 #, c-format
 msgid "%s names may not contain spaces."
 msgstr ""
 
-#: flags.c:2222
+#: flags.c:2227
 #, c-format
 msgid "That's not a valid %s name."
 msgstr ""
 
-#: flags.c:2228
+#: flags.c:2233
 msgid "You must provide more information."
 msgstr ""
 
-#: flags.c:2233 flags.c:2435
+#: flags.c:2238 flags.c:2440
 #, c-format
 msgid "%s characters must be single characters."
 msgstr ""
 
-#: flags.c:2250 flags.c:2441
+#: flags.c:2255 flags.c:2446
 #, c-format
 msgid "Letter conflicts with the %s %s."
 msgstr ""
 
-#: flags.c:2286
+#: flags.c:2291
 #, c-format
 msgid "Unknown failure adding %s."
 msgstr ""
 
-#: flags.c:2305 flags.c:2422 flags.c:2474 flags.c:2513 flags.c:2574
+#: flags.c:2310 flags.c:2427 flags.c:2479 flags.c:2518 flags.c:2579
 msgid "You don't look like God."
 msgstr ""
 
-#: flags.c:2309
+#: flags.c:2314
 msgid "You must provide a name for the alias."
 msgstr ""
 
-#: flags.c:2317
+#: flags.c:2322
 #, c-format
 msgid "%s aliases must be longer than one character."
 msgstr ""
 
-#: flags.c:2322
+#: flags.c:2327
 #, c-format
 msgid "%s aliases may not contain spaces."
 msgstr ""
 
-#: flags.c:2328
+#: flags.c:2333
 #, c-format
 msgid "Internal error: Unknown flag space '%s'!"
 msgstr ""
 
-#: flags.c:2334
+#: flags.c:2339
 #, c-format
 msgid "That alias already matches the %s %s."
 msgstr ""
 
-#: flags.c:2340 flags.c:2428 flags.c:2480 flags.c:2523 flags.c:2580
+#: flags.c:2345 flags.c:2433 flags.c:2485 flags.c:2528 flags.c:2585
 #, c-format
 msgid "I don't know that %s."
 msgstr ""
 
-#: flags.c:2344
+#: flags.c:2349
 #, c-format
 msgid "That %s is disabled."
 msgstr ""
 
-#: flags.c:2348
+#: flags.c:2353
 #, c-format
 msgid "That isn't an alias of the %s %s."
 msgstr ""
 
-#: flags.c:2355
+#: flags.c:2360
 #, c-format
 msgid "That's the %s's name, not an alias."
 msgstr ""
 
-#: flags.c:2361
+#: flags.c:2366
 msgid "Unknown failure deleting alias."
 msgstr ""
 
-#: flags.c:2369
+#: flags.c:2374
 msgid "Unknown failure adding alias."
 msgstr ""
 
-#: flags.c:2447
+#: flags.c:2452
 #, c-format
 msgid "Letter for %s %s set to '%c'."
 msgstr ""
 
-#: flags.c:2451
+#: flags.c:2456
 #, c-format
 msgid "Letter for %s %s cleared."
 msgstr ""
 
-#: flags.c:2484
+#: flags.c:2489
 #, c-format
 msgid "That %s is already disabled."
 msgstr ""
 
-#: flags.c:2489
+#: flags.c:2494
 #, c-format
 msgid "%s %s disabled."
 msgstr ""
 
-#: flags.c:2518
+#: flags.c:2523
 #, c-format
 msgid "Internal error: Unknown flagspace '%s'!"
 msgstr ""
 
-#: flags.c:2527
+#: flags.c:2532
 msgid "There are probably easier ways to crash your MUSH."
 msgstr ""
 
-#: flags.c:2553
+#: flags.c:2558
 #, c-format
 msgid "%s %s deleted."
 msgstr ""
 
-#: flags.c:2584
+#: flags.c:2589
 #, c-format
 msgid "That %s is not disabled."
 msgstr ""
 
-#: flags.c:2589
+#: flags.c:2594
 #, c-format
 msgid "%s %s enabled."
 msgstr ""
 
-#: flags.c:2661
+#: flags.c:2666
 msgid " (disabled)"
 msgstr ""
 
@@ -3433,162 +3444,162 @@
 msgid "#-1 UNSUPPORTED DIGEST TYPE"
 msgstr ""
 
-#: function.c:283
+#: function.c:283 fundb.c:1467
 msgid "#-1 SEPARATOR MUST BE ONE CHARACTER"
 msgstr ""
 
-#: function.c:839
+#: function.c:842
 #, c-format
 msgid "Functions: %s"
 msgstr ""
 
-#: function.c:1043 function.c:1081
+#: function.c:1046 function.c:1084
 msgid "There's already a function with that name."
 msgstr ""
 
-#: function.c:1048 function.c:1087 function.c:1526
+#: function.c:1051 function.c:1090 function.c:1532
 msgid "Invalid function name."
 msgstr ""
 
-#: function.c:1054 function.c:1673
+#: function.c:1057 function.c:1679
 msgid "That's not a builtin function."
 msgstr ""
 
-#: function.c:1060
+#: function.c:1063
 msgid "Function cloned."
 msgstr ""
 
-#: function.c:1095 function.c:1305 function.c:1712 function.c:1760
-#: function.c:1793
+#: function.c:1098 function.c:1308 function.c:1718 function.c:1766
+#: function.c:1799
 msgid "No such function."
 msgstr ""
 
-#: function.c:1102
+#: function.c:1105
 msgid "You cannot alias @functions."
 msgstr ""
 
-#: function.c:1109
+#: function.c:1112
 msgid "Alias added."
 msgstr ""
 
-#: function.c:1296
+#: function.c:1299
 msgid "Restrict what function?"
 msgstr ""
 
-#: function.c:1300
+#: function.c:1303
 msgid "Do what with the function?"
 msgstr ""
 
-#: function.c:1311
+#: function.c:1314
 msgid "Builtin function"
 msgstr ""
 
-#: function.c:1316
+#: function.c:1319
 msgid "Restrictions unchanged."
 msgstr ""
 
-#: function.c:1318
+#: function.c:1321
 msgid "Restrictions modified."
 msgstr ""
 
-#: function.c:1462
+#: function.c:1468
 msgid "No global user-defined functions exist."
 msgstr ""
 
-#: function.c:1473
+#: function.c:1479
 msgid "Function Name                   Dbref #    Attrib"
 msgstr ""
 
-#: function.c:1491
+#: function.c:1497
 msgid "User functions:"
 msgstr ""
 
-#: function.c:1520
+#: function.c:1526
 msgid "You must specify an object and an attribute."
 msgstr ""
 
-#: function.c:1537
+#: function.c:1543
 msgid "No permission to control object."
 msgstr ""
 
-#: function.c:1541
+#: function.c:1547
 msgid "No permission to examine object."
 msgstr ""
 
-#: function.c:1555
+#: function.c:1561
 msgid "Expected between 1 and 5 arguments."
 msgstr ""
 
-#: function.c:1591
+#: function.c:1597
 msgid "Function added."
 msgstr ""
 
-#: function.c:1596
+#: function.c:1602
 msgid "You cannot change that built-in function."
 msgstr ""
 
-#: function.c:1629
+#: function.c:1635
 msgid "Function updated."
 msgstr ""
 
-#: function.c:1666
+#: function.c:1672
 msgid "Restore what?"
 msgstr ""
 
-#: function.c:1678
+#: function.c:1684
 msgid "That function isn't deleted!"
 msgstr ""
 
-#: function.c:1683
+#: function.c:1689
 msgid "Restored."
 msgstr ""
 
-#: function.c:1719
+#: function.c:1725
 msgid "Function alias deleted."
 msgstr ""
 
-#: function.c:1723 function.c:1732
+#: function.c:1729 function.c:1738
 msgid "You can't delete that @function."
 msgstr ""
 
-#: function.c:1727 function.c:1737
+#: function.c:1733 function.c:1743
 msgid "Function deleted."
 msgstr ""
 
-#: function.c:1765
+#: function.c:1771
 msgid "You can't disable aliases."
 msgstr ""
 
-#: function.c:1826
+#: function.c:1832
 #, c-format
 msgid "Name      : %s() (%s%s)"
 msgstr ""
 
-#: function.c:1925
+#: function.c:1931
 #, c-format
 msgid "Flags     : %s"
 msgstr ""
 
-#: function.c:1929
+#: function.c:1935
 #, c-format
 msgid "Location  : #%d/%s\n"
 msgstr ""
 
-#: function.c:1937
+#: function.c:1943
 msgid "(Commas okay in last argument)"
 msgstr ""
 
-#: function.c:1943
+#: function.c:1949
 #, c-format
 msgid "Arguments : %d %s"
 msgstr ""
 
-#: function.c:1945
+#: function.c:1951
 #, c-format
 msgid "Arguments : At least %d %s"
 msgstr ""
 
-#: function.c:1948
+#: function.c:1954
 #, c-format
 msgid "Arguments : %d to %d %s"
 msgstr ""
@@ -3610,113 +3621,113 @@
 msgid "#-1 BAD ARGUMENT FORMAT TO GET_EVAL"
 msgstr ""
 
-#: fundb.c:890 game.c:1609
+#: fundb.c:895 game.c:1617
 msgid "#-1 INVALID LOCATION"
 msgstr ""
 
-#: fundb.c:994
+#: fundb.c:999
 msgid "#-1 NO OBJECTS CONTROLLED"
 msgstr ""
 
-#: fundb.c:1012 fundb.c:1477
+#: fundb.c:1017 fundb.c:1527
 msgid "#-1 ARG1 NOT FOUND"
 msgstr ""
 
-#: fundb.c:1020 fundb.c:1479
+#: fundb.c:1025 fundb.c:1529
 msgid "#-1 ARG2 NOT FOUND"
 msgstr ""
 
-#: fundb.c:1028
+#: fundb.c:1033
 msgid "#-1 BAD ATTR NAME"
 msgstr ""
 
-#: fundb.c:1165
+#: fundb.c:1170
 msgid "#-1 NO SUCH TYPE"
 msgstr ""
 
-#: fundb.c:1183 fundb.c:1195 fundb.c:1213 fundb.c:1231
+#: fundb.c:1188 fundb.c:1200 fundb.c:1218 fundb.c:1236
 msgid "#-1 INVALID FLAG"
 msgstr ""
 
-#: fundb.c:1211 fundb.c:1229
+#: fundb.c:1216 fundb.c:1234
 msgid "#-1 INVALID POWER"
 msgstr ""
 
-#: fundb.c:1330 fundb.c:1334 fundb.c:1355 fundb.c:1362
+#: fundb.c:1335 fundb.c:1339 fundb.c:1360 fundb.c:1367
 msgid "#-1 NO SUCH LOCK"
 msgstr ""
 
-#: fundb.c:1453
+#: fundb.c:1461 fundb.c:1503
 msgid "#-1 INVALID BOOLEXP"
 msgstr ""
 
-#: fundb.c:1898
+#: fundb.c:1948
 msgid "I'm not sure who you mean."
 msgstr ""
 
-#: fundb.c:2039
+#: fundb.c:2085
 #, c-format
 msgid "I don't understand switch '%c'."
 msgstr ""
 
-#: fundb.c:2138
+#: fundb.c:2194
 msgid "#-1 INVALID SOURCE ROOM"
 msgstr ""
 
-#: fundb.c:2243
+#: fundb.c:2299
 msgid "#-1 BAD ARGUMENT FORMAT TO ATTRIB_SET"
 msgstr ""
 
-#: fundb.c:2311
+#: fundb.c:2367
 msgid "#-1 NO SUCH ATTRIBUTE"
 msgstr ""
 
-#: fundb.c:2315 predicat.c:1425
+#: fundb.c:2371 predicat.c:1574
 msgid "#-1 INVALID GREP PATTERN"
 msgstr ""
 
-#: fundb.c:2394 fundb.c:2398
+#: fundb.c:2450 fundb.c:2454
 msgid "#-1 ARGUMENT MUST BE OBJ/ATTR"
 msgstr ""
 
-#: fundb.c:2427 fundb.c:2449
+#: fundb.c:2483 fundb.c:2505
 msgid "#-1 INVALID OBJECT"
 msgstr ""
 
-#: funlist.c:221
+#: funlist.c:236
 msgid "#-1 LISTS MUST BE OF EQUAL SIZE"
 msgstr ""
 
-#: funlist.c:1262 funmisc.c:456
+#: funlist.c:997 funmisc.c:456
 msgid "#-1 NUMBER OUT OF RANGE"
 msgstr ""
 
-#: funlist.c:1732 funlist.c:2038
+#: funlist.c:1472 funlist.c:1778
 msgid "#-1 CAN ONLY TEST ONE ELEMENT"
 msgstr ""
 
-#: funlist.c:2174
+#: funlist.c:1914
 msgid "#-1 NEED A WORD"
 msgstr ""
 
-#: funlist.c:2180
+#: funlist.c:1920
 msgid "#-1 TOO MANY WORDS"
 msgstr ""
 
-#: funlist.c:2187
+#: funlist.c:1927
 msgid "#-1 NUMBER OF WORDS MUST BE EQUAL"
 msgstr ""
 
-#: funlist.c:2228
+#: funlist.c:1968
 msgid "#-1 TOO MANY ITERS"
 msgstr ""
 
-#: funlist.c:2424
+#: funlist.c:2164
 msgid "#-1 STEP OUT OF RANGE"
 msgstr ""
 
-#: funlist.c:2837 funlist.c:2852 funlist.c:2945 funlist.c:2960 funlist.c:3076
-#: funlist.c:3210 funlist.c:3218 predicat.c:1449 predicat.c:1460
+#: funlist.c:2577 funlist.c:2592 funlist.c:2685 funlist.c:2700 funlist.c:2816
+#: funlist.c:2950 funlist.c:2958 predicat.c:1598 predicat.c:1609
 msgid "#-1 REGEXP ERROR: "
 msgstr ""
 
@@ -3743,60 +3754,60 @@
 msgid "#-1 VECTORS MUST BE THREE-DIMENSIONAL"
 msgstr ""
 
-#: funmath.c:893 funmath.c:2156 funmath.c:2201 funmath.c:2246 funmath.c:2281
-#: funmath.c:2326
+#: funmath.c:893 funmath.c:2146 funmath.c:2191 funmath.c:2236 funmath.c:2271
+#: funmath.c:2316
 msgid "#-1 DIVISION BY ZERO"
 msgstr ""
 
-#: funmath.c:1113
+#: funmath.c:1103
 msgid "#-1 FRACTIONAL POWER OF NEGATIVE"
 msgstr ""
 
-#: funmath.c:1137 funmath.c:1172
+#: funmath.c:1127 funmath.c:1162
 msgid "#-1 INFINITY"
 msgstr ""
 
-#: funmath.c:1194
+#: funmath.c:1184
 msgid "#-1 BASE OUT OF RANGE"
 msgstr ""
 
-#: funmath.c:1215 funmath.c:1248
+#: funmath.c:1205 funmath.c:1238
 msgid "#-1 IMAGINARY NUMBER"
 msgstr ""
 
-#: funmath.c:1239
+#: funmath.c:1229
 msgid "#-1 ROOT OUT OF RANGE"
 msgstr ""
 
-#: funmath.c:1821
+#: funmath.c:1811
 msgid "#-1 UNKNOWN OPERATION"
 msgstr ""
 
-#: funmath.c:1899
+#: funmath.c:1889
 msgid "#-1 FROM BASE OUT OF RANGE"
 msgstr ""
 
-#: funmath.c:1908
+#: funmath.c:1898
 msgid "#-1 TO BASE OUT OF RANGE"
 msgstr ""
 
-#: funmath.c:1932
+#: funmath.c:1922
 msgid "#-1 MALFORMED NUMBER"
 msgstr ""
 
-#: funmath.c:2521 funmath.c:2559
+#: funmath.c:2511 funmath.c:2549
 msgid "#-1 COMPARISON REQUIRES 2 OR MORE NUMBERS"
 msgstr ""
 
-#: funmath.c:2672
+#: funmath.c:2662
 msgid "#-1 FUNCTION (DIST2D) EXPECTS 4 ARGUMENTS"
 msgstr ""
 
-#: funmath.c:2687 funmath.c:2716
+#: funmath.c:2677 funmath.c:2706
 msgid "#-1 OVERFLOW ERROR"
 msgstr ""
 
-#: funmath.c:2699
+#: funmath.c:2689
 msgid "#-1 FUNCTION (DIST3D) EXPECTS 6 ARGUMENTS"
 msgstr ""
 
@@ -3911,7 +3922,7 @@
 msgid "#-1 INVALID DBREF"
 msgstr ""
 
-#: funstr.c:643 funstr.c:785 funstr.c:1446
+#: funstr.c:643 funstr.c:785 funstr.c:1457
 msgid "#-1 STRING LENGTHS MUST BE EQUAL"
 msgstr ""
 
@@ -3927,47 +3938,47 @@
 msgid "#-1 FILL ARGUMENT MAY NOT BE ZERO-LENGTH"
 msgstr ""
 
-#: funstr.c:1412
+#: funstr.c:1423
 msgid "#-1 FUNCTION (ORD) EXPECTS ONE CHARACTER"
 msgstr ""
 
-#: funstr.c:1421 funstr.c:1439
+#: funstr.c:1432 funstr.c:1450
 msgid "#-1 UNPRINTABLE CHARACTER"
 msgstr ""
 
-#: funstr.c:1435
+#: funstr.c:1446
 msgid "#-1 THIS ISN'T UNICODE"
 msgstr ""
 
-#: funstr.c:1628
+#: funstr.c:1639
 msgid "#-1 WIDTH TOO SMALL"
 msgstr ""
 
-#: funstr.c:1919 funstr.c:1944
+#: funstr.c:1947 funstr.c:1974
 msgid "#-1 INVALID ALIGN STRING"
 msgstr ""
 
-#: funstr.c:1958
+#: funstr.c:1991
 msgid "#-1 CANNOT HAVE COLUMNS OF NEGATIVE SIZE"
 msgstr ""
 
-#: funstr.c:1962 funstr.c:1968
+#: funstr.c:1995 funstr.c:2001
 msgid "#-1 CANNOT HAVE COLUMNS THAT LARGE"
 msgstr ""
 
-#: funstr.c:1973
+#: funstr.c:2006
 msgid "#-1 NOT ENOUGH COLUMNS FOR ALIGN"
 msgstr ""
 
-#: funstr.c:1977
+#: funstr.c:2010
 msgid "#-1 TOO MANY COLUMNS FOR ALIGN"
 msgstr ""
 
-#: funstr.c:1983 funstr.c:2018
+#: funstr.c:2016 funstr.c:2051
 msgid "#-1 INVALID NUMBER OF ARGUMENTS TO ALIGN"
 msgstr ""
 
-#: funstr.c:1988 funstr.c:2023
+#: funstr.c:2021 funstr.c:2056
 msgid "#-1 FILLER MUST BE ONE CHARACTER"
 msgstr ""
 
@@ -3988,11 +3999,11 @@
 msgid "#-1 INVALID TIMESTRING"
 msgstr ""
 
-#: funufun.c:57 parse.c:1322
+#: funufun.c:57 parse.c:1364
 msgid "#-1 FUNCTION ("
 msgstr ""
 
-#: funufun.c:59 parse.c:1324
+#: funufun.c:59 parse.c:1366
 msgid ") NOT FOUND"
 msgstr ""
 
@@ -4027,355 +4038,369 @@
 msgid "GAME: Shutdown by %s"
 msgstr ""
 
-#: game.c:330
+#: game.c:330 game.c:332
 msgid "GAME: ERROR! Database save failed!"
 msgstr ""
 
-#: game.c:451
+#: game.c:453
 #, c-format
 msgid "EMERGENCY SHUTDOWN: %s"
 msgstr ""
 
-#: game.c:566
+#: game.c:568
 msgid "DUMP: Data are swapped to disk, so nonforking dumps will be used."
 msgstr ""
 
-#: game.c:1096
+#: game.c:1103
 #, c-format
 msgid "Attempt to execute command by halted object #%d"
 msgstr ""
 
-#: game.c:1106
+#: game.c:1113
 #, c-format
 msgid "Invalid location on command execution: %s(#%d)"
 msgstr ""
 
-#: game.c:1281 game.c:1288 look.c:663 look.c:685 look.c:712 look.c:720
-#: move.c:555 move.c:563 move.c:599 move.c:877 move.c:1046 speech.c:564
+#: game.c:1289 game.c:1296 look.c:663 look.c:685 look.c:712 look.c:721
+#: move.c:569 move.c:578 move.c:614 move.c:892 move.c:1061 set.c:121
+#: speech.c:585
 msgid "I don't see that here."
 msgstr ""
 
-#: game.c:1284 game.c:1305
+#: game.c:1292 game.c:1313
 msgid "Make room! Make room!"
 msgstr ""
 
-#: game.c:1299 game.c:1310
+#: game.c:1307 game.c:1318
 msgid "No matching command."
 msgstr ""
 
-#: game.c:1506
+#: game.c:1514
 msgid "Only God can cause financial ruin."
 msgstr ""
 
-#: game.c:1514
+#: game.c:1522
 #, c-format
 msgid "The money supply of all players has been reset to %d %s."
 msgstr ""
 
-#: game.c:1539
+#: game.c:1547
 msgid "Logged."
 msgstr ""
 
-#: game.c:1613
+#: game.c:1621
 msgid "#-1 NO COMMAND"
 msgstr ""
 
-#: game.c:1718
+#: game.c:1726
 msgid "Sorry, you are in an invalid location."
 msgstr ""
 
-#: game.c:1722
+#: game.c:1730
 msgid "What command do you want to scan for?"
 msgstr ""
 
-#: game.c:1729
+#: game.c:1737
 msgid "Matches on contents of this room:"
 msgstr ""
 
-#: game.c:1744
+#: game.c:1752
 #, c-format
 msgid "Matched here: %s  [%d:%s]"
 msgstr ""
 
-#: game.c:1750
+#: game.c:1758
 msgid "Matches on carried objects:"
 msgstr ""
 
-#: game.c:1764
+#: game.c:1772
 #, c-format
 msgid "Matched self: %s  [%d:%s]"
 msgstr ""
 
-#: game.c:1775
+#: game.c:1783
 msgid "Matches on zone master room of location:"
 msgstr ""
 
-#: game.c:1790
+#: game.c:1798
 #, c-format
 msgid "Matched zone of location: %s  [%d:%s]"
 msgstr ""
 
-#: game.c:1802
+#: game.c:1810
 msgid "Matches on personal zone master room:"
 msgstr ""
 
-#: game.c:1814
+#: game.c:1822
 #, c-format
 msgid "Matched personal zone: %s  [%d:%s]"
 msgstr ""
 
-#: game.c:1825
+#: game.c:1833
 msgid "Matches on objects in the Master Room:"
 msgstr ""
 
-#: game.c:1863
+#: game.c:1871
 msgid "What do you want to do with the list?"
 msgstr ""
 
-#: game.c:1871
+#: game.c:1879
 msgid "Separator must be one character."
 msgstr ""
 
-#: game.c:2052
+#: game.c:2060
 msgid "Error -- cannot execute uptime."
 msgstr ""
 
-#: game.c:2134
+#: game.c:2142
 msgid "Up since"
 msgstr ""
 
-#: game.c:2138
+#: game.c:2146
 msgid "Last reboot"
 msgstr ""
 
-#: game.c:2140
+#: game.c:2148
 msgid "Total reboots"
 msgstr ""
 
-#: game.c:2144
+#: game.c:2152
 msgid "Time now"
 msgstr ""
 
-#: game.c:2149
+#: game.c:2157
 msgid "Time of last database save"
 msgstr ""
 
-#: game.c:2157 game.c:2164 game.c:2171 game.c:2179
+#: game.c:2165 game.c:2172 game.c:2179 game.c:2187
 #, c-format
 msgid "%29s: %ld minutes %ld seconds, at %s."
 msgstr ""
 
-#: game.c:2158
+#: game.c:2166
 msgid "Time until next database save"
 msgstr ""
 
-#: game.c:2165
+#: game.c:2173
 msgid "Time until next dbck check"
 msgstr ""
 
-#: game.c:2172
+#: game.c:2180
 msgid "Time until next purge"
 msgstr ""
 
-#: game.c:2180
+#: game.c:2188
 msgid "Time until next @warnings"
 msgstr ""
 
-#: game.c:2196
+#: game.c:2204
 #, c-format
 msgid "PennMUSH Uptime: %ld days %ld hours %ld minutes %ld seconds"
 msgstr ""
 
-#: game.c:2377 game.c:2406
+#: game.c:2385 game.c:2414
 msgid "I don't understand what you want to @list."
 msgstr ""
 
-#: help.c:66
+#: help.c:70
 msgid "That command is unavailable."
 msgstr ""
 
-#: help.c:71
+#: help.c:75
 msgid "You don't look like an admin to me."
 msgstr ""
 
-#: help.c:81
+#: help.c:86
 #, c-format
 msgid "No entries matching '%s' were found."
 msgstr ""
 
-#: help.c:92
+#: help.c:97 help.c:156
 #, c-format
 msgid ""
 "Here are the entries which match '%s':\n"
 "%s"
 msgstr ""
 
-#: help.c:175
+#: help.c:120 help.c:130 help.c:140 help.c:147
+#, c-format
+msgid "No entry for '%s'"
+msgstr ""
+
+#: help.c:238
 msgid "Help files reindexed."
 msgstr ""
 
-#: help.c:195
+#: help.c:258
 msgid "Help topics don't start with '&'."
 msgstr ""
 
-#: help.c:207
+#: help.c:270
 msgid "Sorry, that command is temporarily unvailable."
 msgstr ""
 
-#: help.c:217
+#: help.c:280
 #, c-format
 msgid "No entry for '%s'."
 msgstr ""
 
-#: help.c:222 help.c:227
+#: help.c:285 help.c:290
 msgid "Sorry, that function is temporarily unavailable."
 msgstr ""
 
-#: help.c:260
+#: help.c:323
 #, c-format
 msgid "%s output truncated."
 msgstr ""
 
-#: help.c:474 help.c:505
+#: help.c:537 help.c:568
 msgid "#-1 NO SUCH FILE"
 msgstr ""
 
-#: help.c:487
+#: help.c:550
 msgid "No matching help topics."
 msgstr ""
 
-#: help.c:530
+#: help.c:593
 msgid "#-1 INVALID ENTRY"
 msgstr ""
 
-#: help.c:552
+#: help.c:615
 msgid "#-1 NO INDEX FOR FILE"
 msgstr ""
 
-#: help.c:556
+#: help.c:619
 msgid "#-1 NO ENTRY"
 msgstr ""
 
-#: help.c:560 help.c:563
+#: help.c:623 help.c:626
 msgid "#-1 UNAVAILABLE"
 msgstr ""
 
-#: lock.c:663
+#: lock.c:665
 msgid "Unknown lock type."
 msgstr ""
 
-#: lock.c:667
+#: lock.c:669
 msgid "The character '|' may not be used in lock names."
 msgstr ""
 
-#: lock.c:676
+#: lock.c:678
 msgid "That is not a valid lock name."
 msgstr ""
 
-#: lock.c:706
+#: lock.c:708
 #, c-format
 msgid "%s(%s) - %s (already) unlocked."
 msgstr ""
 
-#: lock.c:710
+#: lock.c:712
 #, c-format
 msgid "%s(%s) - %s unlocked."
 msgstr ""
 
-#: lock.c:747
+#: lock.c:749
 msgid "I don't see what you want to lock!"
 msgstr ""
 
-#: lock.c:750
+#: lock.c:752
 msgid "I don't know which one you want to lock!"
 msgstr ""
 
-#: lock.c:754
+#: lock.c:756
 msgid "You can't lock that!"
 msgstr ""
 
-#: lock.c:758
+#: lock.c:760
 msgid "Why would you want to lock garbage?"
 msgstr ""
 
-#: lock.c:768 wiz.c:1935
+#: lock.c:770 wiz.c:2016
 msgid "I don't understand that key."
 msgstr ""
 
-#: lock.c:774
+#: lock.c:776
 #, c-format
 msgid "%s(%s) - %s locked."
 msgstr ""
 
-#: lock.c:950
+#: lock.c:952
 msgid "No lock name given."
 msgstr ""
 
-#: lock.c:964
+#: lock.c:966
 msgid "Unrecognized lock flag."
 msgstr ""
 
-#: lock.c:970
+#: lock.c:972
 msgid "No such lock."
 msgstr ""
 
-#: lock.c:986
+#: lock.c:988
 msgid "lock flags unset"
 msgstr ""
 
-#: lock.c:986
+#: lock.c:988
 msgid "lock flags set"
 msgstr ""
 
-#: lock.c:1007
+#: lock.c:1009
 #, c-format
 msgid "Unlocked zone %s - automatically zone-locking to itself"
 msgstr ""
 
-#: lock.c:1015
+#: lock.c:1019
 #, c-format
 msgid "Zone %s really should have a more secure zone-lock."
 msgstr ""
 
-#: lock.c:1020
+#: lock.c:1025
 #, c-format
 msgid ""
 "Warning: Zone %s may have loose zone lock. Lock zones to =player, not player"
 msgstr ""
 
-#: log.c:65 unparse.c:131 unparse.c:134
+#: log.c:86 unparse.c:131 unparse.c:134
 msgid "*NOTHING*"
 msgstr ""
 
-#: log.c:68 unparse.c:136
+#: log.c:89 unparse.c:136
 msgid "*VARIABLE*"
 msgstr ""
 
-#: log.c:71 unparse.c:138
+#: log.c:92 unparse.c:138
 msgid "*HOME*"
 msgstr ""
 
-#: log.c:319
+#: log.c:325
 msgid "bad object"
 msgstr ""
 
 #: log.c:360
+msgid "Begin log recall."
+msgstr ""
+
+#: log.c:369
+msgid "End log recall."
+msgstr ""
+
+#: log.c:389
 msgid "Wrong password."
 msgstr ""
 
-#: log.c:397
-msgid "That is not a valid log."
+#: log.c:406
+msgid "That is not a clearable log."
 msgstr ""
 
-#: log.c:400
+#: log.c:409
 msgid "Log wiped."
 msgstr ""
 
-#: log.c:469
+#: log.c:478
 msgid "GAME: Recall from activity log"
 msgstr ""
 
-#: log.c:502
+#: log.c:511
 msgid "GAME: End recall"
 msgstr ""
 
@@ -4424,7 +4449,7 @@
 msgid "%s [#%d%s] is veiled"
 msgstr ""
 
-#: look.c:427 look.c:431 look.c:437 look.c:442 set.c:938
+#: look.c:427 look.c:431 look.c:437 look.c:442 set.c:968
 msgid "No matching attributes."
 msgstr ""
 
@@ -4448,20 +4473,20 @@
 msgid "I don't know which one you mean."
 msgstr ""
 
-#: look.c:688 look.c:723 move.c:558 move.c:566
+#: look.c:688 look.c:724 move.c:572 move.c:581
 #, c-format
 msgid "I can't tell which %s."
 msgstr ""
 
-#: look.c:729
+#: look.c:730
 msgid "You can't look at that from here."
 msgstr ""
 
-#: look.c:734
+#: look.c:735
 msgid "I can't tell which one you mean."
 msgstr ""
 
-#: look.c:755
+#: look.c:756
 msgid "You can't see that from here."
 msgstr ""
 
@@ -4689,7 +4714,7 @@
 msgid "%s(#%d) [home]"
 msgstr ""
 
-#: look.c:1389 wiz.c:1222 wiz.c:1389
+#: look.c:1389 wiz.c:1238 wiz.c:1405
 msgid "Nothing found."
 msgstr ""
 
@@ -4697,17 +4722,17 @@
 msgid "----------  Entrances Done  ----------"
 msgstr ""
 
-#: look.c:1395 wiz.c:1344
+#: look.c:1395 wiz.c:1360
 #, c-format
 msgid "Totals: Rooms...%d  Exits...%d  Things...%d  Players...%d"
 msgstr ""
 
-#: look.c:1504
+#: look.c:1505
 #, c-format
 msgid "@@ No attributes match '%s'. @@"
 msgstr ""
 
-#: look.c:1565
+#: look.c:1571
 msgid "What do you want to @decompile?"
 msgstr ""
 
@@ -4901,307 +4926,307 @@
 msgid "MAIL: %s removed from alias %s"
 msgstr ""
 
-#: markup.c:1153
+#: markup.c:1156
 msgid "Inspecting ansi string"
 msgstr ""
 
-#: markup.c:1154
+#: markup.c:1157
 #, c-format
 msgid "  Text: %s"
 msgstr ""
 
-#: markup.c:1155
+#: markup.c:1158
 #, c-format
 msgid "  Nmarkups: %d"
 msgstr ""
 
-#: markup.c:1161
+#: markup.c:1164
 #, c-format
 msgid "    %d (%s): (start: %d end: %d) start_code: %s stop_code: %s"
 msgstr ""
 
-#: markup.c:1166
+#: markup.c:1169
 msgid "Inspecting ansi string complete"
 msgstr ""
 
-#: move.c:99
+#: move.c:101
 msgid "has left."
 msgstr ""
 
-#: move.c:122
+#: move.c:124
 msgid "has arrived."
 msgstr ""
 
-#: move.c:374 move.c:614 wiz.c:412 wiz.c:417 wiz.c:421
+#: move.c:388 move.c:629 wiz.c:420 wiz.c:425 wiz.c:429
 msgid "Bad destination."
 msgstr ""
 
-#: move.c:380
+#: move.c:394
 #, c-format
 msgid "%s goes home."
 msgstr ""
 
-#: move.c:383 move.c:384 move.c:385
+#: move.c:397 move.c:398 move.c:399
 msgid "There's no place like home..."
 msgstr ""
 
-#: move.c:406 move.c:416 move.c:468 move.c:486
+#: move.c:420 move.c:430 move.c:482 move.c:500
 msgid "You can't go that way."
 msgstr ""
 
-#: move.c:409
+#: move.c:423
 msgid "I don't know which way you mean!"
 msgstr ""
 
-#: move.c:431
+#: move.c:445
 #, c-format
 msgid "Variable exit destination #%d is invalid or not permitted."
 msgstr ""
 
-#: move.c:444 move.c:448
+#: move.c:458 move.c:462
 msgid "Exit destination is invalid."
 msgstr ""
 
-#: move.c:482
+#: move.c:496
 msgid "This feature coming soon."
 msgstr ""
 
-#: move.c:514
+#: move.c:528
 msgid "You cannot modify exits in that room."
 msgstr ""
 
-#: move.c:520
+#: move.c:534
 #, c-format
 msgid "%s is now the first exit in %s."
 msgstr ""
 
-#: move.c:580 move.c:801
+#: move.c:595 move.c:816
 #, c-format
 msgid "%s was taken from you."
 msgstr ""
 
-#: move.c:581 move.c:631 move.c:802
+#: move.c:596 move.c:646 move.c:817
 #, c-format
 msgid "%s took you."
 msgstr ""
 
-#: move.c:583 move.c:804
+#: move.c:598 move.c:819
 #, c-format
 msgid "You take %s from %s."
 msgstr ""
 
-#: move.c:587 move.c:808
+#: move.c:602 move.c:823
 #, c-format
 msgid "takes %s from %s."
 msgstr ""
 
-#: move.c:597 move.c:626
+#: move.c:612 move.c:641
 msgid "You can't take that from there."
 msgstr ""
 
-#: move.c:606
+#: move.c:621
 msgid "You already have that!"
 msgstr ""
 
-#: move.c:610
+#: move.c:625
 msgid "It's all around you!"
 msgstr ""
 
-#: move.c:621
+#: move.c:636
 msgid "You cannot get yourself!"
 msgstr ""
 
-#: move.c:633
+#: move.c:648
 #, c-format
 msgid "You take %s."
 msgstr ""
 
-#: move.c:636
+#: move.c:651
 #, c-format
 msgid "takes %s."
 msgstr ""
 
-#: move.c:643
+#: move.c:658
 msgid "You can't pick that up."
 msgstr ""
 
-#: move.c:647
+#: move.c:662
 msgid "You can't pick up exits."
 msgstr ""
 
-#: move.c:650
+#: move.c:665
 msgid "You can't take that!"
 msgstr ""
 
-#: move.c:674 rob.c:369
+#: move.c:689 rob.c:400
 msgid "You don't have that!"
 msgstr ""
 
-#: move.c:677 rob.c:372
+#: move.c:692 rob.c:403
 msgid "I don't know which you mean!"
 msgstr ""
 
-#: move.c:682
+#: move.c:697
 msgid "You can't drop that."
 msgstr ""
 
-#: move.c:685
+#: move.c:700
 msgid "Sorry, you can't drop exits."
 msgstr ""
 
-#: move.c:689
+#: move.c:704
 msgid "You can't seem to get rid of that."
 msgstr ""
 
-#: move.c:693
+#: move.c:708
 msgid "You can't seem to drop things here."
 msgstr ""
 
-#: move.c:696
+#: move.c:711
 msgid "Dropped."
 msgstr ""
 
-#: move.c:701 move.c:704 move.c:825 move.c:828
+#: move.c:716 move.c:719 move.c:840 move.c:843
 #, c-format
 msgid "%s drops you."
 msgstr ""
 
-#: move.c:710 move.c:832
+#: move.c:725 move.c:847
 #, c-format
 msgid "You drop %s."
 msgstr ""
 
-#: move.c:713 move.c:835
+#: move.c:728 move.c:850
 #, c-format
 msgid "drops %s."
 msgstr ""
 
-#: move.c:761
+#: move.c:776
 msgid "You can't empty that from here."
 msgstr ""
 
-#: move.c:842
+#: move.c:857
 #, c-format
 msgid "You remove 1 object from %s."
 msgstr ""
 
-#: move.c:844
+#: move.c:859
 #, c-format
 msgid "You remove %d objects from %s."
 msgstr ""
 
-#: move.c:889
+#: move.c:904
 msgid "Sorry, you must remain beside yourself!"
 msgstr ""
 
-#: move.c:913
+#: move.c:928
 msgid "You can't leave."
 msgstr ""
 
-#: move.c:987
+#: move.c:1002
 msgid "I can't tell which one to follow."
 msgstr ""
 
-#: move.c:995
+#: move.c:1010
 msgid "You don't see that here."
 msgstr ""
 
-#: move.c:999
+#: move.c:1014
 msgid "You can only follow players and things."
 msgstr ""
 
-#: move.c:1003
+#: move.c:1018
 msgid "You chase your tail for a while and feel silly."
 msgstr ""
 
-#: move.c:1008
+#: move.c:1023
 #, c-format
 msgid "You're already following %s."
 msgstr ""
 
-#: move.c:1014
+#: move.c:1029
 msgid "You're not allowed to follow."
 msgstr ""
 
-#: move.c:1021
+#: move.c:1036
 #, c-format
 msgid "You are following: %s"
 msgstr ""
 
-#: move.c:1022
+#: move.c:1037
 #, c-format
 msgid "You are followed by: %s"
 msgstr ""
 
-#: move.c:1042
+#: move.c:1057
 msgid "I can't tell which one to stop following."
 msgstr ""
 
-#: move.c:1051
+#: move.c:1066
 #, c-format
 msgid "You're not following %s."
 msgstr ""
 
-#: move.c:1059
+#: move.c:1074
 msgid "You stop following anyone."
 msgstr ""
 
-#: move.c:1080
+#: move.c:1095
 msgid "I don't recognize who you want to dismiss."
 msgstr ""
 
-#: move.c:1085
+#: move.c:1100
 #, c-format
 msgid "%s isn't following you."
 msgstr ""
 
-#: move.c:1093
+#: move.c:1108
 msgid "You dismiss all your followers."
 msgstr ""
 
-#: move.c:1113
+#: move.c:1128
 msgid "I don't recognize who you want to desert."
 msgstr ""
 
-#: move.c:1120
+#: move.c:1135
 #, c-format
 msgid "%s isn't following you, nor vice versa."
 msgstr ""
 
-#: move.c:1130
+#: move.c:1145
 msgid "You desert everyone you're leading or following."
 msgstr ""
 
-#: move.c:1181
+#: move.c:1196
 #, c-format
 msgid "You begin following %s."
 msgstr ""
 
-#: move.c:1182
+#: move.c:1197
 #, c-format
 msgid "%s begins following you."
 msgstr ""
 
-#: move.c:1228 move.c:1342
+#: move.c:1243 move.c:1357
 #, c-format
 msgid "You stop following %s."
 msgstr ""
 
-#: move.c:1229 move.c:1370
+#: move.c:1244 move.c:1385
 #, c-format
 msgid "%s stops following you."
 msgstr ""
 
-#: move.c:1404
+#: move.c:1419
 #, c-format
 msgid "You follow %s."
 msgstr ""
 
-#: mymalloc.c:556 rob.c:86 wiz.c:603
+#: mymalloc.c:556 rob.c:87 wiz.c:613
 msgid "Sorry."
 msgstr ""
 
-#: notify.c:1479
+#: notify.c:1482
 #, c-format
 msgid "[%s(#%d)'s %s(#%d)] "
 msgstr ""
@@ -5246,7 +5271,7 @@
 msgid "#-1 NO MATCH"
 msgstr ""
 
-#: parse.c:102 sort.c:337
+#: parse.c:102 sort.c:321
 msgid "#-1 NO SUCH OBJECT VISIBLE"
 msgstr ""
 
@@ -5258,111 +5283,106 @@
 msgid "#-1 ARGUMENT OUT OF RANGE"
 msgstr ""
 
-#: parse.c:713
+#: parse.c:746
 msgid "CPU usage exceeded."
 msgstr ""
 
-#: parse.c:1373
+#: parse.c:1415
 msgid "#-1 FUNCTION RECURSION LIMIT EXCEEDED"
 msgstr ""
 
-#: parse.c:1470
+#: parse.c:1512
 #, c-format
 msgid "#-1 FUNCTION (%s) EXPECTS "
 msgstr ""
 
-#: parse.c:1475
+#: parse.c:1517
 msgid " OR "
 msgstr ""
 
-#: parse.c:1478
+#: parse.c:1520
 msgid "AT LEAST "
 msgstr ""
 
-#: parse.c:1481
+#: parse.c:1523
 msgid "BETWEEN "
 msgstr ""
 
-#: parse.c:1483
+#: parse.c:1525
 msgid " AND "
 msgstr ""
 
-#: parse.c:1486
+#: parse.c:1528
 msgid " ARGUMENTS BUT GOT "
 msgstr ""
 
-#: parse.c:1527
+#: parse.c:1569
 msgid "#-1 @FUNCTION ("
 msgstr ""
 
-#: parse.c:1529
+#: parse.c:1571
 msgid ") MISSING ATTRIBUTE ("
 msgstr ""
 
-#: player.c:195
-msgid ""
-"This IP address has failed too many times. Please try again in 10 minutes."
-msgstr ""
-
-#: player.c:226
+#: player.c:254
 msgid "Guest connections not allowed."
 msgstr ""
 
-#: player.c:236
+#: player.c:267
 msgid "Player connections not allowed."
 msgstr ""
 
-#: player.c:256
+#: player.c:293
 msgid "Too many guests are connected now."
 msgstr ""
 
-#: player.c:406
+#: player.c:483
 #, c-format
 msgid "[%s] Registration of %s\n"
 msgstr ""
 
-#: player.c:410
+#: player.c:487
 msgid "This is an automated message.\n"
 msgstr ""
 
-#: player.c:412
+#: player.c:489
 #, c-format
 msgid "Your requested player, %s, has been created.\n"
 msgstr ""
 
-#: player.c:413
+#: player.c:490
 #, c-format
 msgid "The password is %s\n"
 msgstr ""
 
-#: player.c:415
+#: player.c:492
 #, c-format
 msgid "To access this character, connect to %s and type:\n"
 msgstr ""
 
-#: player.c:536
+#: player.c:616
 msgid "The old password that you entered was incorrect."
 msgstr ""
 
-#: player.c:538
+#: player.c:618
 msgid "Bad new password."
 msgstr ""
 
-#: player.c:541
+#: player.c:621
 msgid "You have changed your password."
 msgstr ""
 
-#: player.c:572
+#: player.c:652
 #, c-format
 msgid "Last connect was from %s on %s."
 msgstr ""
 
-#: player.c:580
+#: player.c:660
 #, c-format
 msgid "Last FAILED connect was from %s."
 msgstr ""
 
-#: player.c:607
+#: player.c:687
 #, c-format
 msgid "%s on %s"
 msgstr ""
@@ -5390,68 +5410,68 @@
 msgid "GAME: %s(%s) tried to spend %d %s."
 msgstr ""
 
-#: predicat.c:1134
+#: predicat.c:1283
 #, c-format
 msgid "%s message from %s: %s"
 msgstr ""
 
-#: predicat.c:1138
+#: predicat.c:1287
 #, c-format
 msgid "[%d:%02d] %s message sent to %s."
 msgstr ""
 
-#: predicat.c:1221
+#: predicat.c:1370
 msgid "What was the victim of the verb?"
 msgstr ""
 
-#: predicat.c:1227
+#: predicat.c:1376
 msgid "What do you want to do with the verb?"
 msgstr ""
 
-#: predicat.c:1233
+#: predicat.c:1382
 msgid "What do you want to do the verb?"
 msgstr ""
 
-#: predicat.c:1427 predicat.c:1519
+#: predicat.c:1576 predicat.c:1668
 msgid "What pattern do you want to grep for?"
 msgstr ""
 
-#: predicat.c:1452 predicat.c:1463
+#: predicat.c:1601 predicat.c:1612
 #, c-format
 msgid "Invalid regexp: %s"
 msgstr ""
 
-#: predicat.c:1536 predicat.c:1546
+#: predicat.c:1685 predicat.c:1695
 msgid "No matches."
 msgstr ""
 
-#: predicat.c:1543
+#: predicat.c:1692
 #, c-format
 msgid "Matches of '%s' on %s(#%d): %s"
 msgstr ""
 
-#: rob.c:61
+#: rob.c:62
 msgid "You do not have such power."
 msgstr ""
 
-#: rob.c:69
+#: rob.c:70
 msgid "No suicide allowed."
 msgstr ""
 
-#: rob.c:77
+#: rob.c:78
 #, c-format
 msgid "Broadcast: Suspect %s tried to kill %s(#%d)."
 msgstr ""
 
-#: rob.c:80
+#: rob.c:81
 msgid "Sorry, you can only kill players and objects."
 msgstr ""
 
-#: rob.c:89
+#: rob.c:90
 msgid "That object cannot be killed."
 msgstr ""
 
-#: rob.c:101
+#: rob.c:102
 #, c-format
 msgid "You don't have enough %s."
 msgstr ""
@@ -5466,180 +5486,185 @@
 msgid "killed %s!"
 msgstr ""
 
-#: rob.c:118
+#: rob.c:123
 #, c-format
 msgid "%s killed you!"
 msgstr ""
 
-#: rob.c:127
+#: rob.c:134
 #, c-format
 msgid "Your insurance policy pays %d %s."
 msgstr ""
 
-#: rob.c:131
+#: rob.c:138
 msgid "Your insurance policy has been revoked."
 msgstr ""
 
-#: rob.c:139
+#: rob.c:147
 msgid "Your murder attempt failed."
 msgstr ""
 
-#: rob.c:140
+#: rob.c:148
 #, c-format
 msgid "%s tried to kill you!"
 msgstr ""
 
-#: rob.c:184
+#: rob.c:193
 msgid "Buy from whom?"
 msgstr ""
 
-#: rob.c:191
+#: rob.c:200
 msgid "You can't buy from yourself!"
 msgstr ""
 
-#: rob.c:195
+#: rob.c:204
 msgid "There's nobody here to buy things from."
 msgstr ""
 
-#: rob.c:202
+#: rob.c:211
 msgid "Buy what?"
 msgstr ""
 
-#: rob.c:284
+#: rob.c:307
 #, c-format
 msgid "You buy a %s from %s."
 msgstr ""
 
-#: rob.c:288
+#: rob.c:311
 #, c-format
 msgid "buys a %s from %s."
 msgstr ""
 
-#: rob.c:306
+#: rob.c:330
+#, c-format
+msgid "%s doesn't want your money."
+msgstr ""
+
+#: rob.c:335
 msgid "I can't find that item with that price here."
 msgstr ""
 
-#: rob.c:308
+#: rob.c:337
 #, c-format
 msgid "%s isn't selling that item for that price"
 msgstr ""
 
-#: rob.c:313
+#: rob.c:343
 msgid "I can't find that item here."
 msgstr ""
 
-#: rob.c:315
+#: rob.c:345
 #, c-format
 msgid "%s isn't selling that item."
 msgstr ""
 
-#: rob.c:318
+#: rob.c:349
 msgid "You can't afford that."
 msgstr ""
 
-#: rob.c:349 rob.c:358 rob.c:576
+#: rob.c:380 rob.c:389 rob.c:612
 msgid "Give to whom?"
 msgstr ""
 
-#: rob.c:380
+#: rob.c:411
 msgid "You can't give yourself away!"
 msgstr ""
 
-#: rob.c:385
+#: rob.c:416
 msgid "You can't give an object to itself!"
 msgstr ""
 
-#: rob.c:390
+#: rob.c:421
 msgid "You can't give that away."
 msgstr ""
 
-#: rob.c:395
+#: rob.c:426
 #, c-format
 msgid "%s doesn't want anything from you."
 msgstr ""
 
-#: rob.c:401
+#: rob.c:432
 #, c-format
 msgid "%s doesn't want that."
 msgstr ""
 
-#: rob.c:410
+#: rob.c:441
 #, c-format
 msgid "You gave %s to %s."
 msgstr ""
 
-#: rob.c:417
+#: rob.c:448
 #, c-format
 msgid "%s gave you to %s."
 msgstr ""
 
-#: rob.c:423
+#: rob.c:454
 #, c-format
 msgid "%s gave you %s."
 msgstr ""
 
-#: rob.c:438
+#: rob.c:469
 msgid "What is this, a holdup?"
 msgstr ""
 
-#: rob.c:442
+#: rob.c:473
 #, c-format
 msgid "You must specify a positive number of %s."
 msgstr ""
 
-#: rob.c:449
+#: rob.c:480
 #, c-format
 msgid "You don't have that many %s to give!"
 msgstr ""
 
-#: rob.c:459 rob.c:474 rob.c:498
+#: rob.c:490 rob.c:522 rob.c:529 rob.c:551
 #, c-format
 msgid "%s refuses your money."
 msgstr ""
 
-#: rob.c:493
+#: rob.c:517
 msgid "Feeling poor today?"
 msgstr ""
 
-#: rob.c:503
+#: rob.c:533
 #, c-format
 msgid "You get %d in change."
 msgstr ""
 
-#: rob.c:505
+#: rob.c:535
 #, c-format
 msgid "You paid %d %s."
 msgstr ""
 
-#: rob.c:520
+#: rob.c:556
 #, c-format
 msgid "You give %d %s to %s."
 msgstr ""
 
-#: rob.c:523
+#: rob.c:559
 #, c-format
 msgid "You took %d %s from %s!"
 msgstr ""
 
-#: rob.c:528
+#: rob.c:564
 #, c-format
 msgid "%s gives you %d %s."
 msgstr ""
 
-#: rob.c:531
+#: rob.c:567
 #, c-format
 msgid "%s took %d %s from you!"
 msgstr ""
 
-#: rob.c:560
+#: rob.c:596
 msgid "Did you want to give something *to* someone?"
 msgstr ""
 
-#: rob.c:567
+#: rob.c:603
 msgid "Give what?"
 msgstr ""
 
-#: rob.c:583
+#: rob.c:619
 msgid "I don't know what you mean."
 msgstr ""
 
@@ -5647,534 +5672,547 @@
 msgid "GAME: Game shutdown by system operator"
 msgstr ""
 
-#: set.c:81
+#: set.c:78
 msgid "Give it what new name?"
 msgstr ""
 
-#: set.c:102
+#: set.c:87
 msgid "You can't give a player that name."
 msgstr ""
 
-#: set.c:111
+#: set.c:90
+msgid "Too many aliases."
+msgstr ""
+
+#: set.c:138
 #, c-format
 msgid "Broadcast: Suspect %s changed name to %s."
 msgstr ""
 
-#: set.c:136
+#: set.c:157
 msgid "Name set."
 msgstr ""
 
-#: set.c:183
+#: set.c:205
 msgid "Players always own themselves."
 msgstr ""
 
-#: set.c:193
+#: set.c:215
 msgid "You must carry the object to @chown it."
 msgstr ""
 
-#: set.c:197
+#: set.c:219
 msgid "You cannot @CHOWN/PRESERVE. Use normal @CHOWN."
 msgstr ""
 
-#: set.c:208
+#: set.c:230
 msgid "That player doesn't have enough money or quota to receive that object."
 msgstr ""
 
-#: set.c:216
+#: set.c:238
 msgid "Owner changed."
 msgstr ""
 
-#: set.c:292
+#: set.c:314
 msgid "Circular zone broken."
 msgstr ""
 
-#: set.c:301
+#: set.c:323
 msgid "Overly deep zone chain broken."
 msgstr ""
 
-#: set.c:321
+#: set.c:343
 #, c-format
 msgid ""
 "Warning: WIZ flag reset on #%d because @CHOWN/PRESERVE is to a third party."
 msgstr ""
 
-#: set.c:329
+#: set.c:351
 #, c-format
 msgid ""
 "Warning: @CHOWN/PRESERVE on an object (#%d) with WIZ, ROY, INHERIT, or "
 "@power privileges."
 msgstr ""
 
-#: set.c:366
+#: set.c:389
 msgid "That object is already in that zone."
 msgstr ""
 
-#: set.c:376
+#: set.c:399
 msgid "You don't have the power to shift reality."
 msgstr ""
 
-#: set.c:389
+#: set.c:414 set.c:416
 msgid "You cannot move that object to that zone."
 msgstr ""
 
-#: set.c:395
+#: set.c:424
 msgid "You shouldn't zone objects to themselves!"
 msgstr ""
 
-#: set.c:404
+#: set.c:433
 msgid "You can't make circular zones!"
 msgstr ""
 
-#: set.c:411
+#: set.c:440
 msgid "Overly deep zone chain."
 msgstr ""
 
-#: set.c:427
+#: set.c:456
 msgid "Warning: @chzoning admin-owned object!"
 msgstr ""
 
-#: set.c:451
+#: set.c:480
 msgid "Warning: @chzoning a privileged player."
 msgstr ""
 
-#: set.c:453
+#: set.c:482
 msgid "Warning: @chzoning a TRUST player."
 msgstr ""
 
-#: set.c:457
+#: set.c:486
 msgid "Zone changed."
 msgstr ""
 
-#: set.c:484
+#: set.c:513
 #, c-format
 msgid "You cannot change that flag on %s/%s"
 msgstr ""
 
-#: set.c:493
+#: set.c:522
 #, c-format
 msgid "%s/%s - %s reset."
 msgstr ""
 
-#: set.c:499
+#: set.c:528
 #, c-format
 msgid "%s/%s - %s set."
 msgstr ""
 
-#: set.c:513
+#: set.c:542
 #, c-format
 msgid "You cannot set attrib flags on %s/%s"
 msgstr ""
 
-#: set.c:542
+#: set.c:571
 msgid "What flag do you want to set?"
 msgstr ""
 
-#: set.c:553
+#: set.c:582
 msgid "Unrecognized attribute flag."
 msgstr ""
 
-#: set.c:559
+#: set.c:588
 msgid "No attribute found to change."
 msgstr ""
 
-#: set.c:588
+#: set.c:617
 msgid "What do you want to set?"
 msgstr ""
 
-#: set.c:610
+#: set.c:639
 msgid "Only God can set himself!"
 msgstr ""
 
-#: set.c:617
+#: set.c:646
 msgid "You may not set attributes."
 msgstr ""
 
-#: set.c:626
+#: set.c:655
 msgid "You must specify a flag to set."
 msgstr ""
 
-#: set.c:668
+#: set.c:697
 msgid "What do you want to copy from?"
 msgstr ""
 
-#: set.c:675
+#: set.c:704
 msgid "What object do you want to copy the attribute from?"
 msgstr ""
 
-#: set.c:688
+#: set.c:717
 msgid "No such attribute to copy from."
 msgstr ""
 
-#: set.c:693
+#: set.c:722
 msgid "Permission to read attribute denied."
 msgstr ""
 
-#: set.c:702
+#: set.c:731
 msgid "What do you want to copy to?"
 msgstr ""
 
-#: set.c:726
+#: set.c:756
 #, c-format
 msgid "Attribute %s (%d copies)"
 msgstr ""
 
-#: set.c:727
+#: set.c:757
 msgid "moved"
 msgstr ""
 
-#: set.c:727
+#: set.c:757
 msgid "copied"
 msgstr ""
 
-#: set.c:731
+#: set.c:761
 #, c-format
 msgid "Unable to %s attribute."
 msgstr ""
 
-#: set.c:732
+#: set.c:762
 msgid "move"
 msgstr ""
 
-#: set.c:732
+#: set.c:762
 msgid "copy"
 msgstr ""
 
-#: set.c:770
+#: set.c:800
 msgid "No such attribute, try set instead."
 msgstr ""
 
-#: set.c:774
+#: set.c:804
 msgid "You need to control an attribute to edit it."
 msgstr ""
 
-#: set.c:879 set.c:881 set.c:886 set.c:888
+#: set.c:909 set.c:911 set.c:916 set.c:918
 #, c-format
 msgid "%s - Set: %s"
 msgstr ""
 
-#: set.c:912 set.c:918
+#: set.c:942 set.c:948
 msgid "I need to know what you want to edit."
 msgstr ""
 
-#: set.c:929
+#: set.c:959
 msgid "Nothing to do."
 msgstr ""
 
-#: set.c:960
+#: set.c:990 sql.c:354
 msgid "I need to know what attribute to trigger."
 msgstr ""
 
-#: set.c:975
+#: set.c:1005 sql.c:372
 msgid "You can't trigger God!"
 msgstr ""
 
-#: set.c:984
+#: set.c:1014
 #, c-format
 msgid "%s - Triggered."
 msgstr ""
 
-#: set.c:1010
+#: set.c:1040
 msgid "I need to know what attribute to include."
 msgstr ""
 
-#: set.c:1021
+#: set.c:1051
 msgid "You can't include God!"
 msgstr ""
 
-#: set.c:1057
+#: set.c:1086
 msgid "Used."
 msgstr ""
 
-#: set.c:1109
+#: set.c:1138
 msgid "A thing cannot be its own ancestor!"
 msgstr ""
 
-#: set.c:1116
+#: set.c:1145
 msgid "You are not allowed to be your own ancestor!"
 msgstr ""
 
-#: set.c:1121
+#: set.c:1150
 msgid "Too many ancestors."
 msgstr ""
 
-#: set.c:1128
+#: set.c:1157
 msgid "Parent changed."
 msgstr ""
 
-#: set.c:1152
+#: set.c:1181
 #, c-format
 msgid "Unable to wipe attribute %s"
 msgstr ""
 
-#: set.c:1157
+#: set.c:1186
 #, c-format
 msgid "Attribute %s cannot be wiped because a child attribute cannot be wiped."
 msgstr ""
 
-#: set.c:1194
+#: set.c:1223
 msgid "That object is protected."
 msgstr ""
 
-#: set.c:1201
+#: set.c:1230
 msgid "No attributes wiped."
 msgstr ""
 
-#: set.c:1204
+#: set.c:1233
 msgid "One attribute wiped."
 msgstr ""
 
-#: set.c:1207
+#: set.c:1236
 #, c-format
 msgid "%d attributes wiped."
 msgstr ""
 
-#: speech.c:115 speech.c:157 speech.c:614 speech.c:1343
+#: speech.c:123 speech.c:165 speech.c:633 speech.c:1391
 msgid "You may not speak here!"
 msgstr ""
 
-#: speech.c:121
+#: speech.c:129
 msgid "You can't teach 'teach', sorry."
 msgstr ""
 
-#: speech.c:127
+#: speech.c:135
 msgid "What command do you want to teach?"
 msgstr ""
 
-#: speech.c:133
+#: speech.c:141
 #, c-format
 msgid "%s types --> %s%s%s"
 msgstr ""
 
-#: speech.c:173
+#: speech.c:181
 #, c-format
 msgid "You say, \"%s\""
 msgstr ""
 
-#: speech.c:175
+#: speech.c:183
 #, c-format
 msgid "%s says, \"%s\""
 msgstr ""
 
-#: speech.c:224
+#: speech.c:233
 msgid "I can't find that room."
 msgstr ""
 
-#: speech.c:229 speech.c:1386 speech.c:1448
+#: speech.c:238 speech.c:1435 speech.c:1497
 msgid "You may not speak there!"
 msgstr ""
 
-#: speech.c:260
+#: speech.c:270
 msgid "Too many people to oemit to."
 msgstr ""
 
-#: speech.c:305
+#: speech.c:326
 msgid "Whisper to whom?"
 msgstr ""
 
-#: speech.c:309
+#: speech.c:330
 msgid "Whisper what?"
 msgstr ""
 
-#: speech.c:343
+#: speech.c:364
 #, c-format
 msgid "%s can't hear you."
 msgstr ""
 
-#: speech.c:348
+#: speech.c:369
 msgid "Too many people to whisper to."
 msgstr ""
 
-#: speech.c:356
+#: speech.c:377
 #, c-format
 msgid "Unable to whisper to:%s"
 msgstr ""
 
-#: speech.c:369 wiz.c:1286
+#: speech.c:390 wiz.c:1302
 msgid " to "
 msgstr ""
 
-#: speech.c:379
+#: speech.c:400
 #, c-format
 msgid "%s sense: %s%s%s"
 msgstr ""
 
-#: speech.c:380
+#: speech.c:401
 #, c-format
 msgid "%s senses: %s%s%s"
 msgstr ""
 
-#: speech.c:383
+#: speech.c:404
 #, c-format
 msgid "You whisper, \"%s\"%s."
 msgstr ""
 
-#: speech.c:384
+#: speech.c:405
 #, c-format
 msgid "%s whispers%s: %s"
 msgstr ""
 
-#: speech.c:397
+#: speech.c:418
 #, c-format
 msgid "%s whispers%s."
 msgstr ""
 
-#: speech.c:572 speech.c:1383
+#: speech.c:592 speech.c:1431
 #, c-format
 msgid "I'm sorry, but %s wishes to be left alone now."
 msgstr ""
 
-#: speech.c:656
+#: speech.c:675
 msgid "Posing as a wizard could be hazardous to your health."
 msgstr ""
 
-#: speech.c:677
+#: speech.c:696
 msgid "What did you want to say?"
 msgstr ""
 
-#: speech.c:702
+#: speech.c:721
 msgid "shouts"
 msgstr ""
 
-#: speech.c:702
+#: speech.c:721
 msgid "says"
 msgstr ""
 
-#: speech.c:834
+#: speech.c:853
 msgid "You haven't paged anyone since connecting."
 msgstr ""
 
-#: speech.c:840
+#: speech.c:872
+msgid "I can't find who you last paged."
+msgstr ""
+
+#: speech.c:880
 #, c-format
 msgid "You last paged %s."
 msgstr ""
 
-#: speech.c:854
+#: speech.c:895
 msgid "Try again after you get the pemit_all power."
 msgstr ""
 
-#: speech.c:866
+#: speech.c:907
 #, c-format
 msgid "I can't find who you're trying to page with: %s"
 msgstr ""
 
-#: speech.c:872
+#: speech.c:913
 #, c-format
 msgid "I'm not sure who you want to page with: %s"
 msgstr ""
 
-#: speech.c:882
+#: speech.c:923
 #, c-format
 msgid "%s is not connected."
 msgstr ""
 
-#: speech.c:889
+#: speech.c:930
 #, c-format
 msgid "%s is not accepting any pages."
 msgstr ""
 
-#: speech.c:894
+#: speech.c:935
 #, c-format
 msgid "%s is not accepting your pages."
 msgstr ""
 
-#: speech.c:917
+#: speech.c:958
 msgid "You're trying to page too many people at once."
 msgstr ""
 
-#: speech.c:932
+#: speech.c:973
 #, c-format
 msgid "Unable to page:%s"
 msgstr ""
 
-#: speech.c:962
+#: speech.c:1003
 msgid "You are set HAVEN and cannot receive pages."
 msgstr ""
 
-#: speech.c:1014
+#: speech.c:1057
 msgid "From afar"
 msgstr ""
 
-#: speech.c:1016
+#: speech.c:1059
 msgid " (to "
 msgstr ""
 
-#: speech.c:1025
+#: speech.c:1068
 msgid " pages"
 msgstr ""
 
-#: speech.c:1159
+#: speech.c:1121
+#, c-format
+msgid "You paged %s, but they are unable to page you."
+msgstr ""
+
+#: speech.c:1207
 msgid "From "
 msgstr ""
 
-#: speech.c:1377
+#: speech.c:1425
 msgid "I can't find that."
 msgstr ""
 
-#: speech.c:1380
+#: speech.c:1428
 msgid "There can't be anything in that!"
 msgstr ""
 
-#: speech.c:1392
+#: speech.c:1441
 #, c-format
 msgid "You remit, \"%s\" in %s"
 msgstr ""
 
-#: speech.c:1445
+#: speech.c:1494
 msgid "Too many containers."
 msgstr ""
 
-#: speech.c:1453
+#: speech.c:1502
 #, c-format
 msgid "You lemit: \"%s\""
 msgstr ""
 
-#: speech.c:1513
+#: speech.c:1562
 msgid "Invalid zone."
 msgstr ""
 
-#: speech.c:1522
+#: speech.c:1572
 #, c-format
 msgid "You zemit, \"%s\" in zone %s"
 msgstr ""
 
-#: sql.c:79
+#: sql.c:80
 msgid "#-1 SQL ERROR: NO DATABASE CONNECTED"
 msgstr ""
 
-#: sql.c:81
+#: sql.c:82
 #, c-format
 msgid "#-1 SQL ERROR: %s"
 msgstr ""
 
-#: sql.c:293 sql.c:352
+#: sql.c:294 sql.c:388 sql.c:525
 msgid "No SQL database connection."
 msgstr ""
 
-#: sql.c:325
+#: sql.c:326
 msgid "#-1 TOO LONG"
 msgstr ""
 
-#: sql.c:350
+#: sql.c:386 sql.c:523
 #, c-format
 msgid "SQL: %d rows affected."
 msgstr ""
 
-#: sql.c:354 sql.c:401
+#: sql.c:390 sql.c:437 sql.c:527 sql.c:574
 #, c-format
 msgid "SQL: Error: %s"
 msgstr ""
 
-#: sql.c:443
+#: sql.c:616
 #, c-format
 msgid "Row %d, Field %s: %s"
 msgstr ""
 
-#: sql.c:447
+#: sql.c:620
 #, c-format
 msgid "Row %d: NULL"
 msgstr ""
 
-#: timer.c:261
+#: timer.c:270
 msgid "Your ON-VACATION flag is set! If you're back, clear it."
 msgstr ""
 
@@ -6325,511 +6363,521 @@
 msgid "@wcheck complete."
 msgstr ""
 
-#: wiz.c:119
+#: wiz.c:124
 msgid "You do not have the power over body and mind!"
 msgstr ""
 
-#: wiz.c:131
+#: wiz.c:136
 #, c-format
 msgid "Failure creating '%s' (bad name)"
 msgstr ""
 
-#: wiz.c:135
+#: wiz.c:140
 #, c-format
 msgid "Failure creating '%s' (bad password)"
 msgstr ""
 
-#: wiz.c:139
+#: wiz.c:144
 #, c-format
 msgid "New player '%s' (#%d) created with password '%s'"
 msgstr ""
 
-#: wiz.c:166 wiz.c:784
+#: wiz.c:173 wiz.c:800
 msgid "No such player."
 msgstr ""
 
-#: wiz.c:173
+#: wiz.c:180
 msgid "Only wizards may change a quota."
 msgstr ""
 
-#: wiz.c:177
+#: wiz.c:184
 msgid "You can't look at someone else's quota."
 msgstr ""
 
-#: wiz.c:191
+#: wiz.c:198
 #, c-format
 msgid "Objects: %d   Limit: UNLIMITED"
 msgstr ""
 
-#: wiz.c:200 wiz.c:206 wiz.c:220
+#: wiz.c:207 wiz.c:213 wiz.c:227
 #, c-format
 msgid "Objects: %d   Limit: %d"
 msgstr ""
 
-#: wiz.c:207
+#: wiz.c:214
 msgid "What do you want to set the quota to?"
 msgstr ""
 
-#: wiz.c:239
+#: wiz.c:246
 msgid "Who do you think you are, GOD?"
 msgstr ""
 
-#: wiz.c:245
+#: wiz.c:252
 msgid "You can only set quotas to a number."
 msgstr ""
 
-#: wiz.c:250
+#: wiz.c:257
 msgid "You can only set quotas to a positive number."
 msgstr ""
 
-#: wiz.c:270
+#: wiz.c:277
 #, c-format
 msgid "%s: Objects: %d   Limit: UNLIMITED"
 msgstr ""
 
-#: wiz.c:276
+#: wiz.c:283
 #, c-format
 msgid "%s: Objects: %d   Limit: %d"
 msgstr ""
 
-#: wiz.c:287
+#: wiz.c:294
 msgid "Quotas not changed."
 msgstr ""
 
-#: wiz.c:289
+#: wiz.c:296
 #, c-format
 msgid "All quotas changed to %d."
 msgstr ""
 
-#: wiz.c:376
+#: wiz.c:383
 msgid "You can't teleport rooms."
 msgstr ""
 
-#: wiz.c:380
+#: wiz.c:387
 msgid "Garbage belongs in the garbage dump."
 msgstr ""
 
-#: wiz.c:404
+#: wiz.c:412
 msgid "I don't know which destination you mean!"
 msgstr ""
 
-#: wiz.c:427
+#: wiz.c:435
 msgid "Exits can only be teleported to other rooms."
 msgstr ""
 
-#: wiz.c:432
+#: wiz.c:440
 msgid "You can't move an exit to someplace that's crumbling."
 msgstr ""
 
-#: wiz.c:453 wiz.c:562
+#: wiz.c:461 wiz.c:570
 msgid "Teleported."
 msgstr ""
 
-#: wiz.c:474
+#: wiz.c:482
 msgid "You're in the Void. This is not a good thing."
 msgstr ""
 
-#: wiz.c:486
+#: wiz.c:494
 msgid "What are you doing inside of yourself?"
 msgstr ""
 
-#: wiz.c:496
+#: wiz.c:504
 msgid "You're in the void - sending you home."
 msgstr ""
 
-#: wiz.c:504
+#: wiz.c:512
 msgid "You're in too many containers."
 msgstr ""
 
-#: wiz.c:519 wiz.c:527
+#: wiz.c:527 wiz.c:535
 msgid "Teleports are not allowed in this room."
 msgstr ""
 
-#: wiz.c:540
+#: wiz.c:548
 msgid "You may not teleport out of the zone from this room."
 msgstr ""
 
-#: wiz.c:581
+#: wiz.c:589
 #, c-format
 msgid "%s tries to impose his will on you and fails."
 msgstr ""
 
-#: wiz.c:619
+#: wiz.c:629
 msgid "You can't force God!"
 msgstr ""
 
-#: wiz.c:733
+#: wiz.c:749
 msgid "You need a search warrant to do that!"
 msgstr ""
 
-#: wiz.c:741
+#: wiz.c:757
 #, c-format
 msgid "%d objects = %d rooms, %d exits, %d things, %d players, %d garbage."
 msgstr ""
 
-#: wiz.c:745
+#: wiz.c:761
 #, c-format
 msgid "The next object to be created will be #%d."
 msgstr ""
 
-#: wiz.c:749
+#: wiz.c:765
 #, c-format
 msgid "%d objects = %d rooms, %d exits, %d things, %d players."
 msgstr ""
 
-#: wiz.c:787
+#: wiz.c:803
 msgid "Bad password."
 msgstr ""
 
-#: wiz.c:789
+#: wiz.c:805
 msgid "You cannot change that player's password."
 msgstr ""
 
-#: wiz.c:793
+#: wiz.c:809
 #, c-format
 msgid "Password for %s changed."
 msgstr ""
 
-#: wiz.c:794
+#: wiz.c:810
 #, c-format
 msgid "Your password has been changed by %s."
 msgstr ""
 
-#: wiz.c:821
+#: wiz.c:837
 msgid "No such connected player."
 msgstr ""
 
-#: wiz.c:832
+#: wiz.c:848
 msgid "Invalid port."
 msgstr ""
 
-#: wiz.c:838
+#: wiz.c:854
 msgid "There is noone connected on that descriptor."
 msgstr ""
 
-#: wiz.c:840 wiz.c:857
+#: wiz.c:856 wiz.c:873
 msgid "You can't boot other people!"
 msgstr ""
 
-#: wiz.c:845
+#: wiz.c:861
 msgid "If you want to quit, use QUIT."
 msgstr ""
 
-#: wiz.c:866
+#: wiz.c:882
 msgid "You boot a duplicate self."
 msgstr ""
 
-#: wiz.c:868 wiz.c:882
+#: wiz.c:884 wiz.c:898
 #, c-format
 msgid "You booted %s off!"
 msgstr ""
 
-#: wiz.c:870
+#: wiz.c:886
 #, c-format
 msgid "You booted unconnected port %s!"
 msgstr ""
 
-#: wiz.c:888
+#: wiz.c:904
 msgid "None of your connections are idle. If you want to quit, use QUIT."
 msgstr ""
 
-#: wiz.c:913
+#: wiz.c:929
 msgid "Try asking them first!"
 msgstr ""
 
-#: wiz.c:944
+#: wiz.c:960
 #, c-format
 msgid "Ownership changed for %d objects."
 msgstr ""
 
-#: wiz.c:964
+#: wiz.c:980
 msgid "You do not have the power to change reality."
 msgstr ""
 
-#: wiz.c:973
+#: wiz.c:989
 msgid "No zone specified."
 msgstr ""
 
-#: wiz.c:981
+#: wiz.c:997
 msgid "I can't seem to find that."
 msgstr ""
 
-#: wiz.c:997
+#: wiz.c:1013
 #, c-format
 msgid "Zone changed for %d objects."
 msgstr ""
 
-#: wiz.c:1021
+#: wiz.c:1037
 msgid "How many commands do you want to execute?"
 msgstr ""
 
-#: wiz.c:1027
+#: wiz.c:1043
 msgid "Number out of range."
 msgstr ""
 
-#: wiz.c:1032
+#: wiz.c:1048
 #, c-format
 msgid "%d commands executed."
 msgstr ""
 
-#: wiz.c:1056
+#: wiz.c:1072
 #, c-format
 msgid "Flags value: %s"
 msgstr ""
 
-#: wiz.c:1058
+#: wiz.c:1074
 #, c-format
 msgid "Powers value: %s"
 msgstr ""
 
-#: wiz.c:1061
+#: wiz.c:1077
 #, c-format
 msgid "Next: %d"
 msgstr ""
 
-#: wiz.c:1062
+#: wiz.c:1078
 #, c-format
 msgid "Contents: %d"
 msgstr ""
 
-#: wiz.c:1063
+#: wiz.c:1079
 #, c-format
 msgid "Pennies: %d"
 msgstr ""
 
-#: wiz.c:1069
+#: wiz.c:1085
 #, c-format
 msgid "Location: %d"
 msgstr ""
 
-#: wiz.c:1070
+#: wiz.c:1086
 #, c-format
 msgid "Home: %d"
 msgstr ""
 
-#: wiz.c:1073
+#: wiz.c:1089
 #, c-format
 msgid "Destination: %d"
 msgstr ""
 
-#: wiz.c:1074
+#: wiz.c:1090
 #, c-format
 msgid "Source: %d"
 msgstr ""
 
-#: wiz.c:1077
+#: wiz.c:1093
 #, c-format
 msgid "Drop-to: %d"
 msgstr ""
 
-#: wiz.c:1078
+#: wiz.c:1094
 #, c-format
 msgid "Exits: %d"
 msgstr ""
 
-#: wiz.c:1083
+#: wiz.c:1099
 msgid "Bad object type."
 msgstr ""
 
-#: wiz.c:1112
+#: wiz.c:1128
 msgid "Only wizards may grant powers."
 msgstr ""
 
-#: wiz.c:1119
+#: wiz.c:1135
 msgid "You can't grant powers to unregistered players."
 msgstr ""
 
-#: wiz.c:1123
+#: wiz.c:1139
 msgid "God is already all-powerful."
 msgstr ""
 
-#: wiz.c:1130
+#: wiz.c:1146
 msgid "You must specify a power to set."
 msgstr ""
 
-#: wiz.c:1259
+#: wiz.c:1275
 msgid ""
 "\n"
 "ROOMS:"
 msgstr ""
 
-#: wiz.c:1262 wiz.c:1299
+#: wiz.c:1278 wiz.c:1315
 #, c-format
 msgid "%s [owner: "
 msgstr ""
 
-#: wiz.c:1274
+#: wiz.c:1290
 msgid ""
 "\n"
 "EXITS:"
 msgstr ""
 
-#: wiz.c:1282
+#: wiz.c:1298
 #, c-format
 msgid "%s [from "
 msgstr ""
 
-#: wiz.c:1284 wiz.c:1287
+#: wiz.c:1300 wiz.c:1303
 msgid "NOWHERE"
 msgstr ""
 
-#: wiz.c:1296
+#: wiz.c:1312
 msgid ""
 "\n"
 "THINGS:"
 msgstr ""
 
-#: wiz.c:1310
+#: wiz.c:1326
 msgid ""
 "\n"
 "PLAYERS:"
 msgstr ""
 
-#: wiz.c:1316
+#: wiz.c:1332
 #, c-format
 msgid " [location: %s]"
 msgstr ""
 
-#: wiz.c:1324
+#: wiz.c:1340
 msgid ""
 "\n"
 "GARBAGE:"
 msgstr ""
 
-#: wiz.c:1328
+#: wiz.c:1344
 #, c-format
 msgid "%sGarbage%s(#%d)"
 msgstr ""
 
-#: wiz.c:1331
+#: wiz.c:1347
 #, c-format
 msgid "Garbage(#%d)"
 msgstr ""
 
-#: wiz.c:1335
+#: wiz.c:1351
 msgid "----------  Search Done  ----------"
 msgstr ""
 
-#: wiz.c:1339
+#: wiz.c:1355
 #, c-format
 msgid "Totals: Rooms...%d  Exits...%d  Things...%d  Players...%d  Garbage...%d"
 msgstr ""
 
-#: wiz.c:1430
+#: wiz.c:1446
 msgid "You can't see someone else's quota!"
 msgstr ""
 
-#: wiz.c:1467 wiz.c:1581
+#: wiz.c:1494
+#, c-format
+msgid "Sitelocked %d known addresses for %s"
+msgstr ""
+
+#: wiz.c:1497
+#, c-format
+msgid "Unable to sitelock %s: No known ip/host to ban."
+msgstr ""
+
+#: wiz.c:1519 wiz.c:1661
 msgid "Your delusions of grandeur have been noted."
 msgstr ""
 
-#: wiz.c:1475
+#: wiz.c:1527
 msgid "What site did you want to lock?"
 msgstr ""
 
-#: wiz.c:1480
+#: wiz.c:1532
 msgid "No valid options found."
 msgstr ""
 
-#: wiz.c:1486
+#: wiz.c:1538
 msgid "Who do you want to lock?"
 msgstr ""
 
-#: wiz.c:1495
+#: wiz.c:1550
 #, c-format
 msgid "Site %s access options for %s(%s) set to %s"
 msgstr ""
 
-#: wiz.c:1501
+#: wiz.c:1556
 #, c-format
 msgid "Site %s access options set to %s"
 msgstr ""
 
-#: wiz.c:1521 wiz.c:1528
+#: wiz.c:1580 wiz.c:1591
 #, c-format
 msgid "Site %s locked"
 msgstr ""
 
-#: wiz.c:1535
+#: wiz.c:1602
 #, c-format
 msgid "Site %s banned"
 msgstr ""
 
-#: wiz.c:1559
+#: wiz.c:1639
 #, c-format
 msgid "%d sitelocks removed."
 msgstr ""
 
-#: wiz.c:1590
+#: wiz.c:1670
 msgid "Unable to open names file."
 msgstr ""
 
-#: wiz.c:1592
+#: wiz.c:1672
 msgid "Any name matching these wildcard patterns is banned:"
 msgstr ""
 
-#: wiz.c:1605 wiz.c:1626 wiz.c:1630
+#: wiz.c:1685 wiz.c:1706 wiz.c:1710
 msgid "Unable to delete name."
 msgstr ""
 
-#: wiz.c:1623
+#: wiz.c:1703
 msgid "Name removed."
 msgstr ""
 
-#: wiz.c:1634 wiz.c:1666
+#: wiz.c:1714 wiz.c:1746
 msgid "Unable to lock name."
 msgstr ""
 
-#: wiz.c:1663
+#: wiz.c:1743
 #, c-format
 msgid "Name %s locked."
 msgstr ""
 
-#: wiz.c:1798
+#: wiz.c:1879
 msgid "Unknown owner."
 msgstr ""
 
-#: wiz.c:1803
+#: wiz.c:1884
 msgid "Invalid search class+restriction format."
 msgstr ""
 
-#: wiz.c:1874
+#: wiz.c:1955
 msgid "Unknown type."
 msgstr ""
 
-#: wiz.c:1895
+#: wiz.c:1976
 msgid "Invalid start index"
 msgstr ""
 
-#: wiz.c:1901
+#: wiz.c:1982
 msgid "Invalid count index"
 msgstr ""
 
-#: wiz.c:1910 wiz.c:1915
+#: wiz.c:1991 wiz.c:1996
 msgid "Unknown parent."
 msgstr ""
 
-#: wiz.c:1924 wiz.c:1929
+#: wiz.c:2005 wiz.c:2010
 msgid "Unknown zone."
 msgstr ""
 
-#: wiz.c:1960
+#: wiz.c:2041
 msgid "You must give a list of power names."
 msgstr ""
 
-#: wiz.c:1967
+#: wiz.c:2048
 msgid "You must give a string of flag characters."
 msgstr ""
 
-#: wiz.c:1974
+#: wiz.c:2055
 msgid "You must give a list of flag names."
 msgstr ""
 
-#: wiz.c:1979
+#: wiz.c:2060
 msgid "Unknown search class."
 msgstr ""
 
-#: wiz.c:2030
+#: wiz.c:2111
 #, c-format
 msgid "Searches cost %d %s."
 msgstr ""
Index: po/fr_FR.pox
===================================================================
--- po/fr_FR.pox	(.../184p2)	(revision 828)
+++ po/fr_FR.pox	(.../184p3)	(revision 828)
@@ -2880,10 +2880,6 @@
 msgid "That is not a valid lock name."
 msgstr "Ce nom de verrou n'est pas valide."
 
-#: src/log.c:355
-msgid "That is not a valid log."
-msgstr "Ce n'est pas un log valide."
-
 #: src/create.c:54
 msgid "That is not a valid object."
 msgstr "Cet objet n'est pas valide."
@@ -3913,10 +3909,6 @@
 msgid "You must carry the object to @chown it."
 msgstr "Vous devez porter l'objet pour utiliser @chown sur celui-ci."
 
-#: cmds.c:424
-msgid "You must give a switch for @hook"
-msgstr "Vous devez passer un switch  @hook"
-
 #: command.c:1357
 msgid "You must give both an object and attribute."
 msgstr "Vous devez spcifier  la fois un objet et un attribut."
Index: po/bg_BG.pox
===================================================================
--- po/bg_BG.pox	(.../184p2)	(revision 828)
+++ po/bg_BG.pox	(.../184p3)	(revision 828)
@@ -2032,11 +2032,6 @@
 msgid "This is an automated message.\n"
 msgstr "   .\n"
 
-#: extchat.c:1836
-#, c-format
-msgid "Title %s for %schannel <%s>."
-msgstr " %s  %s <%s>."
-
 #: src/player.c:301
 #, c-format
 msgid "To access this character, connect to %s and type:\n"
@@ -2340,10 +2335,6 @@
 msgid "You must carry the object to @chown it."
 msgstr "        @chown."
 
-#: cmds.c:424
-msgid "You must give a switch for @hook"
-msgstr "     @hook"
-
 #: flags.c:2006
 #, c-format
 msgid "You must provide a name for the %s."
Index: po/de_DE.pox
===================================================================
--- po/de_DE.pox	(.../184p2)	(revision 828)
+++ po/de_DE.pox	(.../184p3)	(revision 828)
@@ -1862,10 +1862,6 @@
 msgid "That is not a valid channel."
 msgstr "Das ist kein gltiger Channel."
 
-#: src/log.c:355
-msgid "That is not a valid log."
-msgstr "Das ist kein gltiges Log."
-
 #: src/create.c:54
 msgid "That is not a valid object."
 msgstr "Das ist kein gltiges Objekt."
Index: po/da_DK.pox
===================================================================
--- po/da_DK.pox	(.../184p2)	(revision 828)
+++ po/da_DK.pox	(.../184p3)	(revision 828)
@@ -1593,10 +1593,6 @@
 msgid "That is not a valid lock name."
 msgstr "Det er ikke et rum!"
 
-#: src/log.c:355
-msgid "That is not a valid log."
-msgstr "Det er ikke et rum!"
-
 #: src/create.c:54
 msgid "That is not a valid object."
 msgstr "Det er ikke et rum!"
Index: po/hr_HR.pox
===================================================================
--- po/hr_HR.pox	(.../184p2)	(revision 828)
+++ po/hr_HR.pox	(.../184p3)	(revision 828)
@@ -963,6 +963,11 @@
 msgid "%s doesn't want that."
 msgstr "%s to ne eli."
 
+#: rob.c:330
+#, c-format
+msgid "%s doesn't want your money."
+msgstr "%s ne eli tvoj novac."
+
 #: move.c:641 move.c:644
 #, c-format
 msgid "%s drops you."
@@ -1448,10 +1453,6 @@
 msgid "@command is ALWAYS enabled."
 msgstr "@command je UVIJEK ukljuen."
 
-#: cque.c:695
-msgid "@include recursion exceeded."
-msgstr "Prekoraeno ogranienje rekurzije naredbe @include."
-
 #: cmds.c:687
 msgid "@message them with what?"
 msgstr "Koju poruku im eli poslati s @message?"
@@ -1710,6 +1711,10 @@
 msgid "Bad password."
 msgstr "Loa ifra."
 
+#: log.c:358
+msgid "Begin log recall."
+msgstr "Poetak ispisa loga."
+
 #: src/set.c:147
 #, c-format
 msgid "Broadcast: Suspect %s changed name to %s."
@@ -2364,12 +2369,16 @@
 
 #: access.c:425
 msgid "Email registration is allowed"
-msgstr "Registracija putem elektronike poste je dozvoljena"
+msgstr "Registracija putem elektronike pote je dozvoljena"
 
 #: wiz.c:1013
 msgid "Enabled."
 msgstr "Ukljueno."
 
+#: log.c:365
+msgid "End log recall."
+msgstr "Kraj ispisa loga."
+
 #: atr_tab.c:647
 msgid "Enum"
 msgstr "Enum"
@@ -2810,6 +2819,10 @@
 msgid "I can't find that."
 msgstr "Ne mogu to pronai."
 
+#: speech.c:869
+msgid "I can't find who you last paged."
+msgstr "Ne mogu nai zadnjeg primatelja tvojih privatnih poruka."
+
 #: speech.c:686
 #, c-format
 msgid "I can't find who you're trying to page with: %s"
@@ -3660,6 +3673,11 @@
 msgid "MAIL: You probably don't wanna send mail saying 'clear'."
 msgstr "POTA: Vjerojatno ne eli poslati pismo u kojem pie 'clear'."
 
+#: extmail.c:1310
+#, c-format
+msgid "MAIL: You sent your message to %s, but they can't mail you!"
+msgstr "POTA: %s primi tvoju poruku, ali ne moe tebi slati potu!"
+
 #: src/extmail.c:1090
 #, c-format
 msgid "MAIL: You sent your message to %s."
@@ -3856,6 +3874,11 @@
 msgid "No entries matching '%s' were found."
 msgstr "Nije naen nijedan tekst koji se podudara s '%s'."
 
+#: help.c:119 help.c:129 help.c:139 help.c:146
+#, c-format
+msgid "No entry for '%s'"
+msgstr "Nita ne pie pod '%s'"
+
 #: src/bsd.c:3090
 #, c-format
 msgid "No entry for '%s'."
@@ -4483,6 +4506,11 @@
 msgid "Site %s locked"
 msgstr "Internet adresa %s zakljuana"
 
+#: wiz.c:1481
+#, c-format
+msgid "Sitelocked %d known addresses for %s"
+msgstr "Zakljuano %d poznatih adresa za %s"
+
 #: src/destroy.c:266
 msgid "Sorry, no suicide allowed."
 msgstr "Naalost, samoubojstvo je zabranjeno."
@@ -4657,6 +4685,10 @@
 msgid "That is an exit."
 msgstr "To je izlaz."
 
+#: log.c:402
+msgid "That is not a clearable log."
+msgstr "Taj log ne moe biti obrisan."
+
 #: src/extmail.c:1218
 msgid "That is not a debugging option."
 msgstr "To nije opcija za debagiranje."
@@ -4681,10 +4713,6 @@
 msgid "That is not a valid lock name."
 msgstr "To nije ispravno ime brave."
 
-#: src/log.c:355
-msgid "That is not a valid log."
-msgstr "To nije ispravan log."
-
 #: src/create.c:54
 msgid "That is not a valid object."
 msgstr "To nije ispravan objekt."
@@ -4890,7 +4918,7 @@
 #: src/destroy.c:341
 #, c-format
 msgid "The wrecking ball is on its way for %s's %s and its exits."
-msgstr "Sluba za ruenje zgrada je na putu prema sobi %s korisnika '%s' i njenim izlazima."
+msgstr "Sluba za ruenje zgrada je na putu prema sobi korisnika %s '%s' i njenim izlazima."
 
 #: src/extmail.c:1281
 #, c-format
@@ -4954,10 +4982,6 @@
 msgid "There's nothing left of it to clone!"
 msgstr "Od toga nita nije ostalo pa se ne moe ni klonirati!"
 
-#: player.c:190
-msgid "This IP address has failed too many times. Please try again in 10 minutes."
-msgstr "Prevelik broj neuspjenih spajanja s te IP adrese. Molim, pokuati ponovo za 10 minuta."
-
 #: command.c:1562
 msgid "This command has not been implemented."
 msgstr "Ova naredba se ne koristi."
@@ -5006,10 +5030,15 @@
 msgid "TinyMUSH compatibility options"
 msgstr "Opcije za kompatibilnost s TinyMUSHom"
 
-#: extchat.c:1836
+#: extchat.c:2088
 #, c-format
-msgid "Title %s for %schannel <%s>."
-msgstr "Titula %s za %skanal <%s>."
+msgid "Title cleared for %schannel <%s>."
+msgstr "Titula obrisana za %skanal <%s>."
+
+#: extchat.c:2111
+#, c-format
+msgid "Title set for %schannel <%s>."
+msgstr "Titula postavljena za %skanal <%s>."
 
 #: src/extchat.c:1358
 msgid "Title too long."
@@ -5025,6 +5054,10 @@
 msgid "To channel %s: %s"
 msgstr "Na kanal %s: %s"
 
+#: set.c:88
+msgid "Too many aliases."
+msgstr "Previe aliasa."
+
 #: src/set.c:906
 msgid "Too many ancestors."
 msgstr "Previe predaka."
@@ -5161,6 +5194,11 @@
 msgid "Unable to set alias."
 msgstr "Ne mogu postaviti alias."
 
+#: wiz.c:1483
+#, c-format
+msgid "Unable to sitelock %s: No known ip/host to ban."
+msgstr "Ne mogu zakljuati adresu %s: Nema poznatog ip/hosta za bananje."
+
 #: speech.c:355
 #, c-format
 msgid "Unable to whisper to:%s"
@@ -5650,6 +5688,10 @@
 msgid "You can only set quotas to a positive number."
 msgstr "Za quotu moe postaviti samo pozitivan broj."
 
+#: cmds.c:530
+msgid "You can only use /inplace with /override."
+msgstr "/inplace moe koristiti samo s /override."
+
 #: rob.c:326
 msgid "You can't afford that."
 msgstr "Nema novaca za to."
@@ -6098,9 +6140,9 @@
 msgid "You must give a string of flag characters."
 msgstr "Mora navesti string znakova za flagove."
 
-#: cmds.c:424
-msgid "You must give a switch for @hook"
-msgstr "Mora navesti switch za @hook"
+#: cmds.c:525
+msgid "You must give a switch for @hook."
+msgstr "Mora navesti switch za @hook."
 
 #: command.c:2073
 msgid "You must give an object."
@@ -6240,6 +6282,11 @@
 msgid "You paged %s with '%s'"
 msgstr "%s dobije tvoju poruku '%s'"
 
+#: speech.c:1081
+#, c-format
+msgid "You paged %s, but they are unable to page you."
+msgstr "%s primi tvoju privatnu poruku, ali ne moe tebi slati privatne poruke."
+
 #: src/rob.c:263
 #, c-format
 msgid "You paid %d %s."
@@ -6514,7 +6561,7 @@
 "MAIL: You have no mail.\n"
 msgstr ""
 "\n"
-"POSTA: Nema pote.\n"
+"POTA: Nema pote.\n"
 
 #: wiz.c:1284
 msgid ""
Index: po/nl_NL.pox
===================================================================
--- po/nl_NL.pox	(.../184p2)	(revision 828)
+++ po/nl_NL.pox	(.../184p3)	(revision 828)
@@ -642,6 +642,10 @@
 msgid "#-1 TOO MANY ITERS"
 msgstr "#-1 TEVEEL ITERS"
 
+#: funmisc.c:495 funmisc.c:612
+msgid "#-1 TOO MANY SWITCHES"
+msgstr "#-1 TE VEEL SCHAKELOPTIES"
+
 #: src/funlist.c:1782
 msgid "#-1 TOO MANY WORDS"
 msgstr "#-1 TE VEEL WOORDEN"
@@ -834,6 +838,21 @@
 msgid "%s - Triggered."
 msgstr "%s - Getriggerd."
 
+#: atr_tab.c:440
+#, c-format
+msgid "%s -- Attribute %s set to: %s"
+msgstr "%s -- Attribuut %s gezet als: %s"
+
+#: atr_tab.c:432
+#, c-format
+msgid "%s -- Attribute limit or enum already unset."
+msgstr "%s -- Attribuut limiet of enum was al uitgeschakeld."
+
+#: atr_tab.c:429
+#, c-format
+msgid "%s -- Attribute limit or enum unset."
+msgstr "%s -- Attribuut limiet of enum uitgeschakeld."
+
 #: src/atr_tab.c:226
 #, c-format
 msgid "%s -- Attribute permissions now: %s"
@@ -944,6 +963,11 @@
 msgid "%s doesn't want that."
 msgstr "%s wil dat niet."
 
+#: rob.c:330
+#, c-format
+msgid "%s doesn't want your money."
+msgstr "%s hoeft jouw geld niet."
+
 #: move.c:641 move.c:644
 #, c-format
 msgid "%s drops you."
@@ -1349,6 +1373,11 @@
 msgid "'%s' is not a valid alias."
 msgstr "'%s' is geen geldig alias."
 
+#: attrib.c:1851
+#, c-format
+msgid "'%s' is not a valid exit name."
+msgstr "'%s' is niet een geldige naam voor een uitgang."
+
 #: function.c:905
 msgid "(Commas okay in last argument)"
 msgstr "(Komma's zijn ok in het laatste argument)"
@@ -1424,10 +1453,6 @@
 msgid "@command is ALWAYS enabled."
 msgstr "@command is ALTIJD ingeschakeld."
 
-#: cque.c:695
-msgid "@include recursion exceeded."
-msgstr "@include recursie overschreden."
-
 #: cmds.c:687
 msgid "@message them with what?"
 msgstr "@message met wat?"
@@ -1470,6 +1495,10 @@
 msgid "Address: %s"
 msgstr "Adres: %s"
 
+#: conf.c:1386
+msgid "Admin:"
+msgstr "Admin:"
+
 #: src/destroy.c:405
 msgid "Alas, your efforts of mercy are in vain."
 msgstr "Helaas, je pogingen om genade te tonen helpen niet."
@@ -1506,6 +1535,10 @@
 msgid "All but wizards"
 msgstr "Allen behalve wizards"
 
+#: extchat.c:1924
+msgid "All channels have been combined."
+msgstr "Alle kanalen zijn gecombineerd."
+
 #: extchat.c:1597
 msgid "All channels have been gagged."
 msgstr "Alle kanalen zijn tijdelijk afgezet."
@@ -1514,6 +1547,10 @@
 msgid "All channels have been muted."
 msgstr "Alle kanalen zijn op mute gezet."
 
+#: extchat.c:1925
+msgid "All channels have been uncombined."
+msgstr "Alle kanalen zijn gedecombineerd."
+
 #: extchat.c:1598
 msgid "All channels have been ungagged."
 msgstr "Alle kanalen zijn niet langer tijdelijk afgezet."
@@ -1559,6 +1596,10 @@
 msgid "All"
 msgstr "Alle"
 
+#: conf.c:1387
+msgid "Announcement:"
+msgstr "Omroepbericht:"
+
 #: wiz.c:1810
 msgid "Any name matching these wildcard patterns is banned:"
 msgstr "Iedere naam die met deze wildcard patronen overeenkomt is verboden:"
@@ -1620,6 +1661,10 @@
 msgid "Attribute unlocked."
 msgstr "Attribuut ontgrendeld."
 
+#: atr_tab.c:259
+msgid "Attribute value does not match the /limit regexp."
+msgstr "Attribuut waarde komt niet overeen met de /limit regexp."
+
 #: atr_tab.c:349
 msgid "Attribute"
 msgstr "Attribuut"
@@ -1666,6 +1711,10 @@
 msgid "Bad password."
 msgstr "Ongeldig wachtwoord."
 
+#: log.c:358
+msgid "Begin log recall."
+msgstr "Begin log recall."
+
 #: src/set.c:147
 #, c-format
 msgid "Broadcast: Suspect %s changed name to %s."
@@ -1676,6 +1725,10 @@
 msgid "Broadcast: Suspect %s tried to kill %s(#%d)."
 msgstr "Attentie: Verdachte %s probeerde %s (#%d) te vermoorden."
 
+#: conf.c:1385
+msgid "Broadcast:"
+msgstr "Omroep:"
+
 #: extchat.c:2085
 msgid "Buf"
 msgstr "Buf"
@@ -2083,6 +2136,16 @@
 msgid "Compiler: %s"
 msgstr "Compiler: %s"
 
+#: extchat.c:2024
+#, c-format
+msgid "Connect messages on channel <%s> will no longer be combined with others."
+msgstr "Connect berichten op kanaal <%s> zullen niet langer worden gecombineerd met anderen."
+
+#: extchat.c:2018
+#, c-format
+msgid "Connect messages on channel <%s> will now be combined with others."
+msgstr "Connect berichten op kanaal <%s> zullen nu worden gecombineerd met anderen."
+
 #: bsd.c:4386 bsd.c:4395
 msgid "Connecting..."
 msgstr "Bezig met inloggen..."
@@ -2175,6 +2238,10 @@
 msgid "Default flags for new objects"
 msgstr "Standaard vlaggen voor nieuwe objecten"
 
+#: atr_tab.c:364
+msgid "Delimiter must be one character."
+msgstr "Delimiter moet n karakter zijn."
+
 #: access.c:429
 msgid "Denied connections are not logged"
 msgstr "Niet toegestane verbindingen worden niet gelogd"
@@ -2308,6 +2375,14 @@
 msgid "Enabled."
 msgstr "Ingeschakeld."
 
+#: log.c:365
+msgid "End log recall."
+msgstr "Einde log recall."
+
+#: atr_tab.c:647
+msgid "Enum"
+msgstr "Enum"
+
 #: src/game.c:1465
 msgid "Error -- cannot execute uptime."
 msgstr "Fout -- kan uptime niet uitvoeren."
@@ -2484,6 +2559,14 @@
 msgid "GAME: Database consistency check complete."
 msgstr "SPEL: Bezig database consistentie controle uit te voeren."
 
+#: conf.c:1343
+msgid "GAME: Database save in 1 minute."
+msgstr "SPEL: Database opslag over 1 minuut."
+
+#: conf.c:1345
+msgid "GAME: Database save in 5 minutes."
+msgstr "SPEL: Database opslag over 5 minuten."
+
 #: game.c:311
 msgid "GAME: ERROR! Database save failed!"
 msgstr "SPEL: FOUT! Opslaan van database mislukt!"
@@ -2534,6 +2617,14 @@
 msgid "GAME: SSL connections must be dropped, sorry."
 msgstr "SPEL: SSL verbindingen moeten afgesloten worden, sorry."
 
+#: conf.c:1282
+msgid "GAME: Save complete. "
+msgstr "SPEL: Klaar met opslaan. "
+
+#: conf.c:1281
+msgid "GAME: Saving database. Game may freeze for a few moments."
+msgstr "SPEL: Database wordt opgeslagen. Spel kan een paar minuten niet reageren."
+
 #: src/game.c:273
 #, c-format
 msgid "GAME: Shutdown by %s"
@@ -2728,6 +2819,10 @@
 msgid "I can't find that."
 msgstr "Dat kan ik niet vinden."
 
+#: speech.c:869
+msgid "I can't find who you last paged."
+msgstr "Ik kan niet vinden wie je het laatst een bericht hebt gestuurd."
+
 #: speech.c:686
 #, c-format
 msgid "I can't find who you're trying to page with: %s"
@@ -2771,6 +2866,10 @@
 msgid "I don't know that %s."
 msgstr "Ik ken die %s niet."
 
+#: atr_tab.c:410
+msgid "I don't know that attribute. Please use @attribute/access to create it, first."
+msgstr "Ik ken dat attribuut niet. Gebruik eerst @attribute/access om het aan te maken, alstublieft."
+
 #: rob.c:390
 msgid "I don't know what you mean."
 msgstr "Ik snap niet wat je bedoelt."
@@ -2931,10 +3030,29 @@
 msgid "Inspecting ansi string"
 msgstr "Bezig met ansi string inspectie"
 
+#: flags.c:1534 flags.c:1697
+#, c-format
+msgid "Internal error: Unable to find flagspace '%s'!"
+msgstr "Internet fout: Kan flagspace '%s' niet vinden!"
+
+#: flags.c:2325
+#, c-format
+msgid "Internal error: Unknown flag space '%s'!"
+msgstr "Internet fout: Onbekende flag space  '%s'!"
+
+#: flags.c:2515
+#, c-format
+msgid "Internal error: Unknown flagspace '%s'!"
+msgstr "Internet fout: Onbekende flagspace  '%s'!"
+
 #: create.c:373
 msgid "Internal error: weird object type."
 msgstr "Interne fout: vreemd type object."
 
+#: atr_tab.c:350
+msgid "Invalid Regular Expression."
+msgstr "Ongeldige regexp."
+
 #: atr_tab.c:202 atr_tab.c:293
 msgid "Invalid attribute name."
 msgstr "Ongeldige attribuut naam."
@@ -2994,6 +3112,11 @@
 msgid "Invalid range argument"
 msgstr "Ongelding bereik argument"
 
+#: predicat.c:1444 predicat.c:1455
+#, c-format
+msgid "Invalid regexp: %s"
+msgstr "Ongeldige regexp: %s"
+
 #: wiz.c:1772
 msgid "Invalid search class+restriction format."
 msgstr "Ongeldig zoek klasse+restrictie formaat."
@@ -3085,6 +3208,10 @@
 msgid "Letter for %s %s set to '%c'."
 msgstr "Letter voor %s %s gezet op '%c'."
 
+#: atr_tab.c:645
+msgid "Limit"
+msgstr "Limiet"
+
 #: conf.c:554
 msgid "Limits and other constants"
 msgstr "Limieten en andere constanten"
@@ -3241,6 +3368,10 @@
 msgid "MAIL: All messages in all folders cleared."
 msgstr "POST: Alle berichten in alle mappen gewist."
 
+#: extmail.c:481
+msgid "MAIL: All messages in all folders marked as read."
+msgstr "POST: Alle berichten in alle mappen gemarkeerd als gelezen."
+
 #: extmail.c:428
 msgid "MAIL: All messages in all folders tagged."
 msgstr "POST: Alle berichten in alle mappen getagd."
@@ -3249,6 +3380,10 @@
 msgid "MAIL: All messages in all folders uncleared."
 msgstr "POST: Alle berichten in alle mappen teruggehaald."
 
+#: extmail.c:479
+msgid "MAIL: All messages in all folders unread."
+msgstr "POST: Alle berichten in alle mappen ongelezen."
+
 #: extmail.c:426
 msgid "MAIL: All messages in all folders untagged."
 msgstr "POST: Tags van alle berichten in alle mappen weggehaald."
@@ -3370,6 +3505,11 @@
 msgid "MAIL: Msg #%d:%d cleared."
 msgstr "POST: Ber #%dL%d gewist."
 
+#: extmail.c:489
+#, c-format
+msgid "MAIL: Msg #%d:%d marked as read"
+msgstr "POST: Bericht #%d:%d gemarkeerd als gelezen"
+
 #: extmail.c:436
 #, c-format
 msgid "MAIL: Msg #%d:%d tagged"
@@ -3380,6 +3520,11 @@
 msgid "MAIL: Msg #%d:%d uncleared."
 msgstr "POST: Ber #%d:%d ongewist"
 
+#: extmail.c:487
+#, c-format
+msgid "MAIL: Msg #%d:%d unread"
+msgstr "POST: Bericht #%d:%d ongelezen"
+
 #: extmail.c:433
 #, c-format
 msgid "MAIL: Msg #%d:%d untagged"
@@ -3457,6 +3602,10 @@
 msgid "MAIL: To whom should I forward?"
 msgstr "POST: Aan wie moet ik doorsturen?"
 
+#: extmail.c:420
+msgid "MAIL: Unknown status."
+msgstr "POST: Onbekende status."
+
 #: src/extmail.c:378
 #, c-format
 msgid "MAIL: Unread Msg #%d:%d cleared! Use @mail/unclear %d:%d to recover."
@@ -3471,6 +3620,10 @@
 msgid "MAIL: What alias do you want to create?"
 msgstr "POST: Welk alias wil je aanmaken?"
 
+#: extmail.c:409
+msgid "MAIL: What do you want to do with the messages?"
+msgstr "POST: Wat wil je doen met de berichten?"
+
 #: src/extmail.c:239 src/extmail.c:279
 msgid "MAIL: What folder is that?"
 msgstr "POST: Welke map is dat?"
@@ -3520,6 +3673,11 @@
 msgid "MAIL: You probably don't wanna send mail saying 'clear'."
 msgstr "POST: Je wilt waarschijnlijk geen mailtje sturen dat 'clear' zegt."
 
+#: extmail.c:1310
+#, c-format
+msgid "MAIL: You sent your message to %s, but they can't mail you!"
+msgstr "POST: Je hebt je bericht gestuurd naar %s, maar ze kunnen je niet terug mailen!"
+
 #: src/extmail.c:1090
 #, c-format
 msgid "MAIL: You sent your message to %s."
@@ -3716,6 +3874,11 @@
 msgid "No entries matching '%s' were found."
 msgstr "Geen gegevens die voldoen aan '%s' gevonden."
 
+#: help.c:119 help.c:129 help.c:139 help.c:146
+#, c-format
+msgid "No entry for '%s'"
+msgstr "Geen entry voor '%s'"
+
 #: src/bsd.c:3090
 #, c-format
 msgid "No entry for '%s'."
@@ -3737,6 +3900,10 @@
 msgid "No match."
 msgstr "Niets gevonden."
 
+#: predicat.c:1528 predicat.c:1537
+msgid "No matches."
+msgstr "Geen matches."
+
 #: access.c:431
 msgid "No matching access rule"
 msgstr "Geen overeenkomende toegangsregel"
@@ -3915,6 +4082,10 @@
 msgid "Only God can set himself!"
 msgstr "Alleen God kan zichzelf @setten."
 
+#: extchat.c:1904
+msgid "Only players can use that option."
+msgstr "Alleen spelers kunnen die optie gebruiken."
+
 #: src/wiz.c:162
 msgid "Only wizards may change a quota."
 msgstr "Alleen wizards mogen een quota veranderen."
@@ -4028,11 +4199,19 @@
 msgid "PennMUSH version %s patchlevel %s %s"
 msgstr "PennMUSH versie %s patchlevel %s %s"
 
+#: conf.c:1302
+msgid "Pennies"
+msgstr "Pennies"
+
 #: wiz.c:1062
 #, c-format
 msgid "Pennies: %d"
 msgstr "Pennies: %d"
 
+#: conf.c:1301
+msgid "Penny"
+msgstr "Penny"
+
 #: src/extmail.c:1584
 msgid "Permission denied"
 msgstr "Toestemming geweigerd"
@@ -4327,6 +4506,11 @@
 msgid "Site %s locked"
 msgstr "Site %s vergrendeld"
 
+#: wiz.c:1481
+#, c-format
+msgid "Sitelocked %d known addresses for %s"
+msgstr "%d bekende adressen voor %s gesitelocked."
+
 #: src/destroy.c:266
 msgid "Sorry, no suicide allowed."
 msgstr "Sorry, zelfmoord is niet toegestaan."
@@ -4426,11 +4610,11 @@
 #: command.c:1782
 #, c-format
 msgid "Switches   : %s"
-msgstr "Shakelopties  : %s"
+msgstr "Schakelopties : %s"
 
 #: command.c:1784
 msgid "Switches   :"
-msgstr "Shakelopties  :"
+msgstr "Schakelopties :"
 
 #: extmail.c:2481
 msgid "Tagged"
@@ -4481,6 +4665,10 @@
 msgid "That attribute's permissions can not be changed."
 msgstr "De rechten van dat attribuut kunnen niet gewijzigd worden."
 
+#: atr_tab.c:421
+msgid "That attribute's permissions cannot be changed."
+msgstr "De permissies voor dat attribuut kunnen niet worden veranderd."
+
 #: destroy.c:436
 msgid "That can't be undestroyed."
 msgstr "Dat kun je niet terughalen."
@@ -4497,6 +4685,10 @@
 msgid "That is an exit."
 msgstr "Dat is een uitgang."
 
+#: log.c:402
+msgid "That is not a clearable log."
+msgstr "Dat is geen log wat je kunt legen."
+
 #: src/extmail.c:1218
 msgid "That is not a debugging option."
 msgstr "Dat is geen debug optie."
@@ -4521,10 +4713,6 @@
 msgid "That is not a valid lock name."
 msgstr "Dat is geen geldige slot-naam."
 
-#: src/log.c:355
-msgid "That is not a valid log."
-msgstr "Dat is geen geldig log."
-
 #: src/create.c:54
 msgid "That is not a valid object."
 msgstr "Dat is geen geldig object."
@@ -4582,6 +4770,10 @@
 msgid "That object is set WIZARD. You must use @nuke to destroy it."
 msgstr "Dat object is als WIZARD ingesteld. Je moet @nuke gebruiken om het te vernietigen."
 
+#: conf.c:1829
+msgid "That option cannot be altered."
+msgstr "Doe optie kan niet worden aangepast."
+
 #: src/look.c:1048
 msgid "That player does not seem to exist."
 msgstr "Het lijkt er niet op dat die speler bestaat."
@@ -4838,10 +5030,15 @@
 msgid "TinyMUSH compatibility options"
 msgstr "TinyMUSH compatibiliteitsopties."
 
-#: extchat.c:1836
+#: extchat.c:2088
 #, c-format
-msgid "Title %s for %schannel <%s>."
-msgstr "Titel %s voor %skanaal <%s>."
+msgid "Title cleared for %schannel <%s>."
+msgstr "Titel gewist voor %skanaal <%s>."
+
+#: extchat.c:2111
+#, c-format
+msgid "Title set for %schannel <%s>."
+msgstr "Titel gezet voor %skanaal <%s>."
 
 #: src/extchat.c:1358
 msgid "Title too long."
@@ -4857,6 +5054,10 @@
 msgid "To channel %s: %s"
 msgstr "Naar kanaal %s: %s"
 
+#: set.c:88
+msgid "Too many aliases."
+msgstr "Teveel aliasen."
+
 #: src/set.c:906
 msgid "Too many ancestors."
 msgstr "Teveel voorouderen."
@@ -4993,6 +5194,11 @@
 msgid "Unable to set alias."
 msgstr "Kon alias niet zetten."
 
+#: wiz.c:1483
+#, c-format
+msgid "Unable to sitelock %s: No known ip/host to ban."
+msgstr "Kan %s niet sitelocken: Geen ip/host bekend om te verbannen."
+
 #: speech.c:355
 #, c-format
 msgid "Unable to whisper to:%s"
@@ -5025,6 +5231,10 @@
 msgid "Unknown hook type"
 msgstr "Onbekend hook type."
 
+#: atr_tab.c:389
+msgid "Unknown limit type?"
+msgstr "Onbekend limiet type?"
+
 #: src/lock.c:297 src/lock.c:303
 msgid "Unknown lock type."
 msgstr "Onbekend slottype."
@@ -5112,6 +5322,11 @@
 msgid "Users"
 msgstr "Gebruikers"
 
+#: atr_tab.c:268 atr_tab.c:304
+#, c-format
+msgid "Value for %s needs to be one of: %s"
+msgstr "Waarde voor %s moet een zijn van: %s"
+
 #: move.c:423
 #, c-format
 msgid "Variable exit destination #%d is invalid or not permitted."
@@ -5473,6 +5688,10 @@
 msgid "You can only set quotas to a positive number."
 msgstr "Je kunt quota alleen op een positief nummer instellen."
 
+#: cmds.c:530
+msgid "You can only use /inplace with /override."
+msgstr "Je kunt /inplace alleen gebruiken in combinatie met /override."
+
 #: rob.c:326
 msgid "You can't afford that."
 msgstr "Dat kun je niet betalen."
@@ -5921,8 +6140,8 @@
 msgid "You must give a string of flag characters."
 msgstr "Je moet een reeks vlag karakters opgeven."
 
-#: cmds.c:424
-msgid "You must give a switch for @hook"
+#: cmds.c:525
+msgid "You must give a switch for @hook."
 msgstr "Je moet een shakeloptie voor @hook gebruiken."
 
 #: command.c:2073
@@ -6063,6 +6282,11 @@
 msgid "You paged %s with '%s'"
 msgstr "Je roept %s op met '%s'"
 
+#: speech.c:1081
+#, c-format
+msgid "You paged %s, but they are unable to page you."
+msgstr "Je hebt %s een page gestuurd, maar ze kunnen je niet terug pagen!"
+
 #: src/rob.c:263
 #, c-format
 msgid "You paid %d %s."
Index: po/pl_PL.pox
===================================================================
--- po/pl_PL.pox	(.../184p2)	(revision 828)
+++ po/pl_PL.pox	(.../184p3)	(revision 828)
@@ -3970,10 +3970,6 @@
 msgid "That is not a valid lock name."
 msgstr "To nie jest prawidowa nazwa blokady."
 
-#: src/log.c:355
-msgid "That is not a valid log."
-msgstr "To nie jest prawidowy log."
-
 #: src/create.c:54
 msgid "That is not a valid object."
 msgstr "To nie jest poprawny obiekt."
@@ -4238,11 +4234,6 @@
 msgid "TinyMUSH compatibility options"
 msgstr "Opcje kompatybilnoci z TinyMUSH"
 
-#: extchat.c:1836
-#, c-format
-msgid "Title %s for %schannel <%s>."
-msgstr "Tytu %s dla %skanau <%s>."
-
 #: src/extchat.c:1358
 msgid "Title too long."
 msgstr "Tytu zbyt dugi."
@@ -5262,10 +5253,6 @@
 msgid "You must give a string of flag characters."
 msgstr "Musisz poda acuch znakw flagi"
 
-#: cmds.c:424
-msgid "You must give a switch for @hook"
-msgstr "Musisz poda wcznik dla @haka"
-
 #: command.c:2073
 msgid "You must give an object."
 msgstr "Musisz poda obiekt."
Index: po/pt_BR.pox
===================================================================
--- po/pt_BR.pox	(.../184p2)	(revision 828)
+++ po/pt_BR.pox	(.../184p3)	(revision 828)
@@ -705,10 +705,6 @@
 msgid "That function isn't deleted!"
 msgstr "Nome de funo muito grande."
 
-#: src/log.c:355
-msgid "That is not a valid log."
-msgstr "Nome de funo muito grande."
-
 #: src/extchat.c:1181
 msgid "That name is too long."
 msgstr "Nome de funo muito grande."
Index: po/hu_HU.pox
===================================================================
--- po/hu_HU.pox	(.../184p2)	(revision 828)
+++ po/hu_HU.pox	(.../184p3)	(revision 828)
@@ -3012,10 +3012,6 @@
 msgid "That is not a valid lock name."
 msgstr "Ez nem egy rvnyes zr-nv."
 
-#: src/log.c:355
-msgid "That is not a valid log."
-msgstr "Ez nem egy rvnyes log."
-
 #: src/create.c:54
 msgid "That is not a valid object."
 msgstr "Ez nem egy rvnyes objektum."
@@ -4070,10 +4066,6 @@
 msgid "You must give a string of flag characters."
 msgstr "Egy jelz betkbl ll szveget kell megadnod."
 
-#: cmds.c:424
-msgid "You must give a switch for @hook"
-msgstr "Meg kell adnod egy kapcsolt a @hook rszre"
-
 #: command.c:1357
 msgid "You must give both an object and attribute."
 msgstr "Meg kell adnod egy objektumot s egy attribtumot is."
Index: po/no_NO.pox
===================================================================
--- po/no_NO.pox	(.../184p2)	(revision 828)
+++ po/no_NO.pox	(.../184p3)	(revision 828)
@@ -1423,10 +1423,6 @@
 msgid "@command is ALWAYS enabled."
 msgstr "@command er ALLTID tilgjengelig."
 
-#: cque.c:695
-msgid "@include recursion exceeded."
-msgstr "@include rekursjonsgrense overskredet."
-
 #: cmds.c:687
 msgid "@message them with what?"
 msgstr "@message dem med hva?"
@@ -4560,10 +4556,6 @@
 msgid "That is not a valid lock name."
 msgstr "Det er ikke et gyldig lsnavn."
 
-#: src/log.c:355
-msgid "That is not a valid log."
-msgstr "Det er ikke en gyldig logg."
-
 #: src/create.c:54
 msgid "That is not a valid object."
 msgstr "Det der er ikke et gyldig objekt."
@@ -4877,11 +4869,6 @@
 msgid "TinyMUSH compatibility options"
 msgstr "TinyMUSH kompabilitetsalternativer"
 
-#: extchat.c:1836
-#, c-format
-msgid "Title %s for %schannel <%s>."
-msgstr "Tittel %s for %skanal <%s>."
-
 #: src/extchat.c:1358
 msgid "Title too long."
 msgstr "Tittel er for lang."
@@ -5960,10 +5947,6 @@
 msgid "You must give a string of flag characters."
 msgstr "Du m gi en streng med flagg-karakterer."
 
-#: cmds.c:424
-msgid "You must give a switch for @hook"
-msgstr "Du m gi en switch for @hook"
-
 #: command.c:2073
 msgid "You must give an object."
 msgstr "Du m angi et objekt."
Index: po/Makefile
===================================================================
--- po/Makefile	(.../184p2)	(revision 828)
+++ po/Makefile	(.../184p3)	(revision 828)
@@ -2,7 +2,7 @@
 
 POFILES=ru_RU.po nl_NL.po sv_SE.po hu_HU.po es_ES.po pt_BR.po fr_FR.po \
 da_DK.po de_DE.po no_NO.po pl_PL.po ro_RO.po id_ID.po eo.po hr_HR.po pt_PT.po \
-zh_TW.po
+zh_TW.po fi_FI.po
 
 .pox.po: $*.pox pennmush.pot
 	-msgmerge -E -v $*.pox pennmush.pot > $*.po
Index: CHANGES.184
===================================================================
--- CHANGES.184	(.../184p2)	(revision 828)
+++ CHANGES.184	(.../184p3)	(revision 828)
@@ -16,6 +16,137 @@
 
 ==========================================================================
 
+Version 1.8.4 patchlevel 3                                 Mar 18,  2011
+
+Events:
+ * Event system added. Certain things can now trigger events using @config
+   event_handler. See "help events" and "help event <type>". [GM]
+ * dump events: dump`5min, dump`1min, dump`complete.
+ * object events: object`create, object`destroy, object`move,
+   object`rename, object`kill.
+ * sql events: sql`connect, sql`disconnect.
+ * signal events: signal`usr1, signal`usr2.
+ * player events: player`create, player`fail, player`connect,
+   player`disconnect, player`inactivity.
+ * socket events: socket`connect, socket`disconnect
+ * database events: db`dbck, db`purge, db`wcheck
+ * Periodic system events like warnings checks and db consistency
+   checks are now handled by a timed queue and integrated with
+   softcode events. Local hackers: This involves changes to
+   local.c. If you have no changes in local.c, just delete the file.
+   Otherwise, see HACKING.184 for more info. [SW]
+
+Commands:
+ * @hook/override/inplace - You can now run softcode with the same priority
+   as hardcode! [GM]
+ * @lock (and all lock keys) now accepts NAME^<pattern> for matching against
+   an object's name. [GM]
+ * @mapsql passes row results to attributes. Suggested by Mercutio. [GM]
+ * @dig now takes an optional garbage dbref argument to specify the new
+   dbref. Suggested by Paige. [GM]
+ * The help command now does some auto-expansion of topics. For example,
+   'help @chan ad2' will be expanded to match 'help @channel admin2'. [MG]
+ * @force/inplace, @switch/inplace and @select/inplace now run their commands
+   without queueing new events. These are limited by the @include limit. [GM]
+ * @hide without a switch now toggles hide status, rather than defaulting to
+   @hide/on. [MG]
+ * @log now takes a /recall switch for showing wizards the most recent activity
+   in a log file. [SW]
+ * @lemit and @zemit both have /noisy and /silent switches to suppress/show
+   confirmation messages. With no switch, silent_pemit determines whether
+   the message is shown. Suggested by Paige for consistancy. [MG]
+   
+Attributes:
+ * New no_debug flag, which prevents debug info being shown for an attribute
+   when the object is set DEBUG. [MG]
+   
+Config:
+ * New @config option chan_title_len controls the length of @channel/title's.
+   Suggested by Paige. [MG]
+
+Locks:
+ * New @lock/pay, controls who can "give" an object pennies or "buy" items
+   from an object. Based on patch by Covenent. [MG]
+
+Functions:
+ * lockfilter() lets you filter a list of dbrefs using a lock key. [GM]
+ * align() now has '$' (nofill) as an option. Ideal for rightmost columns.
+   Suggested by Minion. [GM]
+ * dig() now takes an optional garbage dbref argument to specify the new
+   dbref. Suggested by Paige. [GM]
+ * convutctime() and convtime(<time>, utc) to convert a timestring to
+   # of seconds since UTC. Patch by Minion.
+ * powers() with no arguments now returns a list of powers, similar to
+   lflags() with no args. [MG]
+ * trim() can now trim multiple characters. [MG] [GM]
+ * In some cases, privs are no longer needed to use locate(). [MG]
+ * cmogrifier(), returns the mogrifier object for a channel. Suggested by
+   Trinsec, patch by Minion.
+
+Minor Changes:
+ * The Can_Nspemit @power has been renamed to Can_Spoof, to better reflect
+   its uses. Can_Nspemit is still an alias. [MG]
+ * Considerable improvement in the speed of functions that sort
+   case-insensitively, particularly using 'm' sort (Now default). [GM]
+ * Combined fun_setinter, fun_setdiff and fun_setunion into fun_setmanip. [GM]
+ * For hardcoders: list2arr and list2arr_ansi now take a third argument
+   on whether to include empty items. [GM]
+ * page and @mail will report to you if your recipient(s) cannot reply
+   to you. Suggested by Paige. [GM]
+ * The debug attribute flag now shows more debug info. [MG]
+ * @oemit now does better object matching, can match names with spaces when
+   enclosed in double quotes, and, when given a <room> but no matching
+   objects, shows the message to everyone in the room, instead of noone.
+   From a bug reported by Paige. [MG]
+ * Paranoid objects now see nospoof messages for their emits. [MG]
+ * ANSI is now ignored when checking the length of channel titles. Suggested
+   by Paige. [MG]
+ * @decompile with a <prefix> now shows cmds for setting attribute flags.
+   @decompile/tf still omits cmds for attr flags. [MG]
+ * @mail <msg-lists> which don't specify a folder now act on your current
+   folder, instead of Folder 0. Suggested by Paige, patch by Minion.
+ * @dig, @open and @name now set exit aliases into the @alias attribute,
+   instead of including them in the exit name. Also, @name can now set/clear
+   the @alias of players/exits while changing the name. See help @name for
+   details. Suggested by Minion. [MG]
+ * The logging code has been rewritten to make extending it with further
+   log files easier. [SW]
+ * When used by a non-player, @search and related functions now search from
+   the perspective of the object's owner. Suggested by Covenent. [MG]
+ * The LASTPAGED attribute now stores objids instead of names, allowing you
+   to repage even when the target changes their name. [MG]
+ * When zwho() or @chzone fail because you don't pass the @lock/zone, zone
+   failure verbs are triggered (as per 'help failure'). Based on a patch by
+   Covenent. [MG]
+ * sub() can now take more than two arguments. Suggested by Paige. [MG]
+ * In the hardcode, disconnected players in the DESC struct are shown as -1
+   instead of 0, to avoid conflicts with #0. Based on patch by Paige. [MG]
+ * It was sometimes possible to "buy" items from yourself. [MG]
+
+Fixes:
+ * Fixing list type autodetect. [GM]
+ * Help fixes by Daniel Powell, AnneLions, Minion and others. [MG]
+ * Connect/disconnect messages for combined channels incorrectly showed
+   NOSPOOF data. Reported by Sketch. [MG]
+ * The delimiter between combined channel names in @chatformat is now '|'
+   instead of ' | ', as documented. Reported by Trinsec. [MG]
+ * ansi(h,) now returns absolutely nothing, instead of an ansi-highlighted
+   nothing. Fixes a few minor/obscure bugs. [MG]
+ * @edit sometimes displayed a success message even when it failed. [MG]
+ * @cpattr/@mvattr would sometimes copy attribute flags, even when the
+   attribute value couldn't be copied. [MG]
+ * Bug in attribute comparisons added in p2 could cause attributes to
+   not be found at times. [MG]
+ * sortby()s results would sometimes be reversed by mistake. [GM]
+ * Minor bugfix in @include. [MG]
+ * round() sometimes returned numbers with more decimal digits than
+   desired. 
+ * The '*' option in locate() didn't actually include all match types. [MG]
+ * @include incorrectly refunded the queue_cost, giving people free pennies.
+   Reported by Covenent. [MG]
+ * lnum() didn't handle negative <step>s well. Reported by Minion. [MG]
+ * comp()s results was sometimes negated. Reported by Covenent. [MG]
+
 Version 1.8.4 patchlevel 2                                 Dec 06,  2010
 
 Major Changes:
Index: hdrs/switches.h
===================================================================
--- hdrs/switches.h	(.../184p2)	(revision 828)
+++ hdrs/switches.h	(.../184p3)	(revision 828)
@@ -21,149 +21,153 @@
 #define SWITCH_CLEAR 18
 #define SWITCH_CLONE 19
 #define SWITCH_CMD 20
-#define SWITCH_COMBINE 21
-#define SWITCH_COMMANDS 22
-#define SWITCH_CONN 23
-#define SWITCH_CONNECT 24
-#define SWITCH_CONNECTED 25
-#define SWITCH_CONTENTS 26
-#define SWITCH_COSTS 27
-#define SWITCH_COUNT 28
-#define SWITCH_CREATE 29
-#define SWITCH_DATABASE 30
-#define SWITCH_DB 31
-#define SWITCH_DEBUG 32
-#define SWITCH_DECOMPILE 33
-#define SWITCH_DEFAULTS 34
-#define SWITCH_DELETE 35
-#define SWITCH_DELIMIT 36
-#define SWITCH_DESCRIBE 37
-#define SWITCH_DESTROY 38
-#define SWITCH_DISABLE 39
-#define SWITCH_DOWN 40
-#define SWITCH_DSTATS 41
-#define SWITCH_EMIT 42
-#define SWITCH_ENABLE 43
-#define SWITCH_ENUM 44
-#define SWITCH_EQSPLIT 45
-#define SWITCH_ERR 46
-#define SWITCH_EXITS 47
-#define SWITCH_FILE 48
-#define SWITCH_FIRST 49
-#define SWITCH_FLAGS 50
-#define SWITCH_FOLDERS 51
-#define SWITCH_FORWARD 52
-#define SWITCH_FREESPACE 53
-#define SWITCH_FSTATS 54
-#define SWITCH_FULL 55
-#define SWITCH_FUNCTIONS 56
-#define SWITCH_FWD 57
-#define SWITCH_GAG 58
-#define SWITCH_GLOBALS 59
-#define SWITCH_HEADER 60
-#define SWITCH_HERE 61
-#define SWITCH_HIDE 62
-#define SWITCH_IGNORE 63
-#define SWITCH_ILIST 64
-#define SWITCH_INSIDE 65
-#define SWITCH_INVENTORY 66
-#define SWITCH_IPRINT 67
-#define SWITCH_JOIN 68
-#define SWITCH_LETTER 69
-#define SWITCH_LIMIT 70
-#define SWITCH_LIST 71
-#define SWITCH_LOCAL 72
-#define SWITCH_LOCKS 73
-#define SWITCH_LOWERCASE 74
-#define SWITCH_LSARGS 75
-#define SWITCH_ME 76
-#define SWITCH_MEMBERS 77
-#define SWITCH_MOD 78
-#define SWITCH_MOGRIFIER 79
-#define SWITCH_MORTAL 80
-#define SWITCH_MOTD 81
-#define SWITCH_MUTE 82
-#define SWITCH_NAME 83
-#define SWITCH_NO 84
-#define SWITCH_NOCASE 85
-#define SWITCH_NOEVAL 86
-#define SWITCH_NOFLAGCOPY 87
-#define SWITCH_NOISY 88
-#define SWITCH_NOPARSE 89
-#define SWITCH_NOSIG 90
-#define SWITCH_NOSPACE 91
-#define SWITCH_NOTIFY 92
-#define SWITCH_NUKE 93
-#define SWITCH_OFF 94
-#define SWITCH_ON 95
-#define SWITCH_OUTSIDE 96
-#define SWITCH_OVERRIDE 97
-#define SWITCH_PAGING 98
-#define SWITCH_PANIC 99
-#define SWITCH_PARANOID 100
-#define SWITCH_PARENT 101
-#define SWITCH_PLAYERS 102
-#define SWITCH_PORT 103
-#define SWITCH_POWERS 104
-#define SWITCH_PREFIX 105
-#define SWITCH_PRESERVE 106
-#define SWITCH_PRINT 107
-#define SWITCH_PRIVS 108
-#define SWITCH_PURGE 109
-#define SWITCH_QUICK 110
-#define SWITCH_QUIET 111
-#define SWITCH_READ 112
-#define SWITCH_REBOOT 113
-#define SWITCH_RECALL 114
-#define SWITCH_REGEXP 115
-#define SWITCH_REGIONS 116
-#define SWITCH_REGISTER 117
-#define SWITCH_REMOVE 118
-#define SWITCH_RENAME 119
-#define SWITCH_RESTORE 120
-#define SWITCH_RESTRICT 121
-#define SWITCH_RETROACTIVE 122
-#define SWITCH_ROOM 123
-#define SWITCH_ROOMS 124
-#define SWITCH_RSARGS 125
-#define SWITCH_SAVE 126
-#define SWITCH_SEE 127
-#define SWITCH_SEEFLAG 128
-#define SWITCH_SELF 129
-#define SWITCH_SEND 130
-#define SWITCH_SET 131
-#define SWITCH_SILENT 132
-#define SWITCH_SKIPDEFAULTS 133
-#define SWITCH_SPEAK 134
-#define SWITCH_SPOOF 135
-#define SWITCH_STATS 136
-#define SWITCH_STATUS 137
-#define SWITCH_SUMMARY 138
-#define SWITCH_TABLES 139
-#define SWITCH_TAG 140
-#define SWITCH_TELEPORT 141
-#define SWITCH_TF 142
-#define SWITCH_THINGS 143
-#define SWITCH_TITLE 144
-#define SWITCH_TRACE 145
-#define SWITCH_TYPE 146
-#define SWITCH_UNCLEAR 147
-#define SWITCH_UNCOMBINE 148
-#define SWITCH_UNFOLDER 149
-#define SWITCH_UNGAG 150
-#define SWITCH_UNHIDE 151
-#define SWITCH_UNMUTE 152
-#define SWITCH_UNREAD 153
-#define SWITCH_UNTAG 154
-#define SWITCH_UNTIL 155
-#define SWITCH_URGENT 156
-#define SWITCH_USEFLAG 157
-#define SWITCH_WHAT 158
-#define SWITCH_WHO 159
-#define SWITCH_WILD 160
-#define SWITCH_WIPE 161
-#define SWITCH_WIZ 162
-#define SWITCH_WIZARD 163
-#define SWITCH_YES 164
-#define SWITCH_ZONE 165
+#define SWITCH_COLNAMES 21
+#define SWITCH_COMBINE 22
+#define SWITCH_COMMANDS 23
+#define SWITCH_CONN 24
+#define SWITCH_CONNECT 25
+#define SWITCH_CONNECTED 26
+#define SWITCH_CONTENTS 27
+#define SWITCH_COSTS 28
+#define SWITCH_COUNT 29
+#define SWITCH_CREATE 30
+#define SWITCH_DATABASE 31
+#define SWITCH_DB 32
+#define SWITCH_DEBUG 33
+#define SWITCH_DECOMPILE 34
+#define SWITCH_DEFAULTS 35
+#define SWITCH_DELETE 36
+#define SWITCH_DELIMIT 37
+#define SWITCH_DESCRIBE 38
+#define SWITCH_DESTROY 39
+#define SWITCH_DISABLE 40
+#define SWITCH_DOWN 41
+#define SWITCH_DSTATS 42
+#define SWITCH_EMIT 43
+#define SWITCH_ENABLE 44
+#define SWITCH_ENUM 45
+#define SWITCH_EQSPLIT 46
+#define SWITCH_ERR 47
+#define SWITCH_EXITS 48
+#define SWITCH_FILE 49
+#define SWITCH_FIRST 50
+#define SWITCH_FLAGS 51
+#define SWITCH_FOLDERS 52
+#define SWITCH_FORWARD 53
+#define SWITCH_FREESPACE 54
+#define SWITCH_FSTATS 55
+#define SWITCH_FULL 56
+#define SWITCH_FUNCTIONS 57
+#define SWITCH_FWD 58
+#define SWITCH_GAG 59
+#define SWITCH_GLOBALS 60
+#define SWITCH_HEADER 61
+#define SWITCH_HERE 62
+#define SWITCH_HIDE 63
+#define SWITCH_IGNORE 64
+#define SWITCH_ILIST 65
+#define SWITCH_INPLACE 66
+#define SWITCH_INSIDE 67
+#define SWITCH_INVENTORY 68
+#define SWITCH_IPRINT 69
+#define SWITCH_JOIN 70
+#define SWITCH_LEAVE 71
+#define SWITCH_LETTER 72
+#define SWITCH_LIMIT 73
+#define SWITCH_LIST 74
+#define SWITCH_LOCAL 75
+#define SWITCH_LOCKS 76
+#define SWITCH_LOWERCASE 77
+#define SWITCH_LSARGS 78
+#define SWITCH_ME 79
+#define SWITCH_MEMBERS 80
+#define SWITCH_MOD 81
+#define SWITCH_MOGRIFIER 82
+#define SWITCH_MORTAL 83
+#define SWITCH_MOTD 84
+#define SWITCH_MUTE 85
+#define SWITCH_NAME 86
+#define SWITCH_NO 87
+#define SWITCH_NOCASE 88
+#define SWITCH_NOEVAL 89
+#define SWITCH_NOFLAGCOPY 90
+#define SWITCH_NOISY 91
+#define SWITCH_NOPARSE 92
+#define SWITCH_NOSIG 93
+#define SWITCH_NOSPACE 94
+#define SWITCH_NOTIFY 95
+#define SWITCH_NUKE 96
+#define SWITCH_OFF 97
+#define SWITCH_ON 98
+#define SWITCH_OUTSIDE 99
+#define SWITCH_OVERRIDE 100
+#define SWITCH_PAGING 101
+#define SWITCH_PANIC 102
+#define SWITCH_PARANOID 103
+#define SWITCH_PARENT 104
+#define SWITCH_PLAYER 105
+#define SWITCH_PLAYERS 106
+#define SWITCH_PORT 107
+#define SWITCH_POWERS 108
+#define SWITCH_PREFIX 109
+#define SWITCH_PRESERVE 110
+#define SWITCH_PRINT 111
+#define SWITCH_PRIVS 112
+#define SWITCH_PURGE 113
+#define SWITCH_QUICK 114
+#define SWITCH_QUIET 115
+#define SWITCH_READ 116
+#define SWITCH_REBOOT 117
+#define SWITCH_RECALL 118
+#define SWITCH_REGEXP 119
+#define SWITCH_REGIONS 120
+#define SWITCH_REGISTER 121
+#define SWITCH_REMOVE 122
+#define SWITCH_RENAME 123
+#define SWITCH_RESTORE 124
+#define SWITCH_RESTRICT 125
+#define SWITCH_RETROACTIVE 126
+#define SWITCH_ROOM 127
+#define SWITCH_ROOMS 128
+#define SWITCH_RSARGS 129
+#define SWITCH_SAVE 130
+#define SWITCH_SEE 131
+#define SWITCH_SEEFLAG 132
+#define SWITCH_SELF 133
+#define SWITCH_SEND 134
+#define SWITCH_SET 135
+#define SWITCH_SILENT 136
+#define SWITCH_SKIPDEFAULTS 137
+#define SWITCH_SPEAK 138
+#define SWITCH_SPOOF 139
+#define SWITCH_STATS 140
+#define SWITCH_STATUS 141
+#define SWITCH_SUMMARY 142
+#define SWITCH_TABLES 143
+#define SWITCH_TAG 144
+#define SWITCH_TELEPORT 145
+#define SWITCH_TF 146
+#define SWITCH_THINGS 147
+#define SWITCH_TITLE 148
+#define SWITCH_TRACE 149
+#define SWITCH_TYPE 150
+#define SWITCH_UNCLEAR 151
+#define SWITCH_UNCOMBINE 152
+#define SWITCH_UNFOLDER 153
+#define SWITCH_UNGAG 154
+#define SWITCH_UNHIDE 155
+#define SWITCH_UNMUTE 156
+#define SWITCH_UNREAD 157
+#define SWITCH_UNTAG 158
+#define SWITCH_UNTIL 159
+#define SWITCH_URGENT 160
+#define SWITCH_USEFLAG 161
+#define SWITCH_WHAT 162
+#define SWITCH_WHO 163
+#define SWITCH_WILD 164
+#define SWITCH_WIPE 165
+#define SWITCH_WIZ 166
+#define SWITCH_WIZARD 167
+#define SWITCH_YES 168
+#define SWITCH_ZONE 169
 #endif                          /* SWITCHES_H */
Index: hdrs/ansi.h
===================================================================
--- hdrs/ansi.h	(.../184p2)	(revision 828)
+++ hdrs/ansi.h	(.../184p3)	(revision 828)
@@ -186,4 +186,16 @@
     int safe_tag_wrap(char const *a_tag, char const *params,
                       char const *data, char *buf, char **bp, dbref player);
 
+/* Walk through a string containing markup, skipping over the markup (ansi/pueblo) codes */
+#define WALK_ANSI_STRING(char, str) for((char) = (str); *(char); (char)++) \
+  if (*(char) == (TAG_START)) { \
+    while ((*(char)) && (*(char) != (TAG_END))) \
+      (char)++; \
+    continue; \
+  } else if (*(char) == ESC_CHAR) { \
+    while ((*(char)) && (*(char) != 'm')) \
+      (char)++; \
+    continue; \
+  } else
+
 #endif                          /* __ANSI_H */
Index: hdrs/extchat.h
===================================================================
--- hdrs/extchat.h	(.../184p2)	(revision 828)
+++ hdrs/extchat.h	(.../184p3)	(revision 828)
@@ -45,7 +45,7 @@
 #include "boolexp.h"
 #include "bufferq.h"
 
-#define CU_TITLE_LEN 80
+#define CU_TITLE_LEN (options.chan_title_len)
 
 /** A channel user.
  * This structure represents an object joined to a chat channel.
@@ -54,7 +54,7 @@
 struct chanuser {
   dbref who;                    /**< Dbref of joined object */
   privbits type;                /**< Bitflags for this user */
-  char title[CU_TITLE_LEN];     /**< User's channel title */
+  char *title;                  /**< User's channel title */
   struct chanuser *next;        /**< Pointer to next user in list */
 };
 
Index: hdrs/mushtype.h
===================================================================
--- hdrs/mushtype.h	(.../184p2)	(revision 828)
+++ hdrs/mushtype.h	(.../184p3)	(revision 828)
@@ -77,6 +77,7 @@
   int switch_nesting;           /**< switch()/@switch nesting depth */
   int local_switch_nesting;     /**< Expression-level switch nesting depth */
   char *switch_text[MAX_ITERS]; /**< #$-values for switch()/@switches */
+  int debugging;                /**< Show debug? 1 = yes, 0 = if DEBUG flag set, -1 = no */
 };
 
 
@@ -130,10 +131,10 @@
  */
 struct descriptor_data {
   int descriptor;       /**< Connection socket (fd) */
-  int connected;        /**< Connection status */
+  int connected;        /**< Connection status. 0 = not connected to a player, 1 = connected, 2 = connection denied due to login limits/sitelock */
   char addr[101];       /**< Hostname of connection source */
   char ip[101];         /**< IP address of connection source */
-  dbref player;         /**< Dbref of player associated with connection */
+  dbref player;         /**< Dbref of player associated with connection, or NOTHING if not connected */
   unsigned char *output_prefix; /**< Text to show before output */
   unsigned char *output_suffix; /**< Text to show after output */
   int output_size;              /**< Size of output left to send */
Index: hdrs/mushdb.h
===================================================================
--- hdrs/mushdb.h	(.../184p2)	(revision 828)
+++ hdrs/mushdb.h	(.../184p3)	(revision 828)
@@ -26,7 +26,7 @@
 #define Open_Anywhere(x) (Hasprivs(x) || has_power_by_name(x,"OPEN_ANYWHERE",NOTYPE))
 #define Link_Anywhere(x)  (Hasprivs(x) || has_power_by_name(x,"LINK_ANYWHERE",NOTYPE))
 #define Can_Boot(x)      (Hasprivs(x) || has_power_by_name(x,"BOOT",NOTYPE))
-#define Can_Nspemit(x)   (Wizard(x) || has_power_by_name(x,"CAN_NSPEMIT",NOTYPE))
+#define Can_Nspemit(x)   (Wizard(x) || has_power_by_name(x,"CAN_SPOOF",NOTYPE))
 #define Do_Quotas(x)     (Wizard(x) || has_power_by_name(x,"QUOTAS",NOTYPE))
 #define Change_Poll(x)   (Wizard(x) || has_power_by_name(x,"POLL",NOTYPE))
 #define HugeQueue(x)     (Wizard(x) || has_power_by_name(x,"QUEUE",NOTYPE))
Index: hdrs/attrib.h
===================================================================
--- hdrs/attrib.h	(.../184p2)	(revision 828)
+++ hdrs/attrib.h	(.../184p3)	(revision 828)
@@ -82,9 +82,10 @@
 extern char const *convert_atr(int oldatr);
 extern int atr_comm_match(dbref thing, dbref player, int type, int end,
                           char const *str, int just_match, int check_locks,
-                          char *atrname, char **abp, dbref *errobj);
+                          char *atrname, char **abp, dbref *errobj,
+                          int inplace);
 extern int one_comm_match(dbref thing, dbref player, const char *atr,
-                          const char *str);
+                          const char *str, int inplace);
 extern int do_set_atr(dbref thing, char const *RESTRICT atr,
                       char const *RESTRICT s, dbref player, uint32_t flags);
 extern void do_atrlock(dbref player, char const *arg1, char const *arg2);
@@ -137,7 +138,7 @@
 #define AF_NOSPACE      0x10000000U     /**< No space in did_it */
 #define AF_MHEAR        0x20000000U     /**< ^-listens can be triggered by %! */
 #define AF_AHEAR        0x40000000U     /**< ^-listens can be triggered by anyone */
-#define AF_UNDEF3       0x80000000U     /**< Undefined; reserved for a future flag */
+#define AF_NODEBUG      0x80000000U     /**< Don't show debug when evaluated */
 
 #define AF_MAXVALUE     0x100000000U     /**< Largest attribute flag value. */
 
Index: hdrs/conf.h
===================================================================
--- hdrs/conf.h	(.../184p2)	(revision 828)
+++ hdrs/conf.h	(.../184p3)	(revision 828)
@@ -126,6 +126,7 @@
   dbref ancestor_exit;  /**< The ultimate parent exit */
   dbref ancestor_thing; /**< The ultimate parent thing */
   dbref ancestor_player; /**< The ultimate parent player */
+  dbref event_handler;  /**< The object events. */
   int connect_fail_limit; /**< Maximum number of connect fails in 10 mins. */
   int idle_timeout;     /**< Maximum idle time allowed, in minutes */
   int unconnected_idle_timeout; /**< Maximum idle time for connections without dbrefs, in minutes */
@@ -158,6 +159,7 @@
   char chatdb[256];             /**< Name of the chat database file */
   int max_player_chans;         /**< Number of channels a player can create */
   int max_channels;             /**< Total maximum allowed channels */
+  int chan_title_len;           /**< Maximum length of a player's channel title */
   int chan_cost;                /**< Cost to create a channel */
   int noisy_cemit;              /**< Is @cemit noisy by default? */
   char connect_file[2][256];    /**< Names of text and html connection files */
@@ -349,6 +351,7 @@
 #define ANCESTOR_EXIT           (options.ancestor_exit)
 #define ANCESTOR_THING          (options.ancestor_thing)
 #define ANCESTOR_PLAYER         (options.ancestor_player)
+#define EVENT_HANDLER    (options.event_handler)
 #define MONEY            (options.money_singular)
 #define MONIES           (options.money_plural)
 #define WHISPER_LOUDNESS        (options.whisper_loudness)
Index: hdrs/lock.h
===================================================================
--- hdrs/lock.h	(.../184p2)	(revision 828)
+++ hdrs/lock.h	(.../184p3)	(revision 828)
@@ -108,6 +108,7 @@
 extern lock_type Drop_Lock;     /* Who can drop me */
 extern lock_type Give_Lock;     /* Who can give me */
 extern lock_type From_Lock;     /* Who can give to me */
+extern lock_type Pay_Lock;      /* Who can give money to me */
 extern lock_type Receive_Lock;  /* What can be given to me */
 extern lock_type Mail_Lock;     /* Who can @mail me */
 extern lock_type Follow_Lock;   /* Who can follow me */
Index: hdrs/bufferq.h
===================================================================
--- hdrs/bufferq.h	(.../184p2)	(revision 828)
+++ hdrs/bufferq.h	(.../184p3)	(revision 828)
@@ -7,6 +7,8 @@
  */
 
 
+#ifndef BUFFERQ_H
+#define BUFFERQ_H
 
 typedef struct bufferq BUFFERQ;
 
@@ -33,3 +35,5 @@
 int bufferq_lines(BUFFERQ *bq);
 int bufferq_blocks(BUFFERQ *bq);
 bool isempty_bufferq(BUFFERQ *bq);
+
+#endif
Index: hdrs/match.h
===================================================================
--- hdrs/match.h	(.../184p2)	(revision 828)
+++ hdrs/match.h	(.../184p3)	(revision 828)
@@ -7,30 +7,32 @@
 
 /* match constants */
   /* match modifiers */
-#define MAT_CHECK_KEYS   0x000001
-#define MAT_GLOBAL       0x000002
-#define MAT_REMOTES      0x000004
-#define MAT_CONTROL      0x000008
+#define MAT_CHECK_KEYS       0x000001
+#define MAT_GLOBAL           0x000002
+#define MAT_REMOTES          0x000004
+#define MAT_CONTROL          0x000008
   /* individual things to match */
-#define MAT_ME           0x000010
-#define MAT_HERE         0x000020
-#define MAT_ABSOLUTE     0x000040
-#define MAT_PLAYER       0x000080
-#define MAT_NEIGHBOR     0x000100
-#define MAT_POSSESSION   0x000200
-#define MAT_EXIT         0x004000
-#define MAT_PMATCH       0x008000
+#define MAT_ME               0x000010
+#define MAT_HERE             0x000020
+#define MAT_ABSOLUTE         0x000040
+#define MAT_PLAYER           0x000080
+#define MAT_NEIGHBOR         0x000100
+#define MAT_POSSESSION       0x000200
+#define MAT_CONTENTS         0x000400   /* Only match objects which are in the looker's contents */
+#define MAT_EXIT             0x000800
+#define MAT_PMATCH           0x001000
   /* special things to match */
-#define MAT_CARRIED_EXIT     0x010000
-#define MAT_CONTAINER        0x020000
-#define MAT_REMOTE_CONTENTS  0x040000
-#define MAT_NEAR             0x080000
-#define MAT_ENGLISH          0x100000
+#define MAT_CARRIED_EXIT     0x002000
+#define MAT_CONTAINER        0x004000
+#define MAT_REMOTE_CONTENTS  0x008000
+#define MAT_NEAR             0x010000
+#define MAT_ENGLISH          0x020000
   /* types of match results - used internally */
-#define MAT_NOISY                0x1000000
-#define MAT_LAST                 0x2000000
-#define MAT_TYPE                 0x4000000      /* don't accept objects of other types */
-#define MAT_EXACT                0x8000000      /* don't do partial name matches */
+#define MAT_NOISY            0x040000
+#define MAT_LAST             0x080000
+#define MAT_TYPE             0x100000   /* don't accept objects of other types */
+#define MAT_EXACT            0x200000   /* don't do partial name matches */
+
   /* groups of things to match */
 #define MAT_EVERYTHING   (MAT_ME|MAT_HERE|MAT_ABSOLUTE|MAT_PLAYER| \
                           MAT_NEIGHBOR|MAT_POSSESSION|MAT_EXIT|MAT_ENGLISH)
@@ -40,6 +42,7 @@
 #define MAT_NEAR_THINGS  (MAT_OBJECTS|MAT_NEAR)
 #define MAT_LIMITED      (MAT_ABSOLUTE|MAT_PLAYER|MAT_NEIGHBOR)
 #define MAT_REMOTE       (MAT_ABSOLUTE|MAT_PLAYER|MAT_REMOTE_CONTENTS|MAT_EXIT)
+#define MAT_OBJ_CONTENTS (MAT_POSSESSION|MAT_PLAYER|MAT_ABSOLUTE|MAT_CONTENTS|MAT_ENGLISH)
 
 
 /* Functions we can call */
@@ -51,11 +54,16 @@
  */
 extern dbref
  match_result(dbref who, const char *xname, int type, long flags);
-extern dbref noisy_match_result
-  (const dbref who, const char *name, const int type, const long flags);
-extern dbref last_match_result
-  (const dbref who, const char *name, const int type, const long flags);
+extern dbref
+
+match_result_relative(dbref who, dbref where, const char *xname, int type,
+                      long flags);
+extern dbref noisy_match_result(const dbref who, const char *name,
+                                const int type, const long flags);
+extern dbref last_match_result(const dbref who, const char *name,
+                               const int type, const long flags);
 extern dbref match_controlled(dbref player, const char *name);
+extern int match_aliases(dbref match, const char *name);
 
 #define match_thing(player,name) \
   noisy_match_result((player), (name), NOTYPE, MAT_EVERYTHING)
Index: hdrs/game.h
===================================================================
--- hdrs/game.h	(.../184p2)	(revision 828)
+++ hdrs/game.h	(.../184p3)	(revision 828)
@@ -46,7 +46,7 @@
 /* From command.c */
 enum hook_type { HOOK_BEFORE, HOOK_AFTER, HOOK_IGNORE, HOOK_OVERRIDE };
 extern void do_hook(dbref player, char *command, char *obj, char *attrname,
-                    enum hook_type flag);
+                    enum hook_type flag, int inplace);
 extern void do_hook_list(dbref player, char *command);
 
 
@@ -76,7 +76,7 @@
 extern void do_entrances(dbref player, const char *where, char **argv,
                          int types);
 enum dec_type { DEC_NORMAL, DEC_DB = 1, DEC_FLAG = 2, DEC_ATTR =
-    4, DEC_SKIPDEF = 8
+    4, DEC_SKIPDEF = 8, DEC_TF = 16
 };
 extern void do_decompile(dbref player, const char *name, const char *prefix,
                          int dec_type);
@@ -96,7 +96,7 @@
 /* From predicat.c */
 extern void do_switch
   (dbref player, char *expression, char **argv, dbref cause, int first,
-   int notifyme, int regexp);
+   int notifyme, int regexp, int inplace);
 extern void do_verb(dbref player, dbref cause, char *arg1, char **argv);
 extern void do_grep
   (dbref player, char *obj, char *lookfor, int flag, int insensitive);
@@ -166,7 +166,8 @@
 extern void do_allquota(dbref player, const char *arg1, int quiet);
 extern void do_teleport
   (dbref player, const char *arg1, const char *arg2, int silent, int inside);
-extern void do_force(dbref player, const char *what, char *command);
+extern void do_force(dbref player, dbref caller, const char *what, char *command,
+                     int inplace);
 extern void do_stats(dbref player, const char *name);
 extern void do_newpassword
   (dbref player, dbref cause, const char *name, const char *password);
@@ -181,7 +182,7 @@
   SITELOCK_CHECK, SITELOCK_LIST, SITELOCK_REGISTER
 };
 extern void do_sitelock(dbref player, const char *site, const char *opts,
-                        const char *charname, enum sitelock_type type);
+                        const char *charname, enum sitelock_type type, int psw);
 extern void do_sitelock_name(dbref player, const char *name);
 extern void do_chownall
   (dbref player, const char *name, const char *target, int preserve);
@@ -192,8 +193,17 @@
 extern void do_destroy(dbref player, char *name, int confirm);
 
 /* From timer.c */
-extern void init_timer(void);
-extern void signal_cpu_limit(int signo);
+void init_timer(void);
+void signal_cpu_limit(int signo);
+
+typedef bool(*sq_func) (void *);
+void sq_register(time_t w, sq_func f, void *d, const char *ev);
+void sq_register_in(int n, sq_func f, void *d, const char *ev);
+void sq_register_loop(int n, sq_func f, void *d, const char *ev);
+bool sq_run_one(void);
+bool sq_run_all(void);
+
+void init_sys_events(void);
 
 /* From version.c */
 extern void do_version(dbref player);
Index: hdrs/parse.h
===================================================================
--- hdrs/parse.h	(.../184p2)	(revision 828)
+++ hdrs/parse.h	(.../184p3)	(revision 828)
@@ -84,13 +84,13 @@
 bool is_boolean(char const *str);
 
 /* Split a sep-delimited string into individual elements */
-int list2arr(char *r[], int max, char *list, char sep);
+int list2arr(char *r[], int max, char *list, char sep, int nullok);
 /* The reverse */
 void arr2list(char *r[], int max, char *list, char **lp, const char *sep);
 /* Split a sep-delimited string into individual elements.
  * Uses mush_strdup, so freearr() is required on all
  * list2arr_ansi()'d arrays (r) */
-int list2arr_ansi(char *r[], int max, char *list, char sep);
+int list2arr_ansi(char *r[], int max, char *list, char sep, int nullok);
 /* Free an array generated by list2arr_ansi */
 void freearr(char *r[], int size);
 
@@ -194,6 +194,7 @@
 #define PE_DEBUG                0x00000400
 #define PE_BUILTINONLY          0x00000800
 #define PE_USERFN               0x00001000
+#define PE_NODEBUG              0x00002000
 
 #define PE_DEFAULT (PE_COMPRESS_SPACES | PE_STRIP_BRACES | \
                     PE_DOLLAR | PE_EVALUATE | PE_FUNCTION_CHECK)
@@ -237,6 +238,8 @@
  *
  * PE_USERFN means we're evaluating within an @function
  *
+ * PE_NODEBUG means we're not debugging this evaluation.
+ *
  *
  * tflags consists of one or more of the following termination flags:
  */
Index: hdrs/command.h
===================================================================
--- hdrs/command.h	(.../184p2)	(revision 828)
+++ hdrs/command.h	(.../184p3)	(revision 828)
@@ -90,13 +90,14 @@
  */
 
 #define COMMAND(command_name) \
-void command_name (COMMAND_INFO *cmd, dbref player, dbref cause, \
+void command_name (COMMAND_INFO *cmd, dbref player, dbref cause, dbref caller, \
  switch_mask sw, const char *raw, const char *switches, char *args_raw, \
                   char *arg_left, char *args_left[MAX_ARG], \
                   char *arg_right, char *args_right[MAX_ARG]); \
 void command_name(COMMAND_INFO *cmd __attribute__ ((__unused__)), \
                   dbref player __attribute__ ((__unused__)), \
                   dbref cause __attribute__ ((__unused__)), \
+                  dbref caller __attribute__ ((__unused__)), \
                   switch_mask sw __attribute__ ((__unused__)), \
                   const char *raw __attribute__ ((__unused__)), \
                   const char *switches __attribute__ ((__unused__)), \
@@ -108,12 +109,12 @@
 
 /** Common command prototype macro */
 #define COMMAND_PROTO(command_name) \
-void command_name (COMMAND_INFO *cmd, dbref player, dbref cause, switch_mask sw, const char *raw, const char *switches, char *args_raw, \
+void command_name (COMMAND_INFO *cmd, dbref player, dbref cause, dbref caller, switch_mask sw, const char *raw, const char *switches, char *args_raw, \
                   char *arg_left, char *args_left[MAX_ARG], \
                   char *arg_right, char *args_right[MAX_ARG])
 
 typedef struct command_info COMMAND_INFO;
-typedef void (*command_func) (COMMAND_INFO *, dbref, dbref, switch_mask,
+typedef void (*command_func) (COMMAND_INFO *, dbref, dbref, dbref, switch_mask,
                               const char *, const char *, char *, char *,
                               char *[MAX_ARG], char *, char *[MAX_ARG]);
 
@@ -122,6 +123,7 @@
 struct hook_data {
   dbref obj;            /**< Object where the hook attribute is stored. */
   char *attrname;       /**< Attribute name of the hook attribute */
+  int inplace;          /**< Valid only for override: Run hook in place. */
 };
 
 /** A command.
@@ -214,9 +216,9 @@
   (dbref player, dbref cause, char *from, char *to, char **args,
    COMMAND_INFO *cmd, int side);
 void command_argparse
-  (dbref player, dbref cause, char **from, char *to, char **argv,
+  (dbref player, dbref cause, dbref caller, char **from, char *to, char **argv,
    COMMAND_INFO *cmd, int side, int forcenoparse);
-char *command_parse(dbref player, dbref cause, char *string, int fromport);
+char *command_parse(dbref player, dbref cause, dbref caller, char *string, int fromport);
 void do_list_commands(dbref player, int lc, int type);
 char *list_commands(int type);
 int command_check(dbref player, COMMAND_INFO *cmd, int noisy);
@@ -237,4 +239,7 @@
 int cnf_hook_command(char *name, char *opts);
 
 
+#define SILENT_OR_NOISY(switches, default_silent) (SW_ISSET(switches, SWITCH_SILENT) ? PEMIT_SILENT : (SW_ISSET(switches, SWITCH_NOISY) ? 0 : (default_silent ? PEMIT_SILENT : 0)))
+
+
 #endif                          /* __COMMAND_H */
Index: hdrs/log.h
===================================================================
--- hdrs/log.h	(.../184p2)	(revision 828)
+++ hdrs/log.h	(.../184p3)	(revision 828)
@@ -1,35 +1,48 @@
 #ifndef LOG_H
 #define LOG_H
 
+#include "bufferq.h"
+#include <stdio.h>
+
 /* log types */
-#define LT_ERR    0
-#define LT_CMD    1
-#define LT_WIZ    2
-#define LT_CONN   3
-#define LT_TRACE  4
-#define LT_RPAGE  5             /* Obsolete */
-#define LT_CHECK  6
-#define LT_HUH    7
+enum log_type {
+  LT_ERR,
+  LT_CMD,
+  LT_WIZ,
+  LT_CONN,
+  LT_TRACE,
+  LT_CHECK,
+  LT_HUH
+};
+
+struct log_stream {
+  enum log_type type;
+  const char *name;
+  const char *filename;
+  FILE *fp;
+  BUFFERQ *buffer;
+};
+
 
 /* From log.c */
-extern void start_all_logs(void);
-extern void end_all_logs(void);
-extern void redirect_streams(void);
-extern void WIN32_CDECL do_log
-  (int logtype, dbref player, dbref object, const char *fmt, ...)
+struct log_stream *lookup_log(enum log_type);
+void start_all_logs(void);
+void end_all_logs(void);
+void redirect_streams(void);
+void WIN32_CDECL do_log
+  (enum log_type logtype, dbref player, dbref object, const char *fmt, ...)
   __attribute__ ((__format__(__printf__, 4, 5)));
-extern void WIN32_CDECL do_rawlog(int logtype, const char *fmt, ...)
+void WIN32_CDECL do_rawlog(enum log_type logtype, const char *fmt, ...)
   __attribute__ ((__format__(__printf__, 2, 3)));
-extern void do_logwipe(dbref player, int logtype, char *str);
+void do_logwipe(dbref player, enum log_type logtype, char *str);
+void do_log_recall(dbref, enum log_type, int);
 
 /* Activity log types */
-#define LA_CMD  0
-#define LA_PE   1
-#define LA_LOCK 2
+enum log_act_type { LA_CMD, LA_PE, LA_LOCK };
 #define ACTIVITY_LOG_SIZE 3     /* In BUFFER_LEN-size lines */
-extern void log_activity(int type, dbref player, const char *action);
-extern void notify_activity(dbref player, int num_lines, int dump);
-extern const char *last_activity(void);
-extern int last_activity_type(void);
+void log_activity(enum log_act_type type, dbref player, const char *action);
+void notify_activity(dbref player, int num_lines, int dump);
+const char *last_activity(void);
+int last_activity_type(void);
 
 #endif                          /* LOG_H */
Index: hdrs/svninfo.h
===================================================================
--- hdrs/svninfo.h	(.../184p2)	(revision 828)
+++ hdrs/svninfo.h	(.../184p3)	(revision 828)
@@ -1,3 +1,3 @@
 #define SVNREVISION "$Rev$"
 #define SVNDATE "$Date$"
-/* Built at 20101205073940 */
+/* Built at 20110318182853 */
Index: hdrs/version.h
===================================================================
--- hdrs/version.h	(.../184p2)	(revision 828)
+++ hdrs/version.h	(.../184p3)	(revision 828)
@@ -1,4 +1,4 @@
 #define VERSION "1.8.4"
-#define PATCHLEVEL "2"
-#define PATCHDATE "[12/06/2010]"
-#define NUMVERSION 1008004002
+#define PATCHLEVEL "3"
+#define PATCHDATE "[03/18/2011]"
+#define NUMVERSION 1008004003
Index: hdrs/dbdefs.h
===================================================================
--- hdrs/dbdefs.h	(.../184p2)	(revision 828)
+++ hdrs/dbdefs.h	(.../184p3)	(revision 828)
@@ -174,6 +174,7 @@
 #define AF_Prefixmatch(a) ((a)->flags & AF_PREFIXMATCH)
 #define AF_Veiled(a) ((a)->flags & AF_VEILED)
 #define AF_Debug(a) ((a)->flags & AF_DEBUG)
+#define AF_NoDebug(a) ((a)->flags & AF_NODEBUG)
 #define AF_Nearby(a) ((a)->flags & AF_NEARBY)
 #define AF_Public(a) ((a)->flags & AF_PUBLIC)
 #define AF_Mhear(a) ((a)->flags & AF_MHEAR)
Index: hdrs/sort.h
===================================================================
--- hdrs/sort.h	(.../184p2)	(revision 828)
+++ hdrs/sort.h	(.../184p3)	(revision 828)
@@ -3,19 +3,64 @@
 #include "copyrite.h"
 
 /* Sort and comparision functions */
+typedef char *SortType;
+typedef struct sort_record s_rec;
+typedef int (*qsort_func) (const void *, const void *);
+typedef void (*makerecord) (s_rec *, dbref player, char *sortflags);
+typedef struct _list_type_info_ ListTypeInfo;
 
-#define MAX_SORTSIZE (BUFFER_LEN / 2)  /**< Maximum number of elements to sort */
+/** Sorting strings by different values. We store both the string and
+ * its 'key' to sort by. Sort of a hardcode munge.
+ */
+struct sort_record {
+  char *ptr;     /**< NULL except for sortkey */
+  char *val;     /**< The string this is */
+  dbref db;      /**< dbref (default 0, bad is -1) */
+  union {
+    struct {
+      char *s;     /**< string comparisons */
+      bool freestr;   /**< free str on completion */
+    } str;
+    int num;       /**< integer comparisons */
+    NVAL numval;   /**< float comparisons */
+    time_t tm;     /**< time comparisions */
+  } memo;
+};
 
-typedef char *SortType;
+struct _list_type_info_ {
+  SortType name;
+  char *attrname;
+  int sort_order;
+  makerecord make_record;
+  qsort_func sorter;
+  uint32_t flags;
+};
+
+ListTypeInfo *get_list_type_info(SortType type);
+
+#define MAX_SORTSIZE (BUFFER_LEN / 2)  /**< Maximum number of elements to sort */
 
 SortType autodetect_list(char **ptrs, int nptrs);
 SortType autodetect_2lists(char *ptrs[], int nptrs, char *ptrs2[], int nptrs2);
 SortType get_list_type(char *args[], int nargs, int type_pos, char *ptrs[],
                        int nptrs);
 SortType get_list_type_noauto(char *args[], int nargs, int type_pos);
+
+/** Routines to actually deal with (sort) lists. */
+ListTypeInfo *get_list_type_info(SortType sort_type);
+void free_list_type_info(ListTypeInfo * lti);
+s_rec *slist_build(dbref player, char *keys[], char *strs[], int n,
+                   ListTypeInfo * lti);
+void slist_qsort(s_rec *sp, int n, ListTypeInfo * lti);
+int slist_uniq(s_rec *sp, int n, ListTypeInfo * lti);
+void slist_free(s_rec *sp, int n, ListTypeInfo * lti);
+int slist_comp(s_rec *s1, s_rec *s2, ListTypeInfo * lti);
+
+/** General-use sorting routines, good for most purposes. */
 int gencomp(dbref player, char *a, char *b, SortType sort_type);
 void do_gensort(dbref player, char *keys[], char *strs[], int n,
                 SortType sort_type);
+
 /** Type definition for a qsort comparison function */
 typedef int (*comp_func) (const void *, const void *);
 void sane_qsort(void **array, int left, int right, comp_func compare);
Index: hdrs/externs.h
===================================================================
--- hdrs/externs.h	(.../184p2)	(revision 828)
+++ hdrs/externs.h	(.../184p3)	(revision 828)
@@ -54,7 +54,7 @@
 
 extern int shutdown_flag;       /* if non-zero, interface should shut down */
 void emergency_shutdown(void);
-void boot_desc(DESC *d);        /* remove a player */
+void boot_desc(DESC *d, const char *cause);     /* remove a player */
 int boot_player(dbref player, int idleonly, int slilent);
 DESC *player_desc(dbref player);        /* find descriptors */
 DESC *inactive_desc(dbref player);      /* find descriptors */
@@ -71,7 +71,7 @@
 void do_doing(dbref player, const char *message);
 
 /* the following symbols are provided by game.c */
-void process_command(dbref player, char *command, dbref cause, int from_port);
+void process_command(dbref player, char *command, dbref cause, dbref caller, int from_port);
 int init_game_dbs(void);
 void init_game_postdb(const char *conf);
 void init_game_config(const char *conf);
@@ -223,6 +223,13 @@
 #endif
 
 /* From cque.c */
+#define QUEUE_PLAYER 0
+#define QUEUE_OBJECT 1
+/* INPLACE and RECURSE are identical except that RECURSE does not
+ * propagate @breaks upward. */
+#define QUEUE_INPLACE 2
+#define QUEUE_RECURSE 3
+struct bque;
 struct _ansi_string;
 struct real_pcre;
 struct eval_context {
@@ -236,9 +243,7 @@
   char ucom[BUFFER_LEN];      /**< evaluated command */
   int break_called;           /**< Has the break command been called? */
   char break_replace[BUFFER_LEN];  /**< What to replace the break with */
-  int include_called;           /**< Has the include command been called? */
-  char include_replace[BUFFER_LEN];  /**< What to replace the include with */
-  char *include_wenv[10];       /**< Working env for include */
+  struct bque *inplace_queue;          /**< Inplace (include, @switch/inplace) commands */
   struct real_pcre *re_code;              /**< The compiled re */
   int re_subpatterns;         /**< The number of re subpatterns */
   int *re_offsets;            /**< The offsets for the subpatterns */
@@ -252,14 +257,21 @@
 void do_second(void);
 int do_top(int ncom);
 void do_halt(dbref owner, const char *ncom, dbref victim);
+#define SYSEVENT -1
+bool queue_event(dbref enactor, const char *event, const char *fmt, ...)
+  __attribute__ ((__format__(__printf__, 3, 4)));
+void insert_que(dbref player, const char *command, dbref cause, dbref caller,
+                PE_Info *pe_info, char **env, char **rval, int quetype);
 void parse_que(dbref player, const char *command, dbref cause,
                PE_Info *pe_info);
 int queue_attribute_base(dbref executor, const char *atrname, dbref enactor,
                          int noparent);
 ATTR *queue_attribute_getatr(dbref executor, const char *atrname, int noparent);
 int queue_attribute_useatr(dbref executor, ATTR *a, dbref enactor);
-int inplace_queue_attribute(dbref thing, const char *atrname,
-                            dbref enactor, int rsargs);
+void inplace_queue_actionlist(dbref executor, dbref cause, dbref caller,
+                              const char *command, char **argv, int quetype);
+int queue_include_attribute(dbref thing, const char *atrname,
+                            dbref executor, dbref cause, dbref caller, char **args);
 void run_user_input(dbref player, char *input);
 
 /** Queue the code in an attribute, including parent objects */
@@ -322,13 +334,15 @@
 void log_mem_check(void);
 
 /* From move.c */
-void enter_room(dbref player, dbref loc, int nomovemsgs);
+void enter_room(dbref player, dbref loc, int nomovemsgs,
+                dbref enactor, const char *cause);
 int can_move(dbref player, const char *direction);
 /** Enumeration of types of movements that can be performed */
 enum move_type { MOVE_NORMAL, MOVE_GLOBAL, MOVE_ZONE };
 void do_move(dbref player, const char *direction, enum move_type type);
-void moveto(dbref what, dbref where);
-void safe_tel(dbref player, dbref dest, int nomovemsgs);
+void moveto(dbref what, dbref where, dbref enactor, const char *cause);
+void safe_tel(dbref player, dbref dest, int nomovemsgs,
+              dbref enactor, const char *cause);
 int global_exit(dbref player, const char *direction);
 int remote_exit(dbref loc, const char *direction);
 void move_wrapper(dbref player, const char *command);
@@ -343,13 +357,17 @@
 char *mush_crypt(const char *key);
 
 /* From player.c */
+extern const char *connect_fail_limit_exceeded;
+int mark_failed(const char *ipaddr);
+int count_failed(const char *ipaddr);
+int check_fails(const char *ipaddr);
 int password_check(dbref player, const char *password);
 dbref lookup_player(const char *name);
 dbref lookup_player_name(const char *name);
 /* from player.c */
-dbref create_player(const char *name, const char *password,
+dbref create_player(DESC *d, const char *name, const char *password,
                     const char *host, const char *ip);
-dbref connect_player(const char *name, const char *password,
+dbref connect_player(DESC *d, const char *name, const char *password,
                      const char *host, const char *ip, char *errbuf);
 void check_last(dbref player, const char *host, const char *ip);
 void check_lastfailed(dbref player, const char *host);
@@ -399,7 +417,9 @@
 int nearby(dbref obj1, dbref obj2);
 int get_current_quota(dbref who);
 void change_quota(dbref who, int payment);
-int ok_name(const char *name);
+int ok_name(const char *name, int is_exit);
+int ok_object_name(char *name, dbref player, dbref thing, int type,
+                   char **newname, char **newalias);
 int ok_command_name(const char *name);
 int ok_function_name(const char *name);
 int ok_player_name(const char *name, dbref player, dbref thing);
@@ -426,9 +446,9 @@
 
 /* From set.c */
 void chown_object(dbref player, dbref thing, dbref newowner, int preserve);
-void do_include(dbref player, char *object, char **argv);
+void do_include(dbref player, dbref cause, char *object, char **argv);
 /* From speech.c */
-int okay_pemit(dbref player, dbref target);
+int okay_pemit(dbref player, dbref target, int dofails, const char *def);
 int vmessageformat(dbref player, const char *attribute,
                    dbref executor, int flags, int nargs, ...);
 int messageformat(dbref player, const char *attribute,
@@ -565,6 +585,7 @@
     const char *real_unparse
       (dbref player, dbref loc, int obey_myopic, int use_nameformat,
        int use_nameaccent);
+    extern const char *unparse_objid(dbref thing);
     extern const char *unparse_object(dbref player, dbref loc);
 /** For back compatibility, an alias for unparse_object */
 #define object_header(p,l) unparse_object(p,l)
@@ -732,7 +753,7 @@
     void local_dump_database(void);
     void local_dbck(void);
     void local_shutdown(void);
-    void local_timer(void);
+    bool local_timer(void *data);
     void local_connect(dbref player, int isnew, int num);
     void local_disconnect(dbref player, int num);
     void local_data_create(dbref object);
